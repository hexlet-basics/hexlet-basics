# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-http-cache` gem.
# Please instead update this file by running `bin/tapioca gem async-http-cache`.


# source://async-http-cache//lib/async/http/cache/version.rb#7
module Async; end

# source://async-http-cache//lib/async/http/cache/version.rb#9
module Async::HTTP; end

# source://async-http-cache//lib/async/http/cache/version.rb#11
module Async::HTTP::Cache; end

# Provides utilities for wrapping HTTP response bodies with caching capabilities.
#
# source://async-http-cache//lib/async/http/cache/body.rb#17
module Async::HTTP::Cache::Body
  class << self
    # Wrap a response body with caching functionality, including ETag generation and completion handling.
    #
    # source://async-http-cache//lib/async/http/cache/body.rb#27
    def wrap(response, &block); end
  end
end

# source://async-http-cache//lib/async/http/cache/body.rb#19
Async::HTTP::Cache::Body::ETAG = T.let(T.unsafe(nil), String)

# source://async-http-cache//lib/async/http/cache/body.rb#18
Async::HTTP::Cache::Body::TRAILER = T.let(T.unsafe(nil), String)

# Implements a general shared cache according to https://www.rfc-editor.org/rfc/rfc9111
#
# source://async-http-cache//lib/async/http/cache/general.rb#18
class Async::HTTP::Cache::General < ::Protocol::HTTP::Middleware
  # Initialize a new cache middleware instance.
  #
  # @return [General] a new instance of General
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#43
  def initialize(app, store: T.unsafe(nil)); end

  # Determine if a request is cacheable based on method, headers, and body.
  #
  # @return [Boolean]
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#73
  def cacheable_request?(request); end

  # Determine if a response is cacheable based on status code and headers.
  #
  # @return [Boolean]
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#123
  def cacheable_response?(response); end

  # Check if response headers allow caching.
  #
  # @return [Boolean]
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#104
  def cacheable_response_headers?(headers); end

  # Process an HTTP request, checking cache first and storing responses when appropriate.
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#184
  def call(request); end

  # Close the cache and clean up resources.
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#55
  def close; end

  # Returns the value of attribute count.
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#51
  def count; end

  # Generate a cache key for the given request.
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#64
  def key(request); end

  # Semantically speaking, it is possible for trailers to result in an uncacheable response, so we need to check for that.
  #
  # @return [Boolean]
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#140
  def proceed_with_response_cache?(response); end

  # Returns the value of attribute store.
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#52
  def store; end

  # Potentially wrap the response so that it updates the cache, if caching is possible.
  #
  # source://async-http-cache//lib/async/http/cache/general.rb#152
  def wrap(key, request, response); end
end

# source://async-http-cache//lib/async/http/cache/general.rb#22
Async::HTTP::Cache::General::AUTHORIZATION = T.let(T.unsafe(nil), String)

# Status codes of responses that MAY be stored by a cache or used in reply
# to a subsequent request.
#
# http://tools.ietf.org/html/rfc2616#section-13.4
#
# source://async-http-cache//lib/async/http/cache/general.rb#30
Async::HTTP::Cache::General::CACHEABLE_RESPONSE_CODES = T.let(T.unsafe(nil), Hash)

# source://async-http-cache//lib/async/http/cache/general.rb#19
Async::HTTP::Cache::General::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://async-http-cache//lib/async/http/cache/general.rb#21
Async::HTTP::Cache::General::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://async-http-cache//lib/async/http/cache/general.rb#23
Async::HTTP::Cache::General::COOKIE = T.let(T.unsafe(nil), String)

# source://async-http-cache//lib/async/http/cache/general.rb#24
Async::HTTP::Cache::General::SET_COOKIE = T.let(T.unsafe(nil), String)

# Represents a cached HTTP response with cache-specific metadata and functionality.
#
# source://async-http-cache//lib/async/http/cache/response.rb#13
class Async::HTTP::Cache::Response < ::Protocol::HTTP::Response
  # Initialize a new cached response.
  #
  # @return [Response] a new instance of Response
  #
  # source://async-http-cache//lib/async/http/cache/response.rb#22
  def initialize(response, body); end

  # Calculate the age of this cached response in seconds.
  #
  # source://async-http-cache//lib/async/http/cache/response.rb#49
  def age; end

  # Create a duplicate of this cached response with independent body and headers.
  #
  # source://async-http-cache//lib/async/http/cache/response.rb#63
  def dup; end

  # Get the ETag header value for this cached response.
  #
  # source://async-http-cache//lib/async/http/cache/response.rb#43
  def etag; end

  # Check if this cached response has expired based on its max-age.
  #
  # @return [Boolean]
  #
  # source://async-http-cache//lib/async/http/cache/response.rb#55
  def expired?; end

  # Returns the value of attribute generated_at.
  #
  # source://async-http-cache//lib/async/http/cache/response.rb#39
  def generated_at; end
end

# source://async-http-cache//lib/async/http/cache/response.rb#14
Async::HTTP::Cache::Response::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://async-http-cache//lib/async/http/cache/response.rb#15
Async::HTTP::Cache::Response::ETAG = T.let(T.unsafe(nil), String)

# source://async-http-cache//lib/async/http/cache/response.rb#17
Async::HTTP::Cache::Response::X_CACHE = T.let(T.unsafe(nil), String)

# Provides cache storage implementations and utilities.
#
# source://async-http-cache//lib/async/http/cache/store/memory.rb#9
module Async::HTTP::Cache::Store
  class << self
    # Create a default cache store with Vary support over an in-memory store.
    #
    # source://async-http-cache//lib/async/http/cache/store.rb#16
    def default; end
  end
end

# source://async-http-cache//lib/async/http/cache/store/vary.rb#11
Async::HTTP::Cache::Store::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)

# Represents an in-memory cache store with automatic pruning of expired entries.
#
# source://async-http-cache//lib/async/http/cache/store/memory.rb#11
class Async::HTTP::Cache::Store::Memory
  # Initialize a new in-memory cache store.
  #
  # @return [Memory] a new instance of Memory
  #
  # source://async-http-cache//lib/async/http/cache/store/memory.rb#16
  def initialize(limit: T.unsafe(nil), maximum_size: T.unsafe(nil), prune_interval: T.unsafe(nil)); end

  # Close the cache store and stop background pruning.
  #
  # source://async-http-cache//lib/async/http/cache/store/memory.rb#51
  def close; end

  # Returns the value of attribute index.
  #
  # source://async-http-cache//lib/async/http/cache/store/memory.rb#55
  def index; end

  # Insert a response into the cache if it meets size and limit constraints.
  #
  # source://async-http-cache//lib/async/http/cache/store/memory.rb#94
  def insert(key, request, response); end

  # Look up a cached response for the given key and request.
  #
  # source://async-http-cache//lib/async/http/cache/store/memory.rb#64
  def lookup(key, request); end

  # @return [Integer] the number of pruned entries.
  #
  # source://async-http-cache//lib/async/http/cache/store/memory.rb#104
  def prune; end
end

# source://async-http-cache//lib/async/http/cache/store/memory.rb#57
Async::HTTP::Cache::Store::Memory::IF_NONE_MATCH = T.let(T.unsafe(nil), String)

# source://async-http-cache//lib/async/http/cache/store/memory.rb#58
Async::HTTP::Cache::Store::Memory::NOT_MODIFIED = T.let(T.unsafe(nil), Protocol::HTTP::Response)

# source://async-http-cache//lib/async/http/cache/store/vary.rb#10
Async::HTTP::Cache::Store::VARY = T.let(T.unsafe(nil), String)

# Represents a cache store wrapper that handles HTTP Vary header functionality.
#
# source://async-http-cache//lib/async/http/cache/store/vary.rb#14
class Async::HTTP::Cache::Store::Vary
  # Initialize a new Vary store wrapper.
  #
  # @return [Vary] a new instance of Vary
  #
  # source://async-http-cache//lib/async/http/cache/store/vary.rb#18
  def initialize(delegate, vary = T.unsafe(nil)); end

  # Close the vary store and its delegate.
  #
  # source://async-http-cache//lib/async/http/cache/store/vary.rb#24
  def close; end

  # Returns the value of attribute delegate.
  #
  # source://async-http-cache//lib/async/http/cache/store/vary.rb#28
  def delegate; end

  # Insert a response into the cache, handling vary headers appropriately.
  #
  # source://async-http-cache//lib/async/http/cache/store/vary.rb#67
  def insert(key, request, response); end

  # Generate vary-specific key components from request headers.
  #
  # source://async-http-cache//lib/async/http/cache/store/vary.rb#46
  def key_for(headers, vary); end

  # Look up a cached response, accounting for vary headers.
  #
  # source://async-http-cache//lib/async/http/cache/store/vary.rb#54
  def lookup(key, request); end

  # Normalize request headers to reduce cache key variations.
  #
  # source://async-http-cache//lib/async/http/cache/store/vary.rb#32
  def normalize(request); end
end

# source://async-http-cache//lib/async/http/cache/version.rb#12
Async::HTTP::Cache::VERSION = T.let(T.unsafe(nil), String)
