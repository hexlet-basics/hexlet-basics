# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `solid_queue` gem.
# Please instead update this file by running `bin/tapioca gem solid_queue`.


# source://solid_queue//lib/active_job/concurrency_controls.rb#3
module ActiveJob
  class << self
    # source://activejob/8.0.1/lib/active_job/queue_adapter.rb#7
    def adapter_name(adapter); end

    # source://activejob/8.0.1/lib/active_job/deprecator.rb#4
    def deprecator; end

    # source://activejob/8.0.1/lib/active_job/gem_version.rb#5
    def gem_version; end

    # source://activejob/8.0.1/lib/active_job/enqueuing.rb#14
    def perform_all_later(*jobs); end

    # source://activejob/8.0.1/lib/active_job.rb#57
    def verbose_enqueue_logs; end

    # source://activejob/8.0.1/lib/active_job.rb#57
    def verbose_enqueue_logs=(_arg0); end

    # source://activejob/8.0.1/lib/active_job/version.rb#7
    def version; end

    private

    # source://activejob/8.0.1/lib/active_job/instrumentation.rb#6
    def instrument_enqueue_all(queue_adapter, jobs); end
  end
end

class ActiveJob::Base
  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
  def __callbacks; end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#923
  def _enqueue_callbacks; end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#923
  def _perform_callbacks; end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#911
  def _run_enqueue_callbacks(&block); end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#911
  def _run_perform_callbacks(&block); end

  # source://activejob/8.0.1/lib/active_job/exceptions.rb#12
  def after_discard_procs; end

  # source://activejob/8.0.1/lib/active_job/exceptions.rb#12
  def after_discard_procs=(_arg0); end

  # source://activejob/8.0.1/lib/active_job/exceptions.rb#12
  def after_discard_procs?; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration=(_arg0); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration?; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit=(_arg0); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit?; end

  # source://activejob/8.0.1/lib/active_job/logging.rb#15
  def logger; end

  # source://activejob/8.0.1/lib/active_job/logging.rb#15
  def logger=(val); end

  # source://activejob/8.0.1/lib/active_job/queue_adapter.rb#27
  def queue_adapter(&_arg0); end

  # source://activejob/8.0.1/lib/active_job/queue_name.rb#57
  def queue_name_prefix; end

  # source://activejob/8.0.1/lib/active_job/queue_name.rb#57
  def queue_name_prefix=(_arg0); end

  # source://activejob/8.0.1/lib/active_job/queue_name.rb#57
  def queue_name_prefix?; end

  # source://activesupport/8.0.1/lib/active_support/rescuable.rb#15
  def rescue_handlers; end

  # source://activesupport/8.0.1/lib/active_support/rescuable.rb#15
  def rescue_handlers=(_arg0); end

  # source://activesupport/8.0.1/lib/active_support/rescuable.rb#15
  def rescue_handlers?; end

  class << self
    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
    def __callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
    def __callbacks=(value); end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#915
    def _enqueue_callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#919
    def _enqueue_callbacks=(value); end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#915
    def _perform_callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#919
    def _perform_callbacks=(value); end

    # source://activejob/8.0.1/lib/active_job/queue_adapter.rb#25
    def _queue_adapter; end

    # source://activejob/8.0.1/lib/active_job/queue_adapter.rb#25
    def _queue_adapter=(value); end

    # source://activejob/8.0.1/lib/active_job/queue_adapter.rb#24
    def _queue_adapter_name; end

    # source://activejob/8.0.1/lib/active_job/queue_adapter.rb#24
    def _queue_adapter_name=(value); end

    # source://activejob/8.0.1/lib/active_job/test_helper.rb#19
    def _test_adapter; end

    # source://activejob/8.0.1/lib/active_job/test_helper.rb#19
    def _test_adapter=(value); end

    # source://activejob/8.0.1/lib/active_job/exceptions.rb#12
    def after_discard_procs; end

    # source://activejob/8.0.1/lib/active_job/exceptions.rb#12
    def after_discard_procs=(value); end

    # source://activejob/8.0.1/lib/active_job/exceptions.rb#12
    def after_discard_procs?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit?; end

    # source://activejob/8.0.1/lib/active_job/enqueuing.rb#53
    def enqueue_after_transaction_commit; end

    # source://activejob/8.0.1/lib/active_job/enqueuing.rb#53
    def enqueue_after_transaction_commit=(value); end

    # source://activejob/8.0.1/lib/active_job/logging.rb#26
    def log_arguments; end

    # source://activejob/8.0.1/lib/active_job/logging.rb#26
    def log_arguments=(value); end

    # source://activejob/8.0.1/lib/active_job/logging.rb#26
    def log_arguments?; end

    # source://activejob/8.0.1/lib/active_job/logging.rb#15
    def logger; end

    # source://activejob/8.0.1/lib/active_job/logging.rb#15
    def logger=(val); end

    # source://activejob/8.0.1/lib/active_job/queue_priority.rb#49
    def priority; end

    # source://activejob/8.0.1/lib/active_job/queue_priority.rb#49
    def priority=(value); end

    # source://activejob/8.0.1/lib/active_job/queue_priority.rb#49
    def priority?; end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#55
    def queue_name; end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#55
    def queue_name=(value); end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#55
    def queue_name?; end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#56
    def queue_name_delimiter; end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#56
    def queue_name_delimiter=(value); end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#56
    def queue_name_delimiter?; end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#57
    def queue_name_prefix; end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#57
    def queue_name_prefix=(value); end

    # source://activejob/8.0.1/lib/active_job/queue_name.rb#57
    def queue_name_prefix?; end

    # source://activesupport/8.0.1/lib/active_support/rescuable.rb#15
    def rescue_handlers; end

    # source://activesupport/8.0.1/lib/active_support/rescuable.rb#15
    def rescue_handlers=(value); end

    # source://activesupport/8.0.1/lib/active_support/rescuable.rb#15
    def rescue_handlers?; end

    # source://activejob/8.0.1/lib/active_job/exceptions.rb#11
    def retry_jitter; end

    # source://activejob/8.0.1/lib/active_job/exceptions.rb#11
    def retry_jitter=(value); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__queue_adapter; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__queue_adapter=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__queue_adapter_name; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__queue_adapter_name=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__test_adapter; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__test_adapter=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_after_discard_procs; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_after_discard_procs=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_concurrency_duration; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_concurrency_duration=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_concurrency_group; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_concurrency_group=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_concurrency_key; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_concurrency_key=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_concurrency_limit; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_concurrency_limit=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_enqueue_after_transaction_commit; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_enqueue_after_transaction_commit=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_log_arguments; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_log_arguments=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_priority; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_priority=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_queue_name; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_queue_name=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_queue_name_delimiter; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_queue_name_delimiter=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_queue_name_prefix; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_queue_name_prefix=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_rescue_handlers; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_rescue_handlers=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_retry_jitter; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_retry_jitter=(new_value); end
  end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#4
module ActiveJob::ConcurrencyControls
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveJob::ConcurrencyControls::ClassMethods

  # source://solid_queue//lib/active_job/concurrency_controls.rb#26
  def concurrency_key; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/active_job/concurrency_controls.rb#39
  def concurrency_limited?; end

  private

  # source://solid_queue//lib/active_job/concurrency_controls.rb#48
  def compute_concurrency_parameter(option); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#44
  def concurrency_group; end

  module GeneratedClassMethods
    def concurrency_duration; end
    def concurrency_duration=(value); end
    def concurrency_duration?; end
    def concurrency_group; end
    def concurrency_group=(value); end
    def concurrency_group?; end
    def concurrency_key; end
    def concurrency_key=(value); end
    def concurrency_key?; end
    def concurrency_limit; end
    def concurrency_limit=(value); end
    def concurrency_limit?; end
  end

  module GeneratedInstanceMethods
    def concurrency_duration; end
    def concurrency_duration=(value); end
    def concurrency_duration?; end
    def concurrency_limit; end
    def concurrency_limit=(value); end
    def concurrency_limit?; end
  end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#0
module ActiveJob::ConcurrencyControls::ClassMethods
  # source://solid_queue//lib/active_job/concurrency_controls.rb#18
  def limits_concurrency(key:, to: T.unsafe(nil), group: T.unsafe(nil), duration: T.unsafe(nil)); end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#7
ActiveJob::ConcurrencyControls::DEFAULT_CONCURRENCY_GROUP = T.let(T.unsafe(nil), Proc)

# source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#4
module ActiveJob::QueueAdapters
  class << self
    # source://activejob/8.0.1/lib/active_job/queue_adapters.rb#135
    def lookup(name); end
  end
end

# == Active Job SolidQueue adapter
#
# To use it set the queue_adapter config to +:solid_queue+.
#
#   Rails.application.config.active_job.queue_adapter = :solid_queue
#
# source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#10
class ActiveJob::QueueAdapters::SolidQueueAdapter
  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#15
  def enqueue(active_job); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#11
  def enqueue_after_transaction_commit?; end

  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#23
  def enqueue_all(active_jobs); end

  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#19
  def enqueue_at(active_job, timestamp); end
end

# source://solid_queue//lib/solid_queue/version.rb#1
module SolidQueue
  extend ::SolidQueue

  # source://solid_queue//lib/solid_queue.rb#26
  def app_executor; end

  # source://solid_queue//lib/solid_queue.rb#26
  def app_executor=(val); end

  # source://solid_queue//lib/solid_queue.rb#41
  def clear_finished_jobs_after; end

  # source://solid_queue//lib/solid_queue.rb#41
  def clear_finished_jobs_after=(val); end

  # source://solid_queue//lib/solid_queue.rb#26
  def connects_to; end

  # source://solid_queue//lib/solid_queue.rb#26
  def connects_to=(val); end

  # source://solid_queue//lib/solid_queue.rb#42
  def default_concurrency_control_period; end

  # source://solid_queue//lib/solid_queue.rb#42
  def default_concurrency_control_period=(val); end

  # source://solid_queue//lib/solid_queue.rb#66
  def instrument(channel, **options, &block); end

  # source://solid_queue//lib/solid_queue.rb#25
  def logger; end

  # source://solid_queue//lib/solid_queue.rb#25
  def logger=(val); end

  # source://solid_queue//lib/solid_queue.rb#44
  def on_start(&_arg0); end

  # source://solid_queue//lib/solid_queue.rb#44
  def on_stop(&_arg0); end

  # source://solid_queue//lib/solid_queue.rb#26
  def on_thread_error; end

  # source://solid_queue//lib/solid_queue.rb#26
  def on_thread_error=(val); end

  # source://solid_queue//lib/solid_queue.rb#46
  def on_worker_start(*_arg0, **_arg1, &_arg2); end

  # source://solid_queue//lib/solid_queue.rb#50
  def on_worker_stop(*_arg0, **_arg1, &_arg2); end

  # source://solid_queue//lib/solid_queue.rb#40
  def preserve_finished_jobs; end

  # source://solid_queue//lib/solid_queue.rb#40
  def preserve_finished_jobs=(val); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue.rb#62
  def preserve_finished_jobs?; end

  # source://solid_queue//lib/solid_queue.rb#31
  def process_alive_threshold; end

  # source://solid_queue//lib/solid_queue.rb#31
  def process_alive_threshold=(val); end

  # source://solid_queue//lib/solid_queue.rb#30
  def process_heartbeat_interval; end

  # source://solid_queue//lib/solid_queue.rb#30
  def process_heartbeat_interval=(val); end

  # source://solid_queue//lib/solid_queue.rb#33
  def shutdown_timeout; end

  # source://solid_queue//lib/solid_queue.rb#33
  def shutdown_timeout=(val); end

  # source://solid_queue//lib/solid_queue.rb#35
  def silence_polling; end

  # source://solid_queue//lib/solid_queue.rb#35
  def silence_polling=(val); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue.rb#58
  def silence_polling?; end

  # source://solid_queue//lib/solid_queue.rb#38
  def supervisor; end

  # source://solid_queue//lib/solid_queue.rb#38
  def supervisor=(val); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue.rb#54
  def supervisor?; end

  # source://solid_queue//lib/solid_queue.rb#37
  def supervisor_pidfile; end

  # source://solid_queue//lib/solid_queue.rb#37
  def supervisor_pidfile=(val); end

  # source://solid_queue//lib/solid_queue.rb#28
  def use_skip_locked; end

  # source://solid_queue//lib/solid_queue.rb#28
  def use_skip_locked=(val); end

  class << self
    # source://solid_queue//lib/solid_queue.rb#26
    def app_executor; end

    # source://solid_queue//lib/solid_queue.rb#26
    def app_executor=(val); end

    # source://solid_queue//lib/solid_queue.rb#41
    def clear_finished_jobs_after; end

    # source://solid_queue//lib/solid_queue.rb#41
    def clear_finished_jobs_after=(val); end

    # source://solid_queue//lib/solid_queue.rb#26
    def connects_to; end

    # source://solid_queue//lib/solid_queue.rb#26
    def connects_to=(val); end

    # source://solid_queue//lib/solid_queue.rb#42
    def default_concurrency_control_period; end

    # source://solid_queue//lib/solid_queue.rb#42
    def default_concurrency_control_period=(val); end

    # source://solid_queue//lib/solid_queue.rb#25
    def logger; end

    # source://solid_queue//lib/solid_queue.rb#25
    def logger=(val); end

    # source://solid_queue//lib/solid_queue.rb#26
    def on_thread_error; end

    # source://solid_queue//lib/solid_queue.rb#26
    def on_thread_error=(val); end

    # source://solid_queue//lib/solid_queue.rb#40
    def preserve_finished_jobs; end

    # source://solid_queue//lib/solid_queue.rb#40
    def preserve_finished_jobs=(val); end

    # source://solid_queue//lib/solid_queue.rb#31
    def process_alive_threshold; end

    # source://solid_queue//lib/solid_queue.rb#31
    def process_alive_threshold=(val); end

    # source://solid_queue//lib/solid_queue.rb#30
    def process_heartbeat_interval; end

    # source://solid_queue//lib/solid_queue.rb#30
    def process_heartbeat_interval=(val); end

    # source://railties/8.0.1/lib/rails/engine.rb#413
    def railtie_helpers_paths; end

    # source://railties/8.0.1/lib/rails/engine.rb#396
    def railtie_namespace; end

    # source://railties/8.0.1/lib/rails/engine.rb#417
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # source://solid_queue//lib/solid_queue.rb#33
    def shutdown_timeout; end

    # source://solid_queue//lib/solid_queue.rb#33
    def shutdown_timeout=(val); end

    # source://solid_queue//lib/solid_queue.rb#35
    def silence_polling; end

    # source://solid_queue//lib/solid_queue.rb#35
    def silence_polling=(val); end

    # source://solid_queue//lib/solid_queue.rb#38
    def supervisor; end

    # source://solid_queue//lib/solid_queue.rb#38
    def supervisor=(val); end

    # source://solid_queue//lib/solid_queue.rb#37
    def supervisor_pidfile; end

    # source://solid_queue//lib/solid_queue.rb#37
    def supervisor_pidfile=(val); end

    # source://railties/8.0.1/lib/rails/engine.rb#402
    def table_name_prefix; end

    # source://railties/8.0.1/lib/rails/engine.rb#409
    def use_relative_model_naming?; end

    # source://solid_queue//lib/solid_queue.rb#28
    def use_skip_locked; end

    # source://solid_queue//lib/solid_queue.rb#28
    def use_skip_locked=(val); end
  end
end

# source://solid_queue//lib/solid_queue/app_executor.rb#4
module SolidQueue::AppExecutor
  # source://solid_queue//lib/solid_queue/app_executor.rb#13
  def handle_thread_error(error); end

  # source://solid_queue//lib/solid_queue/app_executor.rb#5
  def wrap_in_app_executor(&block); end
end

class SolidQueue::BlockedExecution < ::SolidQueue::Execution
  include ::SolidQueue::BlockedExecution::GeneratedAttributeMethods
  include ::SolidQueue::BlockedExecution::GeneratedAssociationMethods

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_semaphore(*args); end

  def release; end

  private

  def acquire_concurrency_lock; end
  def promote_to_ready; end
  def ready_attributes; end
  def set_expires_at; end

  class << self
    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def expired(*args, **_arg1); end

    def release_many(concurrency_keys); end
    def release_one(concurrency_key); end
    def unblock(limit); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__reflections; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__reflections=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_assumable_attributes_from_job; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_assumable_attributes_from_job=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end

    def releasable(concurrency_keys); end
  end
end

module SolidQueue::BlockedExecution::GeneratedAssociationMethods
  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_semaphore(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_semaphore(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_semaphore!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_semaphore; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_semaphore; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def semaphore; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def semaphore=(value); end
end

module SolidQueue::BlockedExecution::GeneratedAttributeMethods; end

class SolidQueue::ClaimedExecution < ::SolidQueue::Execution
  include ::SolidQueue::ClaimedExecution::GeneratedAttributeMethods
  include ::SolidQueue::ClaimedExecution::GeneratedAssociationMethods

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_process(*args); end

  def discard; end
  def failed_with(error); end
  def perform; end
  def release; end

  private

  def execute; end
  def finished; end

  class << self
    def claiming(job_ids, process_id, &block); end
    def discard_all_from_jobs(*_arg0); end
    def discard_all_in_batches(*_arg0); end
    def fail_all_with(error); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def orphaned(*args, **_arg1); end

    def release_all; end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__reflections; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__reflections=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidQueue::ClaimedExecution::GeneratedAssociationMethods
  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_process(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_process(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_process!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def process; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def process=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/belongs_to.rb#146
  def process_changed?; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/belongs_to.rb#150
  def process_previously_changed?; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_process; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_process; end
end

module SolidQueue::ClaimedExecution::GeneratedAttributeMethods; end

class SolidQueue::ClaimedExecution::Result < ::Struct
  def success?; end
end

# source://solid_queue//lib/solid_queue/cli.rb#6
class SolidQueue::Cli < ::Thor
  # source://solid_queue//lib/solid_queue/cli.rb#25
  def start; end

  class << self
    # @return [Boolean]
    #
    # source://solid_queue//lib/solid_queue/cli.rb#18
    def exit_on_failure?; end
  end
end

# source://solid_queue//lib/solid_queue/configuration.rb#4
class SolidQueue::Configuration
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Access
  include ::ActiveModel::Model
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods

  # @return [Configuration] a new instance of Configuration
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#34
  def initialize(**options); end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
  def __callbacks; end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#911
  def _run_validate_callbacks(&block); end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#923
  def _validate_callbacks; end

  # source://activemodel/8.0.1/lib/active_model/validations.rb#50
  def _validators; end

  # source://activemodel/8.0.1/lib/active_model/validations.rb#50
  def _validators?; end

  # source://solid_queue//lib/solid_queue/configuration.rb#38
  def configured_processes; end

  # source://solid_queue//lib/solid_queue/configuration.rb#45
  def error_messages; end

  # source://activemodel/8.0.1/lib/active_model/naming.rb#255
  def model_name(&_arg0); end

  # source://activemodel/8.0.1/lib/active_model/conversion.rb#32
  def param_delimiter=(_arg0); end

  private

  # source://solid_queue//lib/solid_queue/configuration.rb#160
  def config_from(file_or_hash, keys: T.unsafe(nil), fallback: T.unsafe(nil), env: T.unsafe(nil)); end

  # source://solid_queue//lib/solid_queue/configuration.rb#85
  def default_options; end

  # source://solid_queue//lib/solid_queue/configuration.rb#118
  def dispatchers; end

  # source://solid_queue//lib/solid_queue/configuration.rb#137
  def dispatchers_options; end

  # source://solid_queue//lib/solid_queue/configuration.rb#62
  def ensure_configured_processes; end

  # source://solid_queue//lib/solid_queue/configuration.rb#78
  def ensure_correctly_sized_thread_pool; end

  # source://solid_queue//lib/solid_queue/configuration.rb#68
  def ensure_valid_recurring_tasks; end

  # source://solid_queue//lib/solid_queue/configuration.rb#193
  def estimated_number_of_threads; end

  # source://solid_queue//lib/solid_queue/configuration.rb#95
  def invalid_tasks; end

  # source://solid_queue//lib/solid_queue/configuration.rb#172
  def load_config_from(file_or_hash); end

  # source://solid_queue//lib/solid_queue/configuration.rb#185
  def load_config_from_file(file); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#103
  def only_dispatch?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#99
  def only_work?; end

  # Returns the value of attribute options.
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#60
  def options; end

  # source://solid_queue//lib/solid_queue/configuration.rb#148
  def processes_config; end

  # source://solid_queue//lib/solid_queue/configuration.rb#142
  def recurring_tasks; end

  # source://solid_queue//lib/solid_queue/configuration.rb#155
  def recurring_tasks_config; end

  # source://solid_queue//lib/solid_queue/configuration.rb#124
  def schedulers; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#107
  def skip_recurring_tasks?; end

  # source://solid_queue//lib/solid_queue/configuration.rb#111
  def workers; end

  # source://solid_queue//lib/solid_queue/configuration.rb#132
  def workers_options; end

  class << self
    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
    def __callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
    def __callbacks=(value); end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#915
    def _validate_callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#919
    def _validate_callbacks=(value); end

    # source://activemodel/8.0.1/lib/active_model/validations.rb#50
    def _validators; end

    # source://activemodel/8.0.1/lib/active_model/validations.rb#50
    def _validators=(value); end

    # source://activemodel/8.0.1/lib/active_model/validations.rb#50
    def _validators?; end

    # source://activemodel/8.0.1/lib/active_model/conversion.rb#32
    def param_delimiter; end

    # source://activemodel/8.0.1/lib/active_model/conversion.rb#32
    def param_delimiter=(value); end

    # source://activemodel/8.0.1/lib/active_model/conversion.rb#32
    def param_delimiter?; end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_param_delimiter; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_param_delimiter=(new_value); end
  end
end

# source://solid_queue//lib/solid_queue/configuration.rb#31
SolidQueue::Configuration::DEFAULT_CONFIG_FILE_PATH = T.let(T.unsafe(nil), String)

# source://solid_queue//lib/solid_queue/configuration.rb#32
SolidQueue::Configuration::DEFAULT_RECURRING_SCHEDULE_FILE_PATH = T.let(T.unsafe(nil), String)

# source://solid_queue//lib/solid_queue/configuration.rb#24
SolidQueue::Configuration::DISPATCHER_DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://solid_queue//lib/solid_queue/configuration.rb#11
class SolidQueue::Configuration::Process < ::Struct
  # source://solid_queue//lib/solid_queue/configuration.rb#12
  def instantiate; end
end

# source://solid_queue//lib/solid_queue/configuration.rb#17
SolidQueue::Configuration::WORKER_DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://solid_queue//lib/solid_queue.rb#23
SolidQueue::DEFAULT_LOGGER = T.let(T.unsafe(nil), ActiveSupport::Logger)

# source://solid_queue//lib/solid_queue/dispatcher.rb#4
class SolidQueue::Dispatcher < ::SolidQueue::Processes::Poller
  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#10
  def initialize(**options); end

  # Returns the value of attribute batch_size.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#5
  def batch_size; end

  # Sets the attribute batch_size
  #
  # @param value the value to set the attribute batch_size to.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#5
  def batch_size=(_arg0); end

  # Returns the value of attribute concurrency_maintenance.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#5
  def concurrency_maintenance; end

  # Sets the attribute concurrency_maintenance
  #
  # @param value the value to set the attribute concurrency_maintenance to.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#5
  def concurrency_maintenance=(_arg0); end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#20
  def metadata; end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#53
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#31
  def dispatch_next_batch; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#25
  def poll; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#41
  def schedule_recurring_tasks; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#57
  def set_procline; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#37
  def start_concurrency_maintenance; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#45
  def stop_concurrency_maintenance; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#49
  def unschedule_recurring_tasks; end

  class << self
    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end

# source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#4
class SolidQueue::Dispatcher::ConcurrencyMaintenance
  include ::SolidQueue::AppExecutor

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#9
  def initialize(interval, batch_size); end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#7
  def batch_size; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#7
  def interval; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#14
  def start; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#27
  def stop; end

  private

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#32
  def expire_semaphores; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#38
  def unblock_blocked_executions; end
end

# source://solid_queue//lib/solid_queue/engine.rb#4
class SolidQueue::Engine < ::Rails::Engine
  class << self
    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end

class SolidQueue::Execution < ::SolidQueue::Record
  include ::SolidQueue::Execution::GeneratedAttributeMethods
  include ::SolidQueue::Execution::GeneratedAssociationMethods
  include ::SolidQueue::Execution::JobAttributes
  extend ::SolidQueue::Execution::JobAttributes::ClassMethods

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_job(*args); end

  def discard; end
  def type; end

  class << self
    def assumable_attributes_from_job; end
    def assumable_attributes_from_job=(value); end
    def assumable_attributes_from_job?; end
    def create_all_from_jobs(jobs); end
    def discard_all_from_jobs(jobs); end
    def discard_all_in_batches(batch_size: T.unsafe(nil)); end
    def execution_data_from_jobs(jobs); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def ordered(*args, **_arg1); end

    def type; end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__reflections; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__reflections=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_assumable_attributes_from_job; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_assumable_attributes_from_job=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end

    def discard_jobs(job_ids); end
    def lock_all_from_jobs(jobs); end
  end
end

module SolidQueue::Execution::Dispatching
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Execution::Dispatching::ClassMethods
end

module SolidQueue::Execution::Dispatching::ClassMethods
  def dispatch_jobs(job_ids); end
end

module SolidQueue::Execution::GeneratedAssociationMethods
  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_job(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_job(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_job!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def job; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def job=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/belongs_to.rb#146
  def job_changed?; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/belongs_to.rb#150
  def job_previously_changed?; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_job; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_job; end
end

module SolidQueue::Execution::GeneratedAttributeMethods; end

module SolidQueue::Execution::JobAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::SolidQueue::Execution::JobAttributes::ClassMethods

  private

  def assume_attributes_from_job; end

  module GeneratedClassMethods
    def assumable_attributes_from_job; end
    def assumable_attributes_from_job=(value); end
    def assumable_attributes_from_job?; end
  end

  module GeneratedInstanceMethods; end
end

module SolidQueue::Execution::JobAttributes::ClassMethods
  def assumes_attributes_from_job(*attribute_names); end
  def attributes_from_job(job); end
end

class SolidQueue::Execution::UndiscardableError < ::StandardError; end

class SolidQueue::FailedExecution < ::SolidQueue::Execution
  include ::SolidQueue::FailedExecution::GeneratedAttributeMethods
  include ::SolidQueue::FailedExecution::GeneratedAssociationMethods
  include ::SolidQueue::Execution::Dispatching
  extend ::SolidQueue::Execution::Dispatching::ClassMethods

  def backtrace; end
  def exception; end
  def exception=(_arg0); end
  def exception_class; end
  def message; end
  def retry; end

  private

  def determine_backtrace_size_limit; end
  def exception_backtrace; end
  def exception_class_name; end
  def exception_message; end
  def expand_error_details_from_exception; end
  def truncate_backtrace(lines, limit); end

  class << self
    def retry_all(jobs); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidQueue::FailedExecution::GeneratedAssociationMethods; end
module SolidQueue::FailedExecution::GeneratedAttributeMethods; end
SolidQueue::FailedExecution::JSON_OVERHEAD = T.let(T.unsafe(nil), Integer)

class SolidQueue::Job < ::SolidQueue::Record
  include ::SolidQueue::Job::GeneratedAttributeMethods
  include ::SolidQueue::Job::GeneratedAssociationMethods
  include ::SolidQueue::Job::Recurrable
  include ::SolidQueue::Job::Clearable
  include ::SolidQueue::Job::Executable
  include ::SolidQueue::Job::Retryable
  include ::SolidQueue::Job::Schedulable
  include ::SolidQueue::Job::ConcurrencyControls
  extend ::SolidQueue::Job::Clearable::ClassMethods
  extend ::SolidQueue::Job::Executable::ClassMethods
  extend ::SolidQueue::Job::Schedulable::ClassMethods
  extend ::SolidQueue::Job::ConcurrencyControls::ClassMethods

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_blocked_execution(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_claimed_execution(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_failed_execution(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_ready_execution(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_recurring_execution(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_scheduled_execution(*args); end

  def concurrency_duration(*_arg0, **_arg1, &_arg2); end
  def concurrency_limit(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def clearable(*args, **_arg1); end

    def enqueue(active_job, scheduled_at: T.unsafe(nil)); end
    def enqueue_all(active_jobs); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def failed(*args, **_arg1); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def finished(*args, **_arg1); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def scheduled(*args, **_arg1); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__reflections; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__reflections=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end

    def attributes_from_active_job(active_job); end
    def create_all_from_active_jobs(active_jobs); end
    def create_from_active_job(active_job); end
  end
end

module SolidQueue::Job::Clearable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Job::Clearable::ClassMethods
end

module SolidQueue::Job::Clearable::ClassMethods
  def clear_finished_in_batches(batch_size: T.unsafe(nil), finished_before: T.unsafe(nil), class_name: T.unsafe(nil), sleep_between_batches: T.unsafe(nil)); end
end

module SolidQueue::Job::ConcurrencyControls
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Job::ConcurrencyControls::ClassMethods

  def blocked?; end
  def concurrency_limited?; end
  def unblock_next_blocked_job; end

  private

  def acquire_concurrency_lock; end
  def block; end
  def execution; end
  def job_class; end
  def release_concurrency_lock; end
  def release_next_blocked_job; end
end

module SolidQueue::Job::ConcurrencyControls::ClassMethods
  def release_all_concurrency_locks(jobs); end
end

class SolidQueue::Job::EnqueueError < ::StandardError; end

module SolidQueue::Job::Executable
  extend ::ActiveSupport::Concern

  def claimed?; end
  def discard; end
  def dispatch; end
  def dispatch_bypassing_concurrency_limits; end
  def failed?; end
  def finished!; end
  def finished?; end
  def prepare_for_execution; end
  def ready?; end
  def status; end

  private

  def execution; end
  def ready; end
end

module SolidQueue::Job::Executable::ClassMethods
  def dispatch_all(jobs); end
  def prepare_all_for_execution(jobs); end

  private

  def dispatch_all_at_once(jobs); end
  def dispatch_all_one_by_one(jobs); end
  def dispatched_and_blocked(jobs); end
  def dispatched_and_ready(jobs); end
  def successfully_dispatched(jobs); end
end

module SolidQueue::Job::GeneratedAssociationMethods
  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def blocked_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def blocked_execution=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_blocked_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_claimed_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_failed_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_ready_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_recurring_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_scheduled_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def claimed_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def claimed_execution=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_blocked_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_blocked_execution!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_claimed_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_claimed_execution!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_failed_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_failed_execution!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_ready_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_ready_execution!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_recurring_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_recurring_execution!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_scheduled_execution(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_scheduled_execution!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def failed_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def failed_execution=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def ready_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def ready_execution=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def recurring_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def recurring_execution=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_blocked_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_claimed_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_failed_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_ready_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_recurring_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_scheduled_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_blocked_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_claimed_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_failed_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_ready_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_recurring_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_scheduled_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def scheduled_execution; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def scheduled_execution=(value); end
end

module SolidQueue::Job::GeneratedAttributeMethods; end

module SolidQueue::Job::Recurrable
  extend ::ActiveSupport::Concern
end

module SolidQueue::Job::Retryable
  extend ::ActiveSupport::Concern

  def failed_with(exception); end
  def reset_execution_counters; end
  def retry; end
end

module SolidQueue::Job::Schedulable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Job::Schedulable::ClassMethods

  def due?; end
  def scheduled?; end

  private

  def execution; end
  def schedule; end
end

module SolidQueue::Job::Schedulable::ClassMethods
  def schedule_all(jobs); end

  private

  def schedule_all_at_once(jobs); end
  def successfully_scheduled(jobs); end
end

# source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#4
module SolidQueue::LifecycleHooks
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::LifecycleHooks::ClassMethods

  private

  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#35
  def run_hooks_for(event); end

  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#27
  def run_start_hooks; end

  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#31
  def run_stop_hooks; end
end

# source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#0
module SolidQueue::LifecycleHooks::ClassMethods
  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#20
  def clear_hooks; end

  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#12
  def on_start(&block); end

  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#16
  def on_stop(&block); end
end

# source://solid_queue//lib/solid_queue/log_subscriber.rb#5
class SolidQueue::LogSubscriber < ::ActiveSupport::LogSubscriber
  # source://solid_queue//lib/solid_queue/log_subscriber.rb#10
  def claim(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#101
  def deregister_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#38
  def discard(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#34
  def discard_all(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#6
  def dispatch_scheduled(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#50
  def enqueue_recurring_task(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#18
  def fail_many_claimed(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#129
  def graceful_termination(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#139
  def immediate_termination(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#121
  def prune_processes(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#90
  def register_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#46
  def release_blocked(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#22
  def release_claimed(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#42
  def release_many_blocked(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#14
  def release_many_claimed(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#147
  def replace_fork(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#30
  def retry(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#26
  def retry_all(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#77
  def shutdown_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#64
  def start_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#125
  def thread_error(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#143
  def unhandled_signal_error(event); end

  private

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#169
  def formatted_attributes(**attributes); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#173
  def formatted_error(error); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#165
  def formatted_event(event, action:, **attributes); end

  # Use the logger configured for SolidQueue
  #
  # source://solid_queue//lib/solid_queue/log_subscriber.rb#178
  def logger; end
end

class SolidQueue::Pause < ::SolidQueue::Record
  include ::SolidQueue::Pause::GeneratedAttributeMethods
  include ::SolidQueue::Pause::GeneratedAssociationMethods

  class << self
    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidQueue::Pause::GeneratedAssociationMethods; end
module SolidQueue::Pause::GeneratedAttributeMethods; end

# source://solid_queue//lib/solid_queue/pool.rb#4
class SolidQueue::Pool
  include ::SolidQueue::AppExecutor

  # @return [Pool] a new instance of Pool
  #
  # source://solid_queue//lib/solid_queue/pool.rb#11
  def initialize(size, on_idle: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/pool.rb#41
  def idle?; end

  # source://solid_queue//lib/solid_queue/pool.rb#37
  def idle_threads; end

  # source://solid_queue//lib/solid_queue/pool.rb#18
  def post(execution); end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def shutdown(*_arg0, **_arg1, &_arg2); end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def shutdown?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute size.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#7
  def size; end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def wait_for_termination(*_arg0, **_arg1, &_arg2); end

  private

  # Returns the value of attribute available_threads.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def available_threads; end

  # source://solid_queue//lib/solid_queue/pool.rb#54
  def executor; end

  # Returns the value of attribute mutex.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def mutex; end

  # Returns the value of attribute on_idle.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def on_idle; end
end

# source://solid_queue//lib/solid_queue/pool.rb#48
SolidQueue::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class SolidQueue::Process < ::SolidQueue::Record
  include ::SolidQueue::Process::GeneratedAttributeMethods
  include ::SolidQueue::Process::GeneratedAssociationMethods
  include ::SolidQueue::Process::Prunable
  include ::SolidQueue::Process::Executor
  extend ::SolidQueue::Process::Prunable::ClassMethods

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_claimed_executions(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_supervisees(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_supervisor(*args); end

  def deregister(pruned: T.unsafe(nil)); end
  def heartbeat; end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def validate_associated_records_for_claimed_executions(*args); end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def validate_associated_records_for_supervisees(*args); end

  private

  def supervised?; end

  class << self
    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def prunable(*args, **_arg1); end

    def register(**attributes); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__reflections; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__reflections=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidQueue::Process::Executor
  extend ::ActiveSupport::Concern

  def fail_all_claimed_executions_with(error); end
  def release_all_claimed_executions; end

  private

  def claims_executions?; end
end

module SolidQueue::Process::GeneratedAssociationMethods
  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#32
  def build_supervisor(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/collection_association.rb#62
  def claimed_execution_ids; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/collection_association.rb#72
  def claimed_execution_ids=(ids); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def claimed_executions; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def claimed_executions=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#36
  def create_supervisor(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#40
  def create_supervisor!(*args, &block); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#19
  def reload_supervisor; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/singular_association.rb#23
  def reset_supervisor; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/collection_association.rb#62
  def supervisee_ids; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/collection_association.rb#72
  def supervisee_ids=(ids); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def supervisees; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def supervisees=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def supervisor; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def supervisor=(value); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/belongs_to.rb#146
  def supervisor_changed?; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/belongs_to.rb#150
  def supervisor_previously_changed?; end
end

module SolidQueue::Process::GeneratedAttributeMethods; end

module SolidQueue::Process::Prunable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Process::Prunable::ClassMethods

  def prune; end
end

module SolidQueue::Process::Prunable::ClassMethods
  def prune(excluding: T.unsafe(nil)); end
end

# source://solid_queue//lib/solid_queue/supervisor.rb#0
module SolidQueue::Processes; end

# source://solid_queue//lib/solid_queue/processes/base.rb#5
class SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Callbacks
  include ::ActiveSupport::Callbacks
  include ::SolidQueue::Processes::Procline
  include ::SolidQueue::Processes::Interruptible
  include ::SolidQueue::Processes::Registrable
  include ::SolidQueue::AppExecutor
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @return [Base] a new instance of Base
  #
  # source://solid_queue//lib/solid_queue/processes/base.rb#11
  def initialize(*_arg0); end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
  def __callbacks; end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#923
  def _boot_callbacks; end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#911
  def _run_boot_callbacks(&block); end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#911
  def _run_shutdown_callbacks(&block); end

  # source://activesupport/8.0.1/lib/active_support/callbacks.rb#923
  def _shutdown_callbacks; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#20
  def hostname; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#16
  def kind; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#28
  def metadata; end

  # Returns the value of attribute name.
  #
  # source://solid_queue//lib/solid_queue/processes/base.rb#9
  def name; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#24
  def pid; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#32
  def stop; end

  private

  # source://solid_queue//lib/solid_queue/processes/base.rb#37
  def generate_name; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/base.rb#41
  def stopped?; end

  class << self
    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
    def __callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#69
    def __callbacks=(value); end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#915
    def _boot_callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#919
    def _boot_callbacks=(value); end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#915
    def _shutdown_callbacks; end

    # source://activesupport/8.0.1/lib/active_support/callbacks.rb#919
    def _shutdown_callbacks=(value); end

    # source://activemodel/8.0.1/lib/active_model/callbacks.rb#144
    def after_boot(*args, **options, &block); end

    # source://activemodel/8.0.1/lib/active_model/callbacks.rb#144
    def after_shutdown(*args, **options, &block); end

    # source://activemodel/8.0.1/lib/active_model/callbacks.rb#137
    def around_boot(*args, **options, &block); end

    # source://activemodel/8.0.1/lib/active_model/callbacks.rb#137
    def around_shutdown(*args, **options, &block); end

    # source://activemodel/8.0.1/lib/active_model/callbacks.rb#130
    def before_boot(*args, **options, &block); end

    # source://activemodel/8.0.1/lib/active_model/callbacks.rb#130
    def before_shutdown(*args, **options, &block); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end

# source://solid_queue//lib/solid_queue/processes/callbacks.rb#4
module SolidQueue::Processes::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
  end
end

# source://solid_queue//lib/solid_queue/processes/interruptible.rb#4
module SolidQueue::Processes::Interruptible
  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#5
  def wake_up; end

  private

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#11
  def interrupt; end

  # Sleeps for 'time'.  Can be interrupted asynchronously and return early via wake_up.
  # * returns `true` if an interrupt was requested via #wake_up between the
  #   last call to `interruptible_sleep` and now, resulting in an early return.
  # * returns `nil` if it slept the full `time` and was not interrupted.
  #
  # @param time [Numeric] the time to sleep. 0 returns immediately.
  # @return [true, nil]
  #
  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#21
  def interruptible_sleep(time); end

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#29
  def queue; end
end

# source://solid_queue//lib/solid_queue/processes/poller.rb#4
class SolidQueue::Processes::Poller < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Supervised
  include ::SolidQueue::Processes::Runnable

  # @return [Poller] a new instance of Poller
  #
  # source://solid_queue//lib/solid_queue/processes/poller.rb#9
  def initialize(polling_interval:, **options); end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#15
  def metadata; end

  # Returns the value of attribute polling_interval.
  #
  # source://solid_queue//lib/solid_queue/processes/poller.rb#7
  def polling_interval; end

  # Sets the attribute polling_interval
  #
  # @param value the value to set the attribute polling_interval to.
  #
  # source://solid_queue//lib/solid_queue/processes/poller.rb#7
  def polling_interval=(_arg0); end

  private

  # @raise [NotImplementedError]
  #
  # source://solid_queue//lib/solid_queue/processes/poller.rb#40
  def poll; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#20
  def run; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#24
  def start_loop; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#44
  def with_polling_volume; end
end

# source://solid_queue//lib/solid_queue/processes/process_exit_error.rb#5
class SolidQueue::Processes::ProcessExitError < ::RuntimeError
  # @return [ProcessExitError] a new instance of ProcessExitError
  #
  # source://solid_queue//lib/solid_queue/processes/process_exit_error.rb#6
  def initialize(status); end
end

# source://solid_queue//lib/solid_queue/processes/process_missing_error.rb#3
class SolidQueue::Processes::ProcessMissingError < ::RuntimeError
  # @return [ProcessMissingError] a new instance of ProcessMissingError
  #
  # source://solid_queue//lib/solid_queue/processes/process_missing_error.rb#4
  def initialize; end
end

# source://solid_queue//lib/solid_queue/processes/process_pruned_error.rb#5
class SolidQueue::Processes::ProcessPrunedError < ::RuntimeError
  # @return [ProcessPrunedError] a new instance of ProcessPrunedError
  #
  # source://solid_queue//lib/solid_queue/processes/process_pruned_error.rb#6
  def initialize(last_heartbeat_at); end
end

# source://solid_queue//lib/solid_queue/processes/procline.rb#4
module SolidQueue::Processes::Procline
  # Sets the procline ($0)
  # solid-queue-supervisor(0.1.0): <string>
  #
  # source://solid_queue//lib/solid_queue/processes/procline.rb#7
  def procline(string); end
end

# source://solid_queue//lib/solid_queue/processes/registrable.rb#4
module SolidQueue::Processes::Registrable
  extend ::ActiveSupport::Concern

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#14
  def process_id; end

  private

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#31
  def deregister; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#55
  def heartbeat; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#39
  def launch_heartbeat; end

  # Returns the value of attribute process.
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#19
  def process; end

  # Sets the attribute process
  #
  # @param value the value to set the attribute process to.
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#19
  def process=(_arg0); end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#21
  def register; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#35
  def registered?; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#51
  def stop_heartbeat; end
end

# source://solid_queue//lib/solid_queue/processes/runnable.rb#4
module SolidQueue::Processes::Runnable
  include ::SolidQueue::Processes::Supervised

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#7
  def mode=(_arg0); end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#9
  def start; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#19
  def stop; end

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#8
  def supervisor; end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#56
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#33
  def boot; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#79
  def create_thread(&block); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#52
  def finished?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#29
  def mode; end

  # @raise [NotImplementedError]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#48
  def run; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#74
  def running_as_fork?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#70
  def running_async?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#66
  def running_inline?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#63
  def set_procline; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#60
  def shutdown; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#44
  def shutting_down?; end
end

# source://solid_queue//lib/solid_queue/processes/runnable.rb#27
SolidQueue::Processes::Runnable::DEFAULT_MODE = T.let(T.unsafe(nil), Symbol)

# source://solid_queue//lib/solid_queue/processes/supervised.rb#4
module SolidQueue::Processes::Supervised
  extend ::ActiveSupport::Concern

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#11
  def supervised_by(process); end

  private

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#28
  def register_signal_handlers; end

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#16
  def set_procline; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/supervised.rb#24
  def supervised?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/supervised.rb#20
  def supervisor_went_away?; end
end

class SolidQueue::Queue
  def initialize(name); end

  def ==(queue); end
  def clear; end
  def eql?(queue); end
  def hash; end
  def human_latency; end
  def latency; end
  def name; end
  def name=(_arg0); end
  def pause; end
  def paused?; end
  def resume; end
  def size; end

  class << self
    def all; end
    def find_by_name(name); end
  end
end

class SolidQueue::QueueSelector
  def initialize(queue_list, relation); end

  def raw_queues; end
  def relation; end
  def scoped_relations; end

  private

  def all?; end
  def all_queues; end
  def delete_in_order(raw_queue, queues); end
  def eligible_queues; end
  def exact_name?(queue); end
  def exact_names; end
  def in_raw_order(queues); end
  def include_all_queues?; end
  def none?; end
  def paused_queues; end
  def prefixed_name?(queue); end
  def prefixed_names; end
  def prefixes; end
  def queue_names; end
end

class SolidQueue::ReadyExecution < ::SolidQueue::Execution
  include ::SolidQueue::ReadyExecution::GeneratedAttributeMethods
  include ::SolidQueue::ReadyExecution::GeneratedAssociationMethods

  class << self
    def aggregated_count_across(queue_list); end
    def claim(queue_list, limit, process_id); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def queued_as(*args, **_arg1); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_assumable_attributes_from_job; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_assumable_attributes_from_job=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end

    def discard_jobs(job_ids); end
    def lock_candidates(executions, process_id); end
    def select_and_lock(queue_relation, process_id, limit); end
    def select_candidates(queue_relation, limit); end
  end
end

module SolidQueue::ReadyExecution::GeneratedAssociationMethods; end
module SolidQueue::ReadyExecution::GeneratedAttributeMethods; end

class SolidQueue::Record < ::ActiveRecord::Base
  include ::SolidQueue::Record::GeneratedAttributeMethods
  include ::SolidQueue::Record::GeneratedAssociationMethods

  class << self
    def non_blocking_lock; end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidQueue::Record::GeneratedAssociationMethods; end
module SolidQueue::Record::GeneratedAttributeMethods; end

class SolidQueue::RecurringExecution < ::SolidQueue::Execution
  include ::SolidQueue::RecurringExecution::GeneratedAttributeMethods
  include ::SolidQueue::RecurringExecution::GeneratedAssociationMethods

  class << self
    def clear_in_batches(batch_size: T.unsafe(nil)); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def clearable(*args, **_arg1); end

    def create_or_insert!(**attributes); end
    def record(task_key, run_at, &block); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

class SolidQueue::RecurringExecution::AlreadyRecorded < ::StandardError; end
module SolidQueue::RecurringExecution::GeneratedAssociationMethods; end
module SolidQueue::RecurringExecution::GeneratedAttributeMethods; end

class SolidQueue::RecurringJob < ::ActiveJob::Base
  def perform(command); end

  class << self
    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_queue_name; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_queue_name=(new_value); end
  end
end

class SolidQueue::RecurringTask < ::SolidQueue::Record
  include ::SolidQueue::RecurringTask::GeneratedAttributeMethods
  include ::SolidQueue::RecurringTask::GeneratedAssociationMethods

  def attributes_for_upsert; end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def autosave_associated_records_for_recurring_executions(*args); end

  def default_job_class; end
  def default_job_class=(val); end
  def delay_from_now; end
  def enqueue(at:); end
  def last_enqueued_time; end
  def next_time; end
  def previous_time; end
  def to_s; end

  # source://activerecord/8.0.1/lib/active_record/autosave_association.rb#162
  def validate_associated_records_for_recurring_executions(*args); end

  private

  def arguments_with_kwargs; end
  def enqueue_and_record(run_at:); end
  def enqueue_options; end
  def ensure_command_or_class_present; end
  def existing_job_class; end
  def job_class; end
  def parsed_schedule; end
  def perform_later; end
  def supported_schedule; end
  def using_solid_queue_adapter?; end

  class << self
    def create_or_update_all(tasks); end
    def default_job_class; end
    def default_job_class=(val); end
    def from_configuration(key, **options); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def static(*args, **_arg1); end

    def wrap(args); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__reflections; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__reflections=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

class SolidQueue::RecurringTask::Arguments
  class << self
    def dump(data); end
    def load(data); end
  end
end

module SolidQueue::RecurringTask::GeneratedAssociationMethods
  # source://activerecord/8.0.1/lib/active_record/associations/builder/collection_association.rb#62
  def recurring_execution_ids; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/collection_association.rb#72
  def recurring_execution_ids=(ids); end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#104
  def recurring_executions; end

  # source://activerecord/8.0.1/lib/active_record/associations/builder/association.rb#112
  def recurring_executions=(value); end
end

module SolidQueue::RecurringTask::GeneratedAttributeMethods; end

class SolidQueue::ScheduledExecution < ::SolidQueue::Execution
  include ::SolidQueue::ScheduledExecution::GeneratedAttributeMethods
  include ::SolidQueue::ScheduledExecution::GeneratedAssociationMethods
  include ::SolidQueue::Execution::Dispatching
  extend ::SolidQueue::Execution::Dispatching::ClassMethods

  class << self
    def dispatch_next_batch(batch_size); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def due(*args, **_arg1); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def next_batch(*args, **_arg1); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def ordered(*args, **_arg1); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_assumable_attributes_from_job; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_assumable_attributes_from_job=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidQueue::ScheduledExecution::GeneratedAssociationMethods; end
module SolidQueue::ScheduledExecution::GeneratedAttributeMethods; end

# source://solid_queue//lib/solid_queue/scheduler.rb#4
class SolidQueue::Scheduler < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Supervised
  include ::SolidQueue::Processes::Runnable

  # @return [Scheduler] a new instance of Scheduler
  #
  # source://solid_queue//lib/solid_queue/scheduler.rb#12
  def initialize(recurring_tasks:, **options); end

  # source://solid_queue//lib/solid_queue/scheduler.rb#18
  def metadata; end

  # Returns the value of attribute recurring_schedule.
  #
  # source://solid_queue//lib/solid_queue/scheduler.rb#7
  def recurring_schedule; end

  # Sets the attribute recurring_schedule
  #
  # @param value the value to set the attribute recurring_schedule to.
  #
  # source://solid_queue//lib/solid_queue/scheduler.rb#7
  def recurring_schedule=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/scheduler.rb#45
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/scheduler.rb#25
  def run; end

  # source://solid_queue//lib/solid_queue/scheduler.rb#37
  def schedule_recurring_tasks; end

  # source://solid_queue//lib/solid_queue/scheduler.rb#49
  def set_procline; end

  # source://solid_queue//lib/solid_queue/scheduler.rb#41
  def unschedule_recurring_tasks; end

  class << self
    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end

# source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#4
class SolidQueue::Scheduler::RecurringSchedule
  include ::SolidQueue::AppExecutor

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#9
  def initialize(tasks); end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#7
  def configured_tasks; end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#14
  def empty?; end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#29
  def schedule_task(task); end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#18
  def schedule_tasks; end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#7
  def scheduled_tasks; end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#38
  def task_keys; end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#33
  def unschedule_tasks; end

  private

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#43
  def persist_tasks; end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#48
  def reload_tasks; end

  # source://solid_queue//lib/solid_queue/scheduler/recurring_schedule.rb#52
  def schedule(task); end
end

# Right now it doesn't matter, can be set to 1 in the future for dynamic tasks
#
# source://solid_queue//lib/solid_queue/scheduler.rb#23
SolidQueue::Scheduler::SLEEP_INTERVAL = T.let(T.unsafe(nil), Integer)

class SolidQueue::Semaphore < ::SolidQueue::Record
  include ::SolidQueue::Semaphore::GeneratedAttributeMethods
  include ::SolidQueue::Semaphore::GeneratedAssociationMethods

  class << self
    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def available(*args, **_arg1); end

    def create_unique_by(attributes); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def expired(*args, **_arg1); end

    def signal(job); end
    def signal_all(jobs); end
    def wait(job); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidQueue::Semaphore::GeneratedAssociationMethods; end
module SolidQueue::Semaphore::GeneratedAttributeMethods; end

class SolidQueue::Semaphore::Proxy
  def initialize(job); end

  def signal; end
  def wait; end

  private

  def attempt_creation; end
  def attempt_decrement; end
  def attempt_increment; end
  def check_limit_or_decrement; end
  def expires_at; end
  def job; end
  def job=(_arg0); end
  def key; end
  def limit; end

  class << self
    def signal_all(jobs); end
  end
end

# source://solid_queue//lib/solid_queue/supervisor.rb#4
class SolidQueue::Supervisor < ::SolidQueue::Processes::Base
  include ::SolidQueue::LifecycleHooks
  include ::SolidQueue::Supervisor::Pidfiled
  include ::SolidQueue::Supervisor::Signals
  include ::SolidQueue::Supervisor::Maintenance
  extend ::SolidQueue::LifecycleHooks::ClassMethods

  # @return [Supervisor] a new instance of Supervisor
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#21
  def initialize(configuration); end

  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#8
  def lifecycle_hooks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#29
  def start; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#39
  def stop; end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#180
  def all_forks_terminated?; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#47
  def boot; end

  # Returns the value of attribute configuration.
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#45
  def configuration; end

  # Returns the value of attribute configured_processes.
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#45
  def configured_processes; end

  # Returns the value of attribute forks.
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#45
  def forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#173
  def handle_claimed_jobs_by(terminated_fork, status); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#134
  def quit_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#138
  def reap_and_replace_terminated_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#147
  def reap_terminated_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#162
  def replace_fork(pid, status); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#89
  def set_procline; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#114
  def shutdown; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#75
  def start_process(configured_process); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#55
  def start_processes; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#59
  def supervise; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#126
  def supervised_processes; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#122
  def sync_std_streams; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#130
  def term_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#93
  def terminate_gracefully; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#108
  def terminate_immediately; end

  class << self
    # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#8
    def lifecycle_hooks; end

    # source://solid_queue//lib/solid_queue/supervisor.rb#9
    def start(**options); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end

# source://solid_queue//lib/solid_queue/supervisor/maintenance.rb#2
module SolidQueue::Supervisor::Maintenance
  extend ::ActiveSupport::Concern

  private

  # source://solid_queue//lib/solid_queue/supervisor/maintenance.rb#30
  def fail_orphaned_executions; end

  # source://solid_queue//lib/solid_queue/supervisor/maintenance.rb#10
  def launch_maintenance_task; end

  # source://solid_queue//lib/solid_queue/supervisor/maintenance.rb#26
  def prune_dead_processes; end

  # source://solid_queue//lib/solid_queue/supervisor/maintenance.rb#22
  def stop_maintenance_task; end
end

# source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#4
class SolidQueue::Supervisor::Pidfile
  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#5
  def initialize(path); end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#16
  def delete; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#10
  def setup; end

  private

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#54
  def already_running!; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#23
  def check_status; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#50
  def delete_file; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#21
  def path; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#21
  def pid; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#46
  def set_at_exit_hook; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfile.rb#39
  def write_file; end
end

# source://solid_queue//lib/solid_queue/supervisor/pidfiled.rb#5
module SolidQueue::Supervisor::Pidfiled
  extend ::ActiveSupport::Concern

  private

  # source://solid_queue//lib/solid_queue/supervisor/pidfiled.rb#20
  def delete_pidfile; end

  # source://solid_queue//lib/solid_queue/supervisor/pidfiled.rb#14
  def setup_pidfile; end
end

# source://solid_queue//lib/solid_queue/supervisor/signals.rb#5
module SolidQueue::Supervisor::Signals
  extend ::ActiveSupport::Concern

  private

  # source://solid_queue//lib/solid_queue/supervisor/signals.rb#37
  def handle_signal(signal); end

  # source://solid_queue//lib/solid_queue/supervisor/signals.rb#31
  def process_signal_queue; end

  # source://solid_queue//lib/solid_queue/supervisor/signals.rb#16
  def register_signal_handlers; end

  # source://solid_queue//lib/solid_queue/supervisor/signals.rb#25
  def restore_default_signal_handlers; end

  # source://solid_queue//lib/solid_queue/supervisor/signals.rb#56
  def signal_process(pid, signal); end

  # source://solid_queue//lib/solid_queue/supervisor/signals.rb#50
  def signal_processes(pids, signal); end

  # source://solid_queue//lib/solid_queue/supervisor/signals.rb#62
  def signal_queue; end
end

# source://solid_queue//lib/solid_queue/supervisor/signals.rb#14
SolidQueue::Supervisor::Signals::SIGNALS = T.let(T.unsafe(nil), Array)

# source://solid_queue//lib/solid_queue/timer.rb#4
module SolidQueue::Timer
  extend ::SolidQueue::Timer

  # source://solid_queue//lib/solid_queue/timer.rb#7
  def wait_until(timeout, condition, &block); end

  private

  # source://solid_queue//lib/solid_queue/timer.rb#24
  def monotonic_time_now; end
end

# source://solid_queue//lib/solid_queue/version.rb#2
SolidQueue::VERSION = T.let(T.unsafe(nil), String)

# source://solid_queue//lib/solid_queue/worker.rb#4
class SolidQueue::Worker < ::SolidQueue::Processes::Poller
  include ::SolidQueue::LifecycleHooks
  extend ::SolidQueue::LifecycleHooks::ClassMethods

  # @return [Worker] a new instance of Worker
  #
  # source://solid_queue//lib/solid_queue/worker.rb#13
  def initialize(**options); end

  # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#8
  def lifecycle_hooks; end

  # source://solid_queue//lib/solid_queue/worker.rb#22
  def metadata; end

  # Returns the value of attribute pool.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#11
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#11
  def pool=(_arg0); end

  # Returns the value of attribute queues.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#11
  def queues; end

  # Sets the attribute queues
  #
  # @param value the value to set the attribute queues to.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#11
  def queues=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/worker.rb#50
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/worker.rb#37
  def claim_executions; end

  # source://solid_queue//lib/solid_queue/worker.rb#27
  def poll; end

  # source://solid_queue//lib/solid_queue/worker.rb#54
  def set_procline; end

  # source://solid_queue//lib/solid_queue/worker.rb#43
  def shutdown; end

  class << self
    # source://solid_queue//lib/solid_queue/lifecycle_hooks.rb#8
    def lifecycle_hooks; end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end
