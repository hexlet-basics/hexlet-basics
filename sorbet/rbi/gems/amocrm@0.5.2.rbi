# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `amocrm` gem.
# Please instead update this file by running `bin/tapioca gem amocrm`.


# typed: strong

module Amocrm
  AccountGetParams = Amocrm::Models::AccountGetParams
  CallCreateParams = Amocrm::Models::CallCreateParams
  CatalogCreateParams = Amocrm::Models::CatalogCreateParams
  CatalogElementCreateParams = Amocrm::Models::CatalogElementCreateParams
  CatalogElementGetByIDParams = Amocrm::Models::CatalogElementGetByIDParams
  CatalogElementListParams = Amocrm::Models::CatalogElementListParams

  CatalogElementUpdateByIDParams = Amocrm::Models::CatalogElementUpdateByIDParams

  CatalogElementUpdateParams = Amocrm::Models::CatalogElementUpdateParams
  CatalogGetByIDParams = Amocrm::Models::CatalogGetByIDParams
  CatalogListParams = Amocrm::Models::CatalogListParams
  CatalogUpdateByIDParams = Amocrm::Models::CatalogUpdateByIDParams
  CatalogUpdateParams = Amocrm::Models::CatalogUpdateParams

  class Client < Amocrm::Internal::Transport::BaseClient
    sig { returns(Amocrm::Resources::Account) }
    attr_reader :account

    sig { returns(Amocrm::Resources::Calls) }
    attr_reader :calls

    sig { returns(Amocrm::Resources::CatalogElements) }
    attr_reader :catalog_elements

    sig { returns(Amocrm::Resources::Catalogs) }
    attr_reader :catalogs

    sig { returns(Amocrm::Resources::Companies) }
    attr_reader :companies

    sig { returns(Amocrm::Resources::ContactChats) }
    attr_reader :contact_chats

    sig { returns(Amocrm::Resources::Contacts) }
    attr_reader :contacts

    sig { returns(Amocrm::Resources::CustomFieldGroups) }
    attr_reader :custom_field_groups

    sig { returns(Amocrm::Resources::CustomFields) }
    attr_reader :custom_fields

    sig { returns(Amocrm::Resources::CustomerBonusPoints) }
    attr_reader :customer_bonus_points

    sig { returns(Amocrm::Resources::CustomerSegments) }
    attr_reader :customer_segments

    sig { returns(Amocrm::Resources::CustomerStatuses) }
    attr_reader :customer_statuses

    sig { returns(Amocrm::Resources::CustomerTransactions) }
    attr_reader :customer_transactions

    sig { returns(Amocrm::Resources::Customers) }
    attr_reader :customers

    sig { returns(Amocrm::Resources::CustomersMode) }
    attr_reader :customers_mode

    sig { returns(Amocrm::Resources::EntityFollowers) }
    attr_reader :entity_followers

    sig { returns(Amocrm::Resources::EntityLinks) }
    attr_reader :entity_links

    sig { returns(Amocrm::Resources::EntityNotes) }
    attr_reader :entity_notes

    sig { returns(Amocrm::Resources::EntityNotesByParent) }
    attr_reader :entity_notes_by_parent

    sig { returns(Amocrm::Resources::Events) }
    attr_reader :events

    sig { returns(Amocrm::Resources::Leads) }
    attr_reader :leads

    sig { returns(Amocrm::Resources::PipelineStatuses) }
    attr_reader :pipeline_statuses

    sig { returns(Amocrm::Resources::Pipelines) }
    attr_reader :pipelines

    sig { returns(Amocrm::Resources::Roles) }
    attr_reader :roles

    sig { returns(Amocrm::Resources::Salesbot) }
    attr_reader :salesbot

    sig { returns(Amocrm::Resources::ShortLinks) }
    attr_reader :short_links

    sig { returns(Amocrm::Resources::Sources) }
    attr_reader :sources

    sig { returns(String) }
    attr_reader :subdomain

    sig { returns(Amocrm::Resources::Tags) }
    attr_reader :tags

    sig { returns(Amocrm::Resources::Talks) }
    attr_reader :talks

    sig { returns(Amocrm::Resources::Tasks) }
    attr_reader :tasks

    sig { returns(String) }
    attr_reader :token

    sig { returns(Amocrm::Resources::UnsortedLeads) }
    attr_reader :unsorted_leads

    sig { returns(Amocrm::Resources::Users) }
    attr_reader :users

    sig { returns(Amocrm::Resources::Webhooks) }
    attr_reader :webhooks

    sig { returns(Amocrm::Resources::WebsiteButtons) }
    attr_reader :website_buttons

    sig { returns(Amocrm::Resources::WidgetBotContinue) }
    attr_reader :widget_bot_continue

    sig { returns(Amocrm::Resources::Widgets) }
    attr_reader :widgets

    private

    # @api private
    sig { override.returns(T::Hash[String, String]) }
    def auth_headers; end

    class << self
      # Creates and returns a new client for interacting with the API.
      sig do
        params(
          token: T.nilable(String),
          subdomain: T.nilable(String),
          base_url: T.nilable(String),
          max_retries: Integer,
          timeout: Float,
          initial_retry_delay: Float,
          max_retry_delay: Float
        ).returns(T.attached_class)
      end
      def new(
        token: ENV["AMOCRM_AUTH_TOKEN"], # Defaults to `ENV["AMOCRM_AUTH_TOKEN"]`
        subdomain: ENV["AMOCRM_SUBDOMAIN"], # Defaults to `ENV["AMOCRM_SUBDOMAIN"]`
        base_url: ENV["AMOCRM_BASE_URL"], # Override the default base URL for the API, e.g.,
                                          # `"https://api.example.com/v2/"`. Defaults to `ENV["AMOCRM_BASE_URL"]`
        max_retries: Amocrm::Client::DEFAULT_MAX_RETRIES, # Max number of retries to attempt after a failed retryable request.
        timeout: Amocrm::Client::DEFAULT_TIMEOUT_IN_SECONDS,
        initial_retry_delay: Amocrm::Client::DEFAULT_INITIAL_RETRY_DELAY,
        max_retry_delay: Amocrm::Client::DEFAULT_MAX_RETRY_DELAY
); end
    end

    DEFAULT_INITIAL_RETRY_DELAY = T.let(0.5, Float)
    DEFAULT_MAX_RETRIES = 2
    DEFAULT_MAX_RETRY_DELAY = T.let(8.0, Float)
    DEFAULT_TIMEOUT_IN_SECONDS = T.let(60.0, Float)
  end

  CompanyCreateParams = Amocrm::Models::CompanyCreateParams
  CompanyGetByIDParams = Amocrm::Models::CompanyGetByIDParams
  CompanyListParams = Amocrm::Models::CompanyListParams
  CompanyUpdateByIDParams = Amocrm::Models::CompanyUpdateByIDParams
  CompanyUpdateParams = Amocrm::Models::CompanyUpdateParams
  ContactChatLinkParams = Amocrm::Models::ContactChatLinkParams
  ContactChatListParams = Amocrm::Models::ContactChatListParams
  ContactCreateParams = Amocrm::Models::ContactCreateParams
  ContactGetByIDParams = Amocrm::Models::ContactGetByIDParams
  ContactListParams = Amocrm::Models::ContactListParams
  ContactUpdateByIDParams = Amocrm::Models::ContactUpdateByIDParams
  ContactUpdateParams = Amocrm::Models::ContactUpdateParams
  CustomFieldCreateParams = Amocrm::Models::CustomFieldCreateParams
  CustomFieldDeleteByIDParams = Amocrm::Models::CustomFieldDeleteByIDParams
  CustomFieldGetByIDParams = Amocrm::Models::CustomFieldGetByIDParams
  CustomFieldGroupCreateParams = Amocrm::Models::CustomFieldGroupCreateParams

  CustomFieldGroupDeleteByIDParams = Amocrm::Models::CustomFieldGroupDeleteByIDParams

  CustomFieldGroupGetByIDParams = Amocrm::Models::CustomFieldGroupGetByIDParams
  CustomFieldGroupListParams = Amocrm::Models::CustomFieldGroupListParams

  CustomFieldGroupUpdateByIDParams = Amocrm::Models::CustomFieldGroupUpdateByIDParams

  CustomFieldListParams = Amocrm::Models::CustomFieldListParams
  CustomFieldUpdateByIDParams = Amocrm::Models::CustomFieldUpdateByIDParams
  CustomFieldUpdateParams = Amocrm::Models::CustomFieldUpdateParams

  CustomerBonusPointChangeParams = Amocrm::Models::CustomerBonusPointChangeParams

  CustomerCreateParams = Amocrm::Models::CustomerCreateParams
  CustomerGetByIDParams = Amocrm::Models::CustomerGetByIDParams
  CustomerListParams = Amocrm::Models::CustomerListParams
  CustomerSegmentCreateParams = Amocrm::Models::CustomerSegmentCreateParams

  CustomerSegmentDeleteByIDParams = Amocrm::Models::CustomerSegmentDeleteByIDParams

  CustomerSegmentGetByIDParams = Amocrm::Models::CustomerSegmentGetByIDParams
  CustomerSegmentListParams = Amocrm::Models::CustomerSegmentListParams

  CustomerSegmentUpdateByIDParams = Amocrm::Models::CustomerSegmentUpdateByIDParams

  CustomerStatusCreateParams = Amocrm::Models::CustomerStatusCreateParams

  CustomerStatusDeleteByIDParams = Amocrm::Models::CustomerStatusDeleteByIDParams

  CustomerStatusGetByIDParams = Amocrm::Models::CustomerStatusGetByIDParams
  CustomerStatusListParams = Amocrm::Models::CustomerStatusListParams

  CustomerStatusUpdateByIDParams = Amocrm::Models::CustomerStatusUpdateByIDParams

  CustomerTransactionCreateParams = Amocrm::Models::CustomerTransactionCreateParams

  CustomerTransactionDeleteByIDParams = Amocrm::Models::CustomerTransactionDeleteByIDParams

  CustomerTransactionListByCustomerParams = Amocrm::Models::CustomerTransactionListByCustomerParams

  CustomerTransactionListParams = Amocrm::Models::CustomerTransactionListParams
  CustomerUpdateByIDParams = Amocrm::Models::CustomerUpdateByIDParams
  CustomerUpdateParams = Amocrm::Models::CustomerUpdateParams
  CustomersModeSetModeParams = Amocrm::Models::CustomersModeSetModeParams
  EntityFollowerAddParams = Amocrm::Models::EntityFollowerAddParams
  EntityFollowerListParams = Amocrm::Models::EntityFollowerListParams
  EntityFollowerRemoveParams = Amocrm::Models::EntityFollowerRemoveParams
  EntityLinkLinkByEntityParams = Amocrm::Models::EntityLinkLinkByEntityParams
  EntityLinkLinkParams = Amocrm::Models::EntityLinkLinkParams
  EntityLinkListByEntityParams = Amocrm::Models::EntityLinkListByEntityParams
  EntityLinkListParams = Amocrm::Models::EntityLinkListParams

  EntityLinkUnlinkByEntityParams = Amocrm::Models::EntityLinkUnlinkByEntityParams

  EntityLinkUnlinkParams = Amocrm::Models::EntityLinkUnlinkParams
  EntityNoteCreateParams = Amocrm::Models::EntityNoteCreateParams
  EntityNoteGetByIDParams = Amocrm::Models::EntityNoteGetByIDParams
  EntityNoteListParams = Amocrm::Models::EntityNoteListParams
  EntityNotePinParams = Amocrm::Models::EntityNotePinParams
  EntityNoteUnpinParams = Amocrm::Models::EntityNoteUnpinParams
  EntityNoteUpdateByIDParams = Amocrm::Models::EntityNoteUpdateByIDParams
  EntityNoteUpdateParams = Amocrm::Models::EntityNoteUpdateParams

  EntityNotesByParentCreateByParentParams = Amocrm::Models::EntityNotesByParentCreateByParentParams

  EntityNotesByParentGetByParentIDParams = Amocrm::Models::EntityNotesByParentGetByParentIDParams

  EntityNotesByParentListByParentParams = Amocrm::Models::EntityNotesByParentListByParentParams

  EntityNotesByParentUpdateByParentIDParams = Amocrm::Models::EntityNotesByParentUpdateByParentIDParams

  EntityNotesByParentUpdateByParentParams = Amocrm::Models::EntityNotesByParentUpdateByParentParams

  module Errors
    class APIConnectionError < Amocrm::Errors::APIError
      sig { returns(NilClass) }
      attr_accessor :body

      sig { returns(NilClass) }
      attr_accessor :status

      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: NilClass,
            headers: T.nilable(T::Hash[String, String]),
            body: NilClass,
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status: nil, headers: nil, body: nil, request: nil, response: nil, message: "Connection error."); end
      end
    end

    class APIError < Amocrm::Errors::Error
      sig { returns(T.nilable(T.anything)) }
      attr_accessor :body

      sig { returns(T.nilable(T::Hash[String, String])) }
      attr_accessor :headers

      sig { returns(T.nilable(Integer)) }
      attr_accessor :status

      sig { returns(URI::Generic) }
      attr_accessor :url

      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: T.nilable(Integer),
            headers: T.nilable(T::Hash[String, String]),
            body: T.nilable(Object),
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status: nil, headers: nil, body: nil, request: nil, response: nil, message: nil); end
      end
    end

    class APIStatusError < Amocrm::Errors::APIError
      sig { returns(Integer) }
      attr_accessor :status

      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: Integer,
            headers: T.nilable(T::Hash[String, String]),
            body: T.nilable(Object),
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def for(url:, status:, headers:, body:, request:, response:, message: nil); end

        # @api private
        sig do
          params(
            url: URI::Generic,
            status: Integer,
            headers: T.nilable(T::Hash[String, String]),
            body: T.nilable(Object),
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status:, headers:, body:, request:, response:, message: nil); end
      end
    end

    class APITimeoutError < Amocrm::Errors::APIConnectionError
      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: NilClass,
            headers: T.nilable(T::Hash[String, String]),
            body: NilClass,
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status: nil, headers: nil, body: nil, request: nil, response: nil, message: "Request timed out."); end
      end
    end

    class AuthenticationError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = 401
    end

    class BadRequestError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = 400
    end

    class ConflictError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = 409
    end

    class ConversionError < Amocrm::Errors::Error
      sig { returns(T.nilable(StandardError)) }
      def cause; end

      class << self
        # @api private
        sig do
          params(
            on: T::Class[StandardError],
            method: Symbol,
            target: T.anything,
            value: T.anything,
            cause: T.nilable(StandardError)
          ).returns(T.attached_class)
        end
        def new(on:, method:, target:, value:, cause: nil); end
      end
    end

    class Error < StandardError
      sig { returns(T.nilable(StandardError)) }
      attr_accessor :cause
    end

    class InternalServerError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = T.let((500..), T::Range[Integer])
    end

    class NotFoundError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = 404
    end

    class PermissionDeniedError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = 403
    end

    class RateLimitError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = 429
    end

    class UnprocessableEntityError < Amocrm::Errors::APIStatusError
      HTTP_STATUS = 422
    end
  end

  EventGetByIDParams = Amocrm::Models::EventGetByIDParams
  EventListParams = Amocrm::Models::EventListParams
  EventListTypesParams = Amocrm::Models::EventListTypesParams

  class FilePart
    sig { returns(T.any(Pathname, StringIO, IO, String)) }
    attr_reader :content

    sig { returns(T.nilable(String)) }
    attr_reader :content_type

    sig { returns(T.nilable(String)) }
    attr_reader :filename

    sig { params(a: T.anything).returns(String) }
    def to_json(*a); end

    sig { params(a: T.anything).returns(String) }
    def to_yaml(*a); end

    private

    # @api private
    sig { returns(String) }
    def read; end

    class << self
      sig do
        params(
          content: T.any(Pathname, StringIO, IO, String),
          filename: T.nilable(T.any(Pathname, String)),
          content_type: T.nilable(String)
        ).returns(T.attached_class)
      end
      def new(content, filename: nil, content_type: nil); end
    end
  end

  module Internal
    extend Amocrm::Internal::Util::SorbetRuntimeSupport

    # Due to the current WIP status of Shapes support in Sorbet, types referencing
    # this alias might be refined in the future.
    AnyHash = T.type_alias { T::Hash[Symbol, T.anything] }

    FileInput = T.type_alias { T.any(Pathname, StringIO, IO, String, Amocrm::FilePart) }

    OMIT = T.let(Object.new.freeze, T.anything)

    module Transport
      # @api private
      class BaseClient
        extend Amocrm::Internal::Util::SorbetRuntimeSupport

        abstract!

        sig { returns(URI::Generic) }
        attr_reader :base_url

        sig { returns(T::Hash[String, String]) }
        attr_reader :headers

        sig { returns(T.nilable(String)) }
        attr_reader :idempotency_header

        sig { returns(Float) }
        attr_reader :initial_retry_delay

        sig { returns(Integer) }
        attr_reader :max_retries

        sig { returns(Float) }
        attr_reader :max_retry_delay

        # @api private
        sig { returns(Amocrm::Internal::Transport::PooledNetRequester) }
        attr_reader :requester

        sig { returns(Float) }
        attr_reader :timeout

        # @api private
        sig { returns(String) }
        def inspect; end

        # Execute the request specified by `req`. This is the method that all resource
        # methods call into.
        #
        # @overload request(method, path, query: {}, headers: {}, body: nil, unwrap: nil, page: nil, stream: nil, model: Amocrm::Internal::Type::Unknown, options: {})
        sig do
          params(
            method: Symbol,
            path: T.any(String, T::Array[String]),
            query: T.nilable(
                T::Hash[String, T.nilable(T.any(T::Array[String], String))]
              ),
            headers: T.nilable(
                T::Hash[
                  String,
                  T.nilable(
                    T.any(
                      String,
                      Integer,
                      T::Array[T.nilable(T.any(String, Integer))]
                    )
                  )
                ]
              ),
            body: T.nilable(T.anything),
            unwrap: T.nilable(
                T.any(
                  Symbol,
                  Integer,
                  T::Array[T.any(Symbol, Integer)],
                  T.proc.params(arg0: T.anything).returns(T.anything)
                )
              ),
            page: T.nilable(
                T::Class[
                  Amocrm::Internal::Type::BasePage[
                    Amocrm::Internal::Type::BaseModel
                  ]
                ]
              ),
            stream: T.nilable(T::Class[T.anything]),
            model: T.nilable(Amocrm::Internal::Type::Converter::Input),
            options: T.nilable(Amocrm::RequestOptions::OrHash)
          ).returns(T.anything)
        end
        def request(method, path, query: {}, headers: {}, body: nil, unwrap: nil, page: nil, stream: nil, model: Amocrm::Internal::Type::Unknown, options: {}); end

        # @api private
        sig do
          params(
            request: Amocrm::Internal::Transport::BaseClient::RequestInput,
            redirect_count: Integer,
            retry_count: Integer,
            send_retry_header: T::Boolean
          ).returns([Integer, Net::HTTPResponse, T::Enumerable[String]])
        end
        def send_request(request, redirect_count:, retry_count:, send_retry_header:); end

        private

        # @api private
        sig { overridable.returns(T::Hash[String, String]) }
        def auth_headers; end

        # @api private
        sig do
          overridable
            .params(
              req: Amocrm::Internal::Transport::BaseClient::RequestComponents,
              opts: Amocrm::Internal::AnyHash
            ).returns(Amocrm::Internal::Transport::BaseClient::RequestInput)
        end
        def build_request(req, opts); end

        # @api private
        sig { returns(String) }
        def generate_idempotency_key; end

        # @api private
        sig { params(headers: T::Hash[String, String], retry_count: Integer).returns(Float) }
        def retry_delay(headers, retry_count:); end

        # @api private
        sig { returns(String) }
        def user_agent; end

        class << self
          # @api private
          sig do
            params(
              request: Amocrm::Internal::Transport::BaseClient::RequestInput,
              status: Integer,
              response_headers: T::Hash[String, String]
            ).returns(Amocrm::Internal::Transport::BaseClient::RequestInput)
          end
          def follow_redirect(request, status:, response_headers:); end

          # @api private
          sig do
            params(
              status: T.any(Integer, Amocrm::Errors::APIConnectionError),
              stream: T.nilable(T::Enumerable[String])
            ).void
          end
          def reap_connection!(status, stream:); end

          # @api private
          sig { params(status: Integer, headers: T::Hash[String, String]).returns(T::Boolean) }
          def should_retry?(status, headers:); end

          # @api private
          sig { params(req: Amocrm::Internal::Transport::BaseClient::RequestComponents).void }
          def validate!(req); end
        end

        class << self
          # @api private
          sig do
            params(
              base_url: String,
              timeout: Float,
              max_retries: Integer,
              initial_retry_delay: Float,
              max_retry_delay: Float,
              headers: T::Hash[
                String,
                T.nilable(
                  T.any(
                    String,
                    Integer,
                    T::Array[T.nilable(T.any(String, Integer))]
                  )
                )
              ],
              idempotency_header: T.nilable(String)
            ).returns(T.attached_class)
          end
          def new(base_url:, timeout: 0.0, max_retries: 0, initial_retry_delay: 0.0, max_retry_delay: 0.0, headers: {}, idempotency_header: nil); end
        end

        # from whatwg fetch spec
        MAX_REDIRECTS = 20

        PLATFORM_HEADERS = T::Hash[String, String]

        RequestComponents = T.type_alias do
            {
              method: Symbol,
              path: T.any(String, T::Array[String]),
              query:
                T.nilable(
                  T::Hash[String, T.nilable(T.any(T::Array[String], String))]
                ),
              headers:
                T.nilable(
                  T::Hash[
                    String,
                    T.nilable(
                      T.any(
                        String,
                        Integer,
                        T::Array[T.nilable(T.any(String, Integer))]
                      )
                    )
                  ]
                ),
              body: T.nilable(T.anything),
              unwrap:
                T.nilable(
                  T.any(
                    Symbol,
                    Integer,
                    T::Array[T.any(Symbol, Integer)],
                    T.proc.params(arg0: T.anything).returns(T.anything)
                  )
                ),
              page:
                T.nilable(
                  T::Class[
                    Amocrm::Internal::Type::BasePage[
                      Amocrm::Internal::Type::BaseModel
                    ]
                  ]
                ),
              stream: T.nilable(T::Class[T.anything]),
              model: T.nilable(Amocrm::Internal::Type::Converter::Input),
              options: T.nilable(Amocrm::RequestOptions::OrHash)
            }
          end

        RequestInput = T.type_alias do
            {
              method: Symbol,
              url: URI::Generic,
              headers: T::Hash[String, String],
              body: T.anything,
              max_retries: Integer,
              timeout: Float
            }
          end
      end

      # @api private
      class PooledNetRequester
        extend Amocrm::Internal::Util::SorbetRuntimeSupport

        # @api private
        sig do
          params(
            request: Amocrm::Internal::Transport::PooledNetRequester::Request
          ).returns([Integer, Net::HTTPResponse, T::Enumerable[String]])
        end
        def execute(request); end

        private

        # @api private
        sig { params(url: URI::Generic, deadline: Float, blk: T.proc.params(arg0: Net::HTTP).void).void }
        def with_pool(url, deadline:, &blk); end

        class << self
          # @api private
          sig do
            params(
              request: Amocrm::Internal::Transport::PooledNetRequester::Request,
              blk: T.proc.params(arg0: String).void
            ).returns([Net::HTTPGenericRequest, T.proc.void])
          end
          def build_request(request, &blk); end

          # @api private
          sig { params(conn: Net::HTTP, deadline: Float).void }
          def calibrate_socket_timeout(conn, deadline); end

          # @api private
          sig { params(cert_store: OpenSSL::X509::Store, url: URI::Generic).returns(Net::HTTP) }
          def connect(cert_store:, url:); end
        end

        class << self
          # @api private
          sig { params(size: Integer).returns(T.attached_class) }
          def new(size: Amocrm::Internal::Transport::PooledNetRequester::DEFAULT_MAX_CONNECTIONS); end
        end

        DEFAULT_MAX_CONNECTIONS = T.let(T.unsafe(nil), Integer)

        # from the golang stdlib
        # https://github.com/golang/go/blob/c8eced8580028328fde7c03cbfcb720ce15b2358/src/net/http/transport.go#L49
        KEEP_ALIVE_TIMEOUT = 30

        Request = T.type_alias do
            {
              method: Symbol,
              url: URI::Generic,
              headers: T::Hash[String, String],
              body: T.anything,
              deadline: Float
            }
          end
      end
    end

    module Type
      # @api private
      #
      # Array of items of a given type.
      class ArrayOf
        include Amocrm::Internal::Type::Converter
        include Amocrm::Internal::Util::SorbetRuntimeSupport

        abstract!

        Elem = type_member(:out)

        # @api private
        sig do
          params(
            type_info: T.any(
                Amocrm::Internal::AnyHash,
                T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                Amocrm::Internal::Type::Converter::Input
              ),
            spec: Amocrm::Internal::AnyHash
          ).void
        end
        def initialize(type_info, spec = {}); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Array[T.anything], T.anything),
              state: Amocrm::Internal::Type::Converter::CoerceState
            ).returns(T.any(T::Array[T.anything], T.anything))
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Array[T.anything], T.anything),
              state: Amocrm::Internal::Type::Converter::DumpState
            ).returns(T.any(T::Array[T.anything], T.anything))
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        protected

        # @api private
        sig { returns(Elem) }
        def item_type; end

        # @api private
        sig { returns(T::Boolean) }
        def nilable?; end

        class << self
          sig do
            params(
              type_info: T.any(
                Amocrm::Internal::AnyHash,
                T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                Amocrm::Internal::Type::Converter::Input
              ),
              spec: Amocrm::Internal::AnyHash
            ).returns(T.attached_class)
          end
          def [](type_info, spec = {}); end
        end
      end

      class BaseModel
        extend Amocrm::Internal::Type::Converter
        extend Amocrm::Internal::Util::SorbetRuntimeSupport

        abstract!

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        # Returns the raw value associated with the given key, if found. Otherwise, nil is
        # returned.
        #
        # It is valid to lookup keys that are not in the API spec, for example to access
        # undocumented features. This method does not parse response data into
        # higher-level types. Lookup by anything other than a Symbol is an ArgumentError.
        sig { params(key: Symbol).returns(T.nilable(T.anything)) }
        def [](key); end

        sig { params(keys: T.nilable(T::Array[Symbol])).returns(Amocrm::Internal::AnyHash) }
        def deconstruct_keys(keys); end

        # In addition to the behaviour of `#to_h`, this method will recursively call
        # `#to_h` on nested models.
        sig { overridable.returns(Amocrm::Internal::AnyHash) }
        def deep_to_h; end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { returns(String) }
        def inspect; end

        # Returns a Hash of the data underlying this object. O(1)
        #
        # Keys are Symbols and values are the raw values from the response. The return
        # value indicates which values were ever set on the object. i.e. there will be a
        # key in this hash if they ever were, even if the set value was nil.
        #
        # This method is not recursive. The returned value is shared by the object, so it
        # should not be mutated.
        sig { overridable.returns(Amocrm::Internal::AnyHash) }
        def to_h; end

        # Returns a Hash of the data underlying this object. O(1)
        #
        # Keys are Symbols and values are the raw values from the response. The return
        # value indicates which values were ever set on the object. i.e. there will be a
        # key in this hash if they ever were, even if the set value was nil.
        #
        # This method is not recursive. The returned value is shared by the object, so it
        # should not be mutated.
        sig { overridable.returns(Amocrm::Internal::AnyHash) }
        def to_hash; end

        sig { params(a: T.anything).returns(String) }
        def to_json(*a); end

        sig { returns(String) }
        def to_s; end

        sig { params(a: T.anything).returns(String) }
        def to_yaml(*a); end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          # @api private
          sig do
            returns(T::Hash[
                Symbol,
                T.all(
                  Amocrm::Internal::Type::BaseModel::KnownField,
                  { type: Amocrm::Internal::Type::Converter::Input }
                )
              ])
          end
          def fields; end

          sig { returns(Integer) }
          def hash; end

          # @api private
          #
          # Assumes superclass fields are totally defined before fields are accessed /
          # defined on subclasses.
          sig { params(child: Amocrm::Internal::Type::BaseModel).void }
          def inherited(child); end

          # @api private
          sig do
            returns(T::Hash[
                Symbol,
                T.all(
                  Amocrm::Internal::Type::BaseModel::KnownField,
                  {
                    type_fn:
                      T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                  }
                )
              ])
          end
          def known_fields; end

          # @api private
          sig do
            params(
              name_sym: Symbol,
              type_info: T.any(
                  Amocrm::Internal::AnyHash,
                  T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                  Amocrm::Internal::Type::Converter::Input
                ),
              spec: Amocrm::Internal::AnyHash
            ).void
          end
          def optional(name_sym, type_info, spec = {}); end

          # @api private
          sig do
            params(
              name_sym: Symbol,
              type_info: T.any(
                  Amocrm::Internal::AnyHash,
                  T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                  Amocrm::Internal::Type::Converter::Input
                ),
              spec: Amocrm::Internal::AnyHash
            ).void
          end
          def required(name_sym, type_info, spec = {}); end

          private

          # @api private
          sig do
            params(
              name_sym: Symbol,
              required: T::Boolean,
              type_info: T.any(
                  {
                    const:
                      T.nilable(
                        T.any(NilClass, T::Boolean, Integer, Float, Symbol)
                      ),
                    enum:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      ),
                    union:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      ),
                    api_name: Symbol,
                    nil?: T::Boolean
                  },
                  T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                  Amocrm::Internal::Type::Converter::Input
                ),
              spec: Amocrm::Internal::AnyHash
            ).void
          end
          def add_field(name_sym, required:, type_info:, spec:); end

          # @api private
          #
          # `request_only` attributes not excluded from `.#coerce` when receiving responses
          # even if well behaved servers should not send them
          sig { params(blk: T.proc.void).void }
          def request_only(&blk); end

          # @api private
          #
          # `response_only` attributes are omitted from `.#dump` when making requests
          sig { params(blk: T.proc.void).void }
          def response_only(&blk); end
        end

        class << self
          # @api private
          sig do
            override
              .params(
                value: T.any(
                    Amocrm::Internal::Type::BaseModel,
                    T::Hash[T.anything, T.anything],
                    T.anything
                  ),
                state: Amocrm::Internal::Type::Converter::CoerceState
              ).returns(T.any(T.attached_class, T.anything))
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.any(T.attached_class, T.anything),
                state: Amocrm::Internal::Type::Converter::DumpState
              ).returns(T.any(T::Hash[T.anything, T.anything], T.anything))
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          # @api private
          sig do
            params(
              model: Amocrm::Internal::Type::BaseModel,
              convert: T::Boolean
            ).returns(Amocrm::Internal::AnyHash)
          end
          def recursively_to_h(model, convert:); end
        end

        class << self
          # @api private
          sig { params(depth: Integer).returns(String) }
          def inspect(depth: 0); end
        end

        class << self
          # Create a new instance of a model.
          sig do
            params(
              data: T.any(
                T::Hash[Symbol, T.anything],
                Amocrm::Internal::Type::BaseModel
              )
            ).returns(T.attached_class)
          end
          def new(data = {}); end
        end

        KnownField = T.type_alias do
            {
              mode: T.nilable(Symbol),
              required: T::Boolean,
              nilable: T::Boolean
            }
          end

        OrHash = T.type_alias do
            T.any(Amocrm::Internal::Type::BaseModel, Amocrm::Internal::AnyHash)
          end
      end

      # @api private
      #
      # This module provides a base implementation for paginated responses in the SDK.
      module BasePage
        Elem = type_member(:out)

        # @api private
        sig do
          params(
            client: Amocrm::Internal::Transport::BaseClient,
            req: Amocrm::Internal::Transport::BaseClient::RequestComponents,
            headers: T::Hash[String, String],
            page_data: T.anything
          ).void
        end
        def initialize(client:, req:, headers:, page_data:); end

        sig { overridable.params(blk: T.proc.params(arg0: Elem).void).void }
        def auto_paging_each(&blk); end

        sig { overridable.returns(T.self_type) }
        def next_page; end

        sig { overridable.returns(T::Boolean) }
        def next_page?; end

        sig { returns(T::Enumerable[Elem]) }
        def to_enum; end
      end

      # @api private
      #
      # Ruby has no Boolean class; this is something for models to refer to.
      class Boolean
        extend Amocrm::Internal::Type::Converter
        extend Amocrm::Internal::Util::SorbetRuntimeSupport

        abstract!

        class << self
          # @api private
          #
          # Coerce value to Boolean if possible, otherwise return the original value.
          sig do
            override
              .params(
                value: T.any(T::Boolean, T.anything),
                state: Amocrm::Internal::Type::Converter::CoerceState
              ).returns(T.any(T::Boolean, T.anything))
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.any(T::Boolean, T.anything),
                state: Amocrm::Internal::Type::Converter::DumpState
              ).returns(T.any(T::Boolean, T.anything))
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          sig { params(other: T.anything).returns(T::Boolean) }
          def ===(other); end
        end
      end

      # @api private
      module Converter
        extend Amocrm::Internal::Util::SorbetRuntimeSupport

        # @api private
        sig do
          overridable
            .params(
              value: T.anything,
              state: Amocrm::Internal::Type::Converter::CoerceState
            ).returns(T.anything)
        end
        def coerce(value, state:); end

        # @api private
        sig do
          overridable
            .params(
              value: T.anything,
              state: Amocrm::Internal::Type::Converter::DumpState
            ).returns(T.anything)
        end
        def dump(value, state:); end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        class << self
          class << self
            # @api private
            #
            # Based on `target`, transform `value` into `target`, to the extent possible:
            #
            # 1. if the given `value` conforms to `target` already, return the given `value`
            # 2. if it's possible and safe to convert the given `value` to `target`, then the
            #    converted value
            # 3. otherwise, the given `value` unaltered
            #
            # The coercion process is subject to improvement between minor release versions.
            # See https://docs.pydantic.dev/latest/concepts/unions/#smart-mode
            sig do
              params(
                target: Amocrm::Internal::Type::Converter::Input,
                value: T.anything,
                state: Amocrm::Internal::Type::Converter::CoerceState
              ).returns(T.anything)
            end
            def coerce(
              target,
              value,
              state: Amocrm::Internal::Type::Converter.new_coerce_state # The `strictness` is one of `true`, `false`. This informs the coercion strategy
                                                                        # when we have to decide between multiple possible conversion targets:
                                                                        # - `true`: the conversion must be exact, with minimum coercion.
                                                                        # - `false`: the conversion can be approximate, with some coercion.
                                                                        # The `exactness` is `Hash` with keys being one of `yes`, `no`, or `maybe`. For
                                                                        # any given conversion attempt, the exactness will be updated based on how closely
                                                                        # the value recursively matches the target type:
                                                                        # - `yes`: the value can be converted to the target type with minimum coercion.
                                                                        # - `maybe`: the value can be converted to the target type with some reasonable
                                                                        #   coercion.
                                                                        # - `no`: the value cannot be converted to the target type.
                                                                        # See implementation below for more details.
); end

            # @api private
            sig do
              params(
                target: Amocrm::Internal::Type::Converter::Input,
                value: T.anything,
                state: Amocrm::Internal::Type::Converter::DumpState
              ).returns(T.anything)
            end
            def dump(target, value, state: { can_retry: true }); end

            # @api private
            sig { params(target: T.anything, depth: Integer).returns(String) }
            def inspect(target, depth:); end

            # @api private
            sig do
              params(
                type_info: T.any(
                  {
                    const:
                      T.nilable(
                        T.any(NilClass, T::Boolean, Integer, Float, Symbol)
                      ),
                    enum:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      ),
                    union:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      )
                  },
                  T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                  Amocrm::Internal::Type::Converter::Input
                ),
                spec: T.any(
                  {
                    const:
                      T.nilable(
                        T.any(NilClass, T::Boolean, Integer, Float, Symbol)
                      ),
                    enum:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      ),
                    union:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      )
                  },
                  T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                  Amocrm::Internal::Type::Converter::Input
                )
              ).returns(Amocrm::Internal::AnyHash)
            end
            def meta_info(type_info, spec); end

            # @api private
            sig { params(translate_names: T::Boolean).returns(Amocrm::Internal::Type::Converter::CoerceState) }
            def new_coerce_state(translate_names: true); end

            # @api private
            sig do
              params(
                spec: T.any(
                  {
                    const:
                      T.nilable(
                        T.any(NilClass, T::Boolean, Integer, Float, Symbol)
                      ),
                    enum:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      ),
                    union:
                      T.nilable(
                        T.proc.returns(Amocrm::Internal::Type::Converter::Input)
                      )
                  },
                  T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                  Amocrm::Internal::Type::Converter::Input
                )
              ).returns(T.proc.returns(T.anything))
            end
            def type_info(spec); end
          end
        end

        CoerceState = T.type_alias do
            {
              translate_names: T::Boolean,
              strictness: T::Boolean,
              exactness: {
                yes: Integer,
                no: Integer,
                maybe: Integer
              },
              error: T::Class[StandardError],
              branched: Integer
            }
          end

        DumpState = T.type_alias { { can_retry: T::Boolean } }

        Input = T.type_alias do
            T.any(Amocrm::Internal::Type::Converter, T::Class[T.anything])
          end
      end

      # @api private
      #
      # A value from among a specified list of options. OpenAPI enum values map to Ruby
      # values in the SDK as follows:
      #
      # 1. boolean => true | false
      # 2. integer => Integer
      # 3. float => Float
      # 4. string => Symbol
      #
      # We can therefore convert string values to Symbols, but can't convert other
      # values safely.
      module Enum
        include Amocrm::Internal::Type::Converter
        include Amocrm::Internal::Util::SorbetRuntimeSupport

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        #
        # Unlike with primitives, `Enum` additionally validates that the value is a member
        # of the enum.
        sig do
          override
            .params(
              value: T.any(String, Symbol, T.anything),
              state: Amocrm::Internal::Type::Converter::CoerceState
            ).returns(T.any(Symbol, T.anything))
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.any(Symbol, T.anything),
              state: Amocrm::Internal::Type::Converter::DumpState
            ).returns(T.any(Symbol, T.anything))
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        # All of the valid Symbol values for this enum.
        sig { overridable.returns(T::Array[T.any(NilClass, T::Boolean, Integer, Float, Symbol)]) }
        def values; end
      end

      # @api private
      #
      # Either `Pathname` or `StringIO`, or `IO`, or
      # `Amocrm::Internal::Type::FileInput`.
      #
      # Note: when `IO` is used, all retries are disabled, since many IO` streams are
      # not rewindable.
      class FileInput
        extend Amocrm::Internal::Type::Converter

        abstract!

        class << self
          # @api private
          sig do
            override
              .params(
                value: T.any(StringIO, String, T.anything),
                state: Amocrm::Internal::Type::Converter::CoerceState
              ).returns(T.any(StringIO, T.anything))
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.any(Pathname, StringIO, IO, String, T.anything),
                state: Amocrm::Internal::Type::Converter::DumpState
              ).returns(T.any(Pathname, StringIO, IO, String, T.anything))
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          sig { params(other: T.anything).returns(T::Boolean) }
          def ===(other); end
        end
      end

      # @api private
      #
      # Hash of items of a given type.
      class HashOf
        include Amocrm::Internal::Type::Converter
        include Amocrm::Internal::Util::SorbetRuntimeSupport

        abstract!

        Elem = type_member(:out)

        # @api private
        sig do
          params(
            type_info: T.any(
                Amocrm::Internal::AnyHash,
                T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                Amocrm::Internal::Type::Converter::Input
              ),
            spec: Amocrm::Internal::AnyHash
          ).void
        end
        def initialize(type_info, spec = {}); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Hash[T.anything, T.anything], T.anything),
              state: Amocrm::Internal::Type::Converter::CoerceState
            ).returns(T.any(Amocrm::Internal::AnyHash, T.anything))
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Hash[T.anything, T.anything], T.anything),
              state: Amocrm::Internal::Type::Converter::DumpState
            ).returns(T.any(Amocrm::Internal::AnyHash, T.anything))
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        protected

        # @api private
        sig { returns(Elem) }
        def item_type; end

        # @api private
        sig { returns(T::Boolean) }
        def nilable?; end

        class << self
          sig do
            params(
              type_info: T.any(
                Amocrm::Internal::AnyHash,
                T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                Amocrm::Internal::Type::Converter::Input
              ),
              spec: Amocrm::Internal::AnyHash
            ).returns(T.attached_class)
          end
          def [](type_info, spec = {}); end
        end
      end

      # @api private
      module RequestParameters
        # Options to specify HTTP behaviour for this request.
        sig { returns(Amocrm::RequestOptions) }
        attr_reader :request_options

        sig { params(request_options: Amocrm::RequestOptions::OrHash).void }
        attr_writer :request_options

        # @api private
        module Converter
          # @api private
          sig { params(params: T.anything).returns([T.anything, Amocrm::Internal::AnyHash]) }
          def dump_request(params); end
        end
      end

      # @api private
      module Union
        include Amocrm::Internal::Type::Converter
        include Amocrm::Internal::Util::SorbetRuntimeSupport

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        #
        # Tries to efficiently coerce the given value to one of the known variants.
        #
        # If the value cannot match any of the known variants, the coercion is considered
        # non-viable and returns the original value.
        sig do
          override
            .params(
              value: T.anything,
              state: Amocrm::Internal::Type::Converter::CoerceState
            ).returns(T.anything)
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.anything,
              state: Amocrm::Internal::Type::Converter::DumpState
            ).returns(T.anything)
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        # All of the specified variants for this union.
        sig { overridable.returns(T::Array[T.anything]) }
        def variants; end

        protected

        # @api private
        sig { returns(T::Array[[T.nilable(Symbol), T.anything, Amocrm::Internal::AnyHash]]) }
        def derefed_variants; end

        private

        # @api private
        sig { params(property: Symbol).void }
        def discriminator(property); end

        # @api private
        #
        # All of the specified variant info for this union.
        sig do
          returns(T::Array[
              [
                T.nilable(Symbol),
                T.proc.returns(Amocrm::Internal::Type::Converter::Input),
                Amocrm::Internal::AnyHash
              ]
            ])
        end
        def known_variants; end

        # @api private
        sig { params(value: T.anything).returns(T.nilable(T.anything)) }
        def resolve_variant(value); end

        # @api private
        sig do
          params(
            key: T.any(
                Symbol,
                Amocrm::Internal::AnyHash,
                T.proc.returns(T.anything),
                T.anything
              ),
            spec: T.any(
                Amocrm::Internal::AnyHash,
                T.proc.returns(T.anything),
                T.anything
              )
          ).void
        end
        def variant(key, spec = nil); end
      end

      # @api private
      #
      # When we don't know what to expect for the value.
      class Unknown
        extend Amocrm::Internal::Type::Converter
        extend Amocrm::Internal::Util::SorbetRuntimeSupport

        abstract!

        class << self
          # @api private
          #
          # No coercion needed for Unknown type.
          sig do
            override
              .params(
                value: T.anything,
                state: Amocrm::Internal::Type::Converter::CoerceState
              ).returns(T.anything)
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.anything,
                state: Amocrm::Internal::Type::Converter::DumpState
              ).returns(T.anything)
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          sig { params(other: T.anything).returns(T::Boolean) }
          def ===(other); end
        end
      end
    end

    # @api private
    module Util
      extend Amocrm::Internal::Util::SorbetRuntimeSupport

      class << self
        # @api private
        sig { returns(String) }
        def arch; end

        # @api private
        sig { returns(String) }
        def os; end
      end

      class << self
        # @api private
        sig { params(input: T.any(String, T::Boolean)).returns(T.any(T::Boolean, T.anything)) }
        def coerce_boolean(input); end

        # @api private
        sig { params(input: T.any(String, T::Boolean)).returns(T.nilable(T::Boolean)) }
        def coerce_boolean!(input); end

        # @api private
        sig { params(input: T.any(String, Integer, Float)).returns(T.any(Float, T.anything)) }
        def coerce_float(input); end

        # @api private
        sig { params(input: T.anything).returns(T.any(T::Hash[T.anything, T.anything], T.anything)) }
        def coerce_hash(input); end

        # @api private
        sig { params(input: T.anything).returns(T.nilable(T::Hash[T.anything, T.anything])) }
        def coerce_hash!(input); end

        # @api private
        sig { params(input: T.any(String, Integer)).returns(T.any(Integer, T.anything)) }
        def coerce_integer(input); end

        # @api private
        sig { params(input: T.anything).returns(T::Boolean) }
        def primitive?(input); end
      end

      class << self
        # @api private
        #
        # Recursively merge one hash with another. If the values at a given key are not
        # both hashes, just take the new value.
        sig do
          params(
            values: T::Array[T.anything],
            sentinel: T.nilable(T.anything),
            concat: T::Boolean
          ).returns(T.anything)
        end
        def deep_merge(
          *values,
          sentinel: nil, # the value to return if no values are provided.
          concat: false # whether to merge sequences by concatenation.
); end

        # @api private
        sig do
          params(
            data: T.any(
                Amocrm::Internal::AnyHash,
                T::Array[T.anything],
                T.anything
              ),
            pick: T.nilable(
                T.any(
                  Symbol,
                  Integer,
                  T::Array[T.any(Symbol, Integer)],
                  T.proc.params(arg0: T.anything).returns(T.anything)
                )
              ),
            blk: T.nilable(T.proc.returns(T.anything))
          ).returns(T.nilable(T.anything))
        end
        def dig(data, pick, &blk); end

        private

        # @api private
        sig { params(lhs: T.anything, rhs: T.anything, concat: T::Boolean).returns(T.anything) }
        def deep_merge_lr(lhs, rhs, concat: false); end
      end

      class << self
        # @api private
        sig { params(path: T.any(String, T::Array[String])).returns(String) }
        def interpolate_path(path); end

        # @api private
        sig { params(uri: URI::Generic).returns(String) }
        def uri_origin(uri); end
      end

      class << self
        # @api private
        sig { params(query: T.nilable(String)).returns(T::Hash[String, T::Array[String]]) }
        def decode_query(query); end

        # @api private
        sig do
          params(
            query: T.nilable(
                T::Hash[String, T.nilable(T.any(T::Array[String], String))]
              )
          ).returns(T.nilable(String))
        end
        def encode_query(query); end
      end

      class << self
        # @api private
        sig do
          params(
            lhs: Amocrm::Internal::Util::ParsedUri,
            rhs: Amocrm::Internal::Util::ParsedUri
          ).returns(URI::Generic)
        end
        def join_parsed_uri(lhs, rhs); end

        # @api private
        sig { params(url: T.any(URI::Generic, String)).returns(Amocrm::Internal::Util::ParsedUri) }
        def parse_uri(url); end

        # @api private
        sig { params(parsed: Amocrm::Internal::Util::ParsedUri).returns(URI::Generic) }
        def unparse_uri(parsed); end
      end

      class << self
        # @api private
        sig do
          params(
            headers: T::Hash[
                String,
                T.nilable(
                  T.any(
                    String,
                    Integer,
                    T::Array[T.nilable(T.any(String, Integer))]
                  )
                )
              ]
          ).returns(T::Hash[String, String])
        end
        def normalized_headers(*headers); end
      end

      class << self
        sig { params(blk: T.proc.params(y: Enumerator::Yielder).void).returns(T::Enumerable[String]) }
        def writable_enum(&blk); end
      end

      class << self
        # @api private
        #
        # Assumes each chunk in stream has `Encoding::BINARY`.
        sig do
          params(
            headers: T::Hash[String, String],
            stream: T::Enumerable[String],
            suppress_error: T::Boolean
          ).returns(T.anything)
        end
        def decode_content(headers, stream:, suppress_error: false); end

        # @api private
        sig { params(headers: T::Hash[String, String], body: T.anything).returns(T.anything) }
        def encode_content(headers, body); end

        # @api private
        #
        # https://www.iana.org/assignments/character-sets/character-sets.xhtml
        sig { params(content_type: String, text: String).void }
        def force_charset!(content_type, text:); end

        private

        # @api private
        #
        # https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.1.md#special-considerations-for-multipart-content
        sig { params(body: T.anything).returns([String, T::Enumerable[String]]) }
        def encode_multipart_streaming(body); end

        # @api private
        sig do
          params(
            y: Enumerator::Yielder,
            boundary: String,
            key: T.any(Symbol, String),
            val: T.anything,
            closing: T::Array[T.proc.void]
          ).void
        end
        def write_multipart_chunk(y, boundary:, key:, val:, closing:); end

        # @api private
        sig do
          params(
            y: Enumerator::Yielder,
            val: T.anything,
            closing: T::Array[T.proc.void],
            content_type: T.nilable(String)
          ).void
        end
        def write_multipart_content(y, val:, closing:, content_type: nil); end
      end

      class << self
        # @api private
        sig do
          params(
            enum: T.nilable(T::Enumerable[T.anything]),
            blk: T.proc.params(arg0: Enumerator::Yielder).void
          ).returns(T::Enumerable[T.anything])
        end
        def chain_fused(enum, &blk); end

        # @api private
        sig { params(enum: T.nilable(T::Enumerable[T.anything])).void }
        def close_fused!(enum); end

        # @api private
        #
        # https://doc.rust-lang.org/std/iter/trait.FusedIterator.html
        sig do
          params(
            enum: T::Enumerable[T.anything],
            external: T::Boolean,
            close: T.proc.void
          ).returns(T::Enumerable[T.anything])
        end
        def fused_enum(enum, external: false, &close); end
      end

      class << self
        # @api private
        #
        # Assumes Strings have been forced into having `Encoding::BINARY`.
        #
        # This decoder is responsible for reassembling lines split across multiple
        # fragments.
        sig { params(enum: T::Enumerable[String]).returns(T::Enumerable[String]) }
        def decode_lines(enum); end

        # @api private
        #
        # https://html.spec.whatwg.org/multipage/server-sent-events.html#parsing-an-event-stream
        #
        # Assumes that `lines` has been decoded with `#decode_lines`.
        sig { params(lines: T::Enumerable[String]).returns(T::Enumerable[Amocrm::Internal::Util::ServerSentEvent]) }
        def decode_sse(lines); end
      end

      class << self
        # @api private
        sig { returns(Float) }
        def monotonic_secs; end

        # @api private
        sig do
          params(
            ns: T.any(Module, T::Class[T.anything])
          ).returns(T::Enumerable[T.any(Module, T::Class[T.anything])])
        end
        def walk_namespaces(ns); end
      end

      JSONL_CONTENT = T.let(%r{^application/(:?x-(?:n|l)djson)|(:?(?:x-)?jsonl)}, Regexp)

      JSON_CONTENT = T.let(%r{^application/(?:[a-zA-Z0-9.-]+\+)?json(?!l)}, Regexp)

      ParsedUri = T.type_alias do
          {
            scheme: T.nilable(String),
            host: T.nilable(String),
            port: T.nilable(Integer),
            path: T.nilable(String),
            query: T::Hash[String, T::Array[String]]
          }
        end

      # @api private
      #
      # An adapter that satisfies the IO interface required by `::IO.copy_stream`
      class ReadIOAdapter
        # @api private
        sig { void }
        def close; end

        # @api private
        sig { returns(T.nilable(T::Boolean)) }
        def close?; end

        # @api private
        sig { params(max_len: T.nilable(Integer), out_string: T.nilable(String)).returns(T.nilable(String)) }
        def read(max_len = nil, out_string = nil); end

        private

        # @api private
        sig { params(max_len: T.nilable(Integer)).returns(String) }
        def read_enum(max_len); end

        class << self
          # @api private
          sig do
            params(
              src: T.any(String, Pathname, StringIO, T::Enumerable[String]),
              blk: T.proc.params(arg0: String).void
            ).returns(T.attached_class)
          end
          def new(src, &blk); end
        end
      end

      ServerSentEvent = T.type_alias do
          {
            event: T.nilable(String),
            data: T.nilable(String),
            id: T.nilable(String),
            retry: T.nilable(Integer)
          }
        end

      # @api private
      module SorbetRuntimeSupport
        # @api private
        sig { params(name: Symbol).void }
        def const_missing(name); end

        # @api private
        sig { params(name: Symbol, blk: T.proc.returns(T.anything)).void }
        def define_sorbet_constant!(name, &blk); end

        # @api private
        sig { params(name: Symbol).returns(T::Boolean) }
        def sorbet_constant_defined?(name); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        private

        # @api private
        sig { returns(T::Hash[Symbol, T.anything]) }
        def sorbet_runtime_constants; end

        class << self
          # @api private
          sig { params(type: T.any(Amocrm::Internal::Util::SorbetRuntimeSupport, T.anything)).returns(T.anything) }
          def to_sorbet_type(type); end
        end

        class MissingSorbetRuntimeError < ::RuntimeError; end
      end
    end
  end

  LeadCreateComplexParams = Amocrm::Models::LeadCreateComplexParams
  LeadCreateParams = Amocrm::Models::LeadCreateParams
  LeadGetByIDParams = Amocrm::Models::LeadGetByIDParams
  LeadListParams = Amocrm::Models::LeadListParams
  LeadUpdateByIDParams = Amocrm::Models::LeadUpdateByIDParams
  LeadUpdateParams = Amocrm::Models::LeadUpdateParams

  module Models
    class AccountGetParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Additional data to include (comma-separated).
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(
          with: nil, # Additional data to include (comma-separated).
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::AccountGetParams, Amocrm::Internal::AnyHash)
        end
    end

    module AccountGetResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::AccountGetResponse::Variants]) }
        def variants; end
      end

      class AccountInfo < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::AccountGetResponse::AccountInfo::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(String)) }
        attr_reader :amojo_id

        sig { params(amojo_id: String).void }
        attr_writer :amojo_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :contact_name_display_order

        sig { params(contact_name_display_order: Integer).void }
        attr_writer :contact_name_display_order

        sig { returns(T.nilable(String)) }
        attr_reader :country

        sig { params(country: String).void }
        attr_writer :country

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(String)) }
        attr_reader :currency

        sig { params(currency: String).void }
        attr_writer :currency

        sig { returns(T.nilable(String)) }
        attr_reader :currency_symbol

        sig { params(currency_symbol: String).void }
        attr_writer :currency_symbol

        sig { returns(T.nilable(Integer)) }
        attr_reader :current_user_id

        sig { params(current_user_id: Integer).void }
        attr_writer :current_user_id

        sig do
          returns(T.nilable(
              Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::Variants
            ))
        end
        attr_reader :customers_mode

        sig do
          params(
            customers_mode: T.any(
                Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :customers_mode

        sig { returns(T.nilable(String)) }
        attr_reader :drive_url

        sig { params(drive_url: String).void }
        attr_writer :drive_url

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig do
          returns(T.nilable(
              Amocrm::Models::AccountGetResponse::AccountInfo::InvoicesSettings
            ))
        end
        attr_reader :invoices_settings

        sig do
          params(
            invoices_settings: Amocrm::Models::AccountGetResponse::AccountInfo::InvoicesSettings::OrHash
          ).void
        end
        attr_writer :invoices_settings

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_api_filter_enabled

        sig { params(is_api_filter_enabled: T::Boolean).void }
        attr_writer :is_api_filter_enabled

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_helpbot_enabled

        sig { params(is_helpbot_enabled: T::Boolean).void }
        attr_writer :is_helpbot_enabled

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_loss_reason_enabled

        sig { params(is_loss_reason_enabled: T::Boolean).void }
        attr_writer :is_loss_reason_enabled

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_technical_account

        sig { params(is_technical_account: T::Boolean).void }
        attr_writer :is_technical_account

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_unsorted_on

        sig { params(is_unsorted_on: T::Boolean).void }
        attr_writer :is_unsorted_on

        sig { returns(T.nilable(Integer)) }
        attr_reader :mobile_feature_version

        sig { params(mobile_feature_version: Integer).void }
        attr_writer :mobile_feature_version

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_reader :subdomain

        sig { params(subdomain: String).void }
        attr_writer :subdomain

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig { returns(T.nilable(String)) }
        attr_reader :uuid

        sig { params(uuid: String).void }
        attr_writer :uuid

        sig { returns(T.nilable(Integer)) }
        attr_reader :version

        sig { params(version: Integer).void }
        attr_writer :version

        sig do
          override
            .returns({
              id: Integer,
              _embedded:
                Amocrm::Models::AccountGetResponse::AccountInfo::Embedded,
              _links: T.anything,
              amojo_id: String,
              contact_name_display_order: Integer,
              country: String,
              created_at: Integer,
              created_by: Integer,
              currency: String,
              currency_symbol: String,
              current_user_id: Integer,
              customers_mode:
                Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::Variants,
              drive_url: String,
              invoices_settings:
                Amocrm::Models::AccountGetResponse::AccountInfo::InvoicesSettings,
              is_api_filter_enabled: T::Boolean,
              is_helpbot_enabled: T::Boolean,
              is_loss_reason_enabled: T::Boolean,
              is_technical_account: T::Boolean,
              is_unsorted_on: T::Boolean,
              mobile_feature_version: Integer,
              name: String,
              subdomain: String,
              updated_at: Integer,
              updated_by: Integer,
              uuid: String,
              version: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::OrHash,
              _links: T.anything,
              amojo_id: String,
              contact_name_display_order: Integer,
              country: String,
              created_at: Integer,
              created_by: Integer,
              currency: String,
              currency_symbol: String,
              current_user_id: Integer,
              customers_mode: T.any(
                Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::OrSymbol,
                String
              ),
              drive_url: String,
              invoices_settings: Amocrm::Models::AccountGetResponse::AccountInfo::InvoicesSettings::OrHash,
              is_api_filter_enabled: T::Boolean,
              is_helpbot_enabled: T::Boolean,
              is_loss_reason_enabled: T::Boolean,
              is_technical_account: T::Boolean,
              is_unsorted_on: T::Boolean,
              mobile_feature_version: Integer,
              name: String,
              subdomain: String,
              updated_at: Integer,
              updated_by: Integer,
              uuid: String,
              version: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, amojo_id: nil, contact_name_display_order: nil, country: nil, created_at: nil, created_by: nil, currency: nil, currency_symbol: nil, current_user_id: nil, customers_mode: nil, drive_url: nil, invoices_settings: nil, is_api_filter_enabled: nil, is_helpbot_enabled: nil, is_loss_reason_enabled: nil, is_technical_account: nil, is_unsorted_on: nil, mobile_feature_version: nil, name: nil, subdomain: nil, updated_at: nil, updated_by: nil, uuid: nil, version: nil); end
        end

        module CustomersMode
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::Variants
              ])
            end
            def variants; end
          end

          DISABLED = T.let(
              :disabled,
              Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::TaggedSymbol
            )

          DYNAMIC = T.let(
              :dynamic,
              Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          PERIODICITY = T.let(
              :periodicity,
              Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::TaggedSymbol
            )

          SEGMENTS = T.let(
              :segments,
              Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode
              )
            end

          UNAVAILABLE = T.let(
              :unavailable,
              Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::TaggedSymbol
            )

          Variants = T.type_alias do
              T.any(
                Amocrm::Models::AccountGetResponse::AccountInfo::CustomersMode::TaggedSymbol,
                String
              )
            end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::AmojoRights
              ))
          end
          attr_reader :amojo_rights

          sig do
            params(
              amojo_rights: Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::AmojoRights::OrHash
            ).void
          end
          attr_writer :amojo_rights

          sig do
            returns(T.nilable(
                Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::DatetimeSettings
              ))
          end
          attr_reader :datetime_settings

          sig do
            params(
              datetime_settings: Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::DatetimeSettings::OrHash
            ).void
          end
          attr_writer :datetime_settings

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::TaskType
                ]
              ))
          end
          attr_reader :task_types

          sig do
            params(
              task_types: T::Array[
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::TaskType::OrHash
                ]
            ).void
          end
          attr_writer :task_types

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::UsersGroup
                ]
              ))
          end
          attr_reader :users_groups

          sig do
            params(
              users_groups: T::Array[
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::UsersGroup::OrHash
                ]
            ).void
          end
          attr_writer :users_groups

          sig do
            override
              .returns({
                amojo_rights:
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::AmojoRights,
                datetime_settings:
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::DatetimeSettings,
                task_types:
                  T::Array[
                    Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::TaskType
                  ],
                users_groups:
                  T::Array[
                    Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::UsersGroup
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                amojo_rights: Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::AmojoRights::OrHash,
                datetime_settings: Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::DatetimeSettings::OrHash,
                task_types: T::Array[
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::TaskType::OrHash
                ],
                users_groups: T::Array[
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::UsersGroup::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(amojo_rights: nil, datetime_settings: nil, task_types: nil, users_groups: nil); end
          end

          class AmojoRights < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_create_groups

            sig { params(can_create_groups: T::Boolean).void }
            attr_writer :can_create_groups

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_direct

            sig { params(can_direct: T::Boolean).void }
            attr_writer :can_direct

            sig { override.returns({ can_create_groups: T::Boolean, can_direct: T::Boolean }) }
            def to_hash; end

            class << self
              sig { params(can_create_groups: T::Boolean, can_direct: T::Boolean).returns(T.attached_class) }
              def new(can_create_groups: nil, can_direct: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::AmojoRights,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class DatetimeSettings < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :date_format

            sig { params(date_format: String).void }
            attr_writer :date_format

            sig { returns(T.nilable(String)) }
            attr_reader :date_pattern

            sig { params(date_pattern: String).void }
            attr_writer :date_pattern

            sig { returns(T.nilable(String)) }
            attr_reader :short_date_pattern

            sig { params(short_date_pattern: String).void }
            attr_writer :short_date_pattern

            sig { returns(T.nilable(String)) }
            attr_reader :short_time_pattern

            sig { params(short_time_pattern: String).void }
            attr_writer :short_time_pattern

            sig { returns(T.nilable(String)) }
            attr_reader :time_format

            sig { params(time_format: String).void }
            attr_writer :time_format

            sig { returns(T.nilable(String)) }
            attr_reader :timezone

            sig { params(timezone: String).void }
            attr_writer :timezone

            sig { returns(T.nilable(String)) }
            attr_reader :timezone_offset

            sig { params(timezone_offset: String).void }
            attr_writer :timezone_offset

            sig do
              override
                .returns({
                  date_format: String,
                  date_pattern: String,
                  short_date_pattern: String,
                  short_time_pattern: String,
                  time_format: String,
                  timezone: String,
                  timezone_offset: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  date_format: String,
                  date_pattern: String,
                  short_date_pattern: String,
                  short_time_pattern: String,
                  time_format: String,
                  timezone: String,
                  timezone_offset: String
                ).returns(T.attached_class)
              end
              def new(date_format: nil, date_pattern: nil, short_date_pattern: nil, short_time_pattern: nil, time_format: nil, timezone: nil, timezone_offset: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::DatetimeSettings,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::AccountGetResponse::AccountInfo::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class TaskType < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :code

            sig { params(code: String).void }
            attr_writer :code

            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :icon_id

            sig { params(icon_id: Integer).void }
            attr_writer :icon_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              override
                .returns({
                  id: Integer,
                  code: String,
                  color: String,
                  icon_id: Integer,
                  name: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  code: String,
                  color: String,
                  icon_id: Integer,
                  name: String
                ).returns(T.attached_class)
              end
              def new(id: nil, code: nil, color: nil, icon_id: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::TaskType,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class UsersGroup < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :uuid

            sig { params(uuid: String).void }
            attr_writer :uuid

            sig { override.returns({ id: Integer, name: String, uuid: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String, uuid: String).returns(T.attached_class) }
              def new(id: nil, name: nil, uuid: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::AccountGetResponse::AccountInfo::Embedded::UsersGroup,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        class InvoicesSettings < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(Integer)) }
          attr_reader :invoices_catalog_id

          sig { params(invoices_catalog_id: Integer).void }
          attr_writer :invoices_catalog_id

          sig { returns(T.nilable(String)) }
          attr_reader :lang

          sig { params(lang: String).void }
          attr_writer :lang

          sig { override.returns({ invoices_catalog_id: Integer, lang: String }) }
          def to_hash; end

          class << self
            sig { params(invoices_catalog_id: Integer, lang: String).returns(T.attached_class) }
            def new(invoices_catalog_id: nil, lang: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::AccountGetResponse::AccountInfo::InvoicesSettings,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::AccountGetResponse::AccountInfo,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::AccountGetResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::AccountGetResponse::AccountInfo,
            Amocrm::Models::AccountGetResponse::Problem
          )
        end
    end

    class CallCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CallCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CallCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CallCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::CallCreateParams::Body::CallResponsible::Variants)) }
        attr_accessor :call_responsible

        sig { returns(T.nilable(String)) }
        attr_reader :call_result

        sig { params(call_result: String).void }
        attr_writer :call_result

        sig { returns(T.nilable(Integer)) }
        attr_reader :call_status

        sig { params(call_status: Integer).void }
        attr_writer :call_status

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.any(Amocrm::CallCreateParams::Body::Direction::OrSymbol, String)) }
        attr_accessor :direction

        sig { returns(Integer) }
        attr_accessor :duration

        sig { returns(T.nilable(String)) }
        attr_reader :link

        sig { params(link: String).void }
        attr_writer :link

        sig { returns(String) }
        attr_accessor :phone

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(String) }
        attr_accessor :source

        sig { returns(T.nilable(String)) }
        attr_reader :uniq

        sig { params(uniq: String).void }
        attr_writer :uniq

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              direction:
                T.any(
                  Amocrm::CallCreateParams::Body::Direction::OrSymbol,
                  String
                ),
              duration: Integer,
              phone: String,
              source: String,
              call_responsible:
                T.nilable(
                  Amocrm::CallCreateParams::Body::CallResponsible::Variants
                ),
              call_result: String,
              call_status: Integer,
              created_at: Integer,
              created_by: Integer,
              link: String,
              request_id: String,
              responsible_user_id: Integer,
              uniq: String,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              direction: T.any(
                Amocrm::CallCreateParams::Body::Direction::OrSymbol,
                String
              ),
              duration: Integer,
              phone: String,
              source: String,
              call_responsible: T.nilable(
                Amocrm::CallCreateParams::Body::CallResponsible::Variants
              ),
              call_result: String,
              call_status: Integer,
              created_at: Integer,
              created_by: Integer,
              link: String,
              request_id: String,
              responsible_user_id: Integer,
              uniq: String,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(direction:, duration:, phone:, source:, call_responsible: nil, call_result: nil, call_status: nil, created_at: nil, created_by: nil, link: nil, request_id: nil, responsible_user_id: nil, uniq: nil, updated_at: nil, updated_by: nil); end
        end

        module CallResponsible
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::CallCreateParams::Body::CallResponsible::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias { T.any(String, Integer) }
        end

        module Direction
          extend Amocrm::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Amocrm::CallCreateParams::Body::Direction::Variants]) }
            def variants; end
          end

          INBOUND = T.let(
              :inbound,
              Amocrm::CallCreateParams::Body::Direction::TaggedSymbol
            )

          OUTBOUND = T.let(
              :outbound,
              Amocrm::CallCreateParams::Body::Direction::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Amocrm::CallCreateParams::Body::Direction)
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::CallCreateParams::Body::Direction::TaggedSymbol,
                String
              )
            end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::CallCreateParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CallCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CallCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CallCreateResponse::Variants]) }
        def variants; end
      end

      class CallCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig { returns(T.nilable(T::Array[T.anything])) }
        attr_reader :errors

        sig { params(errors: T::Array[T.anything]).void }
        attr_writer :errors

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded,
              _total_items: Integer,
              errors: T::Array[T.anything]
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::OrHash,
              _total_items: Integer,
              errors: T::Array[T.anything]
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _total_items: nil, errors: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call
                ]
              ))
          end
          attr_reader :calls

          sig do
            params(
              calls: T::Array[
                  Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::OrHash
                ]
            ).void
          end
          attr_writer :calls

          sig do
            override
              .returns({
                calls:
                  T::Array[
                    Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                calls: T::Array[
                  Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(calls: nil); end
          end

          class Call < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::EntityType::Variants
                ))
            end
            attr_reader :entity_type

            sig do
              params(
                entity_type: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::EntityType::Variants
              ).void
            end
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded,
                  account_id: Integer,
                  entity_id: Integer,
                  entity_type:
                    Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::EntityType::Variants,
                  request_id: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded::OrHash,
                  account_id: Integer,
                  entity_id: Integer,
                  entity_type: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::EntityType::Variants,
                  request_id: String
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, account_id: nil, entity_id: nil, entity_type: nil, request_id: nil); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded::Entity
                  ))
              end
              attr_reader :entity

              sig do
                params(
                  entity: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded::Entity::OrHash
                ).void
              end
              attr_writer :entity

              sig do
                override
                  .returns({
                    entity:
                      Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded::Entity
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    entity: Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded::Entity::OrHash
                  ).returns(T.attached_class)
                end
                def new(entity: nil); end
              end

              class Entity < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded::Entity,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end
            end

            module EntityType
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call::EntityType::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded::Call,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CallCreateResponse::CallCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CallCreateResponse::CallCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CallCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CallCreateResponse::CallCreateResponse,
            Amocrm::Models::CallCreateResponse::Problem
          )
        end
    end

    class CatalogCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CatalogCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CatalogCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CatalogCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_add_elements

        sig { params(can_add_elements: T::Boolean).void }
        attr_writer :can_add_elements

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_link_multiple

        sig { params(can_link_multiple: T::Boolean).void }
        attr_writer :can_link_multiple

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          returns(T.nilable(
              T.any(Amocrm::CatalogCreateParams::Body::Type::OrSymbol, String)
            ))
        end
        attr_reader :type

        sig { params(type: T.any(Amocrm::CatalogCreateParams::Body::Type::OrSymbol, String)).void }
        attr_writer :type

        sig do
          override
            .returns({
              name: String,
              can_add_elements: T::Boolean,
              can_link_multiple: T::Boolean,
              request_id: String,
              sort: Integer,
              type:
                T.any(Amocrm::CatalogCreateParams::Body::Type::OrSymbol, String)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              can_add_elements: T::Boolean,
              can_link_multiple: T::Boolean,
              request_id: String,
              sort: Integer,
              type: T.any(Amocrm::CatalogCreateParams::Body::Type::OrSymbol, String)
            ).returns(T.attached_class)
          end
          def new(name:, can_add_elements: nil, can_link_multiple: nil, request_id: nil, sort: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::CatalogCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        module Type
          extend Amocrm::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Amocrm::CatalogCreateParams::Body::Type::Variants]) }
            def variants; end
          end

          INVOICES = T.let(
              :invoices,
              Amocrm::CatalogCreateParams::Body::Type::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          PRODUCTS = T.let(
              :products,
              Amocrm::CatalogCreateParams::Body::Type::TaggedSymbol
            )

          REGULAR = T.let(
              :regular,
              Amocrm::CatalogCreateParams::Body::Type::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Amocrm::CatalogCreateParams::Body::Type)
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::CatalogCreateParams::Body::Type::TaggedSymbol,
                String
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogCreateResponse::Variants]) }
        def variants; end
      end

      class CatalogCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog
                ]
              ))
          end
          attr_reader :catalogs

          sig do
            params(
              catalogs: T::Array[
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::OrHash
                ]
            ).void
          end
          attr_writer :catalogs

          sig do
            override
              .returns({
                catalogs:
                  T::Array[
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalogs: T::Array[
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalogs: nil); end
          end

          class Catalog < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_add_elements

            sig { params(can_add_elements: T::Boolean).void }
            attr_writer :can_add_elements

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_be_deleted

            sig { params(can_be_deleted: T::Boolean).void }
            attr_writer :can_be_deleted

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_link_multiple

            sig { params(can_link_multiple: T::Boolean).void }
            attr_writer :can_link_multiple

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_show_in_cards

            sig { params(can_show_in_cards: T::Boolean).void }
            attr_writer :can_show_in_cards

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                ))
            end
            attr_accessor :sdk_widget_code

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::Variants
                ))
            end
            attr_reader :type

            sig do
              params(
                type: T.any(
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :type

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  request_id: String,
                  sdk_widget_code:
                    T.nilable(
                      Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                    ),
                  sort: Integer,
                  type:
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::Variants,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  request_id: String,
                  sdk_widget_code: T.nilable(
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ),
                  sort: Integer,
                  type: T.any(
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  ),
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, account_id: nil, can_add_elements: nil, can_be_deleted: nil, can_link_multiple: nil, can_show_in_cards: nil, created_at: nil, created_by: nil, name: nil, request_id: nil, sdk_widget_code: nil, sort: nil, type: nil, updated_at: nil, updated_by: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog,
                  Amocrm::Internal::AnyHash
                )
              end

            module SDKWidgetCode
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            module Type
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::Variants
                  ])
                end
                def variants; end
              end

              INVOICES = T.let(
                  :invoices,
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              PRODUCTS = T.let(
                  :products,
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              REGULAR = T.let(
                  :regular,
                  Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded::Catalog::Type::TaggedSymbol,
                    String
                  )
                end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogCreateResponse::CatalogCreateResponse,
            Amocrm::Models::CatalogCreateResponse::Problem
          )
        end
    end

    class CatalogElementCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CatalogElementCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CatalogElementCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CatalogElementCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue
              ]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig do
          override
            .returns({
              name: String,
              custom_fields_values:
                T::Array[
                  Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue
                ],
              request_id: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              custom_fields_values: T::Array[
                Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue::OrHash
              ],
              request_id: String
            ).returns(T.attached_class)
          end
          def new(name:, custom_fields_values: nil, request_id: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          sig { returns(T.nilable(String)) }
          attr_reader :field_name

          sig { params(field_name: String).void }
          attr_writer :field_name

          sig { returns(T.nilable(String)) }
          attr_reader :field_type

          sig { params(field_type: String).void }
          attr_writer :field_type

          sig do
            returns(T::Array[
                Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer,
                field_name: String,
                field_type: String
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer,
                field_name: String,
                field_type: String
              ).returns(T.attached_class)
            end
            def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(T.anything) }
            attr_accessor :value

            sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
            def to_hash; end

            class << self
              sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
              def new(value:, enum_code: nil, enum_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CatalogElementCreateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CatalogElementCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogElementCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogElementCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogElementCreateResponse::Variants]) }
        def variants; end
      end

      class CatalogElementCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element
                ]
              ))
          end
          attr_reader :elements

          sig do
            params(
              elements: T::Array[
                  Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::OrHash
                ]
            ).void
          end
          attr_writer :elements

          sig do
            override
              .returns({
                elements:
                  T::Array[
                    Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                elements: T::Array[
                  Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(elements: nil); end
          end

          class Element < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :catalog_id

            sig { params(catalog_id: Integer).void }
            attr_writer :catalog_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_accessor :invoice_link

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_deleted

            sig { params(is_deleted: T::Boolean).void }
            attr_writer :is_deleted

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue
                      ]
                    ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  request_id: String,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue::OrHash
                    ]
                  ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  request_id: String,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, catalog_id: nil, created_at: nil, created_by: nil, custom_fields_values: nil, invoice_link: nil, is_deleted: nil, name: nil, request_id: nil, updated_at: nil, updated_by: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              sig { returns(T.nilable(String)) }
              attr_reader :field_name

              sig { params(field_name: String).void }
              attr_writer :field_name

              sig { returns(T.nilable(String)) }
              attr_reader :field_type

              sig { params(field_type: String).void }
              attr_writer :field_type

              sig do
                returns(T::Array[
                    Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  ).returns(T.attached_class)
                end
                def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig { returns(T.anything) }
                attr_accessor :value

                sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
                  def new(value:, enum_code: nil, enum_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded::Warning
                  ))
              end
              attr_reader :warning

              sig do
                params(
                  warning: T.nilable(
                      Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                ).void
              end
              attr_writer :warning

              sig do
                override
                  .returns({
                    warning:
                      T.nilable(
                        Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded::Warning
                      )
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    warning: T.nilable(
                      Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                  ).returns(T.attached_class)
                end
                def new(warning: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Warning < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_accessor :message

                sig { override.returns({ message: T.nilable(String) }) }
                def to_hash; end

                class << self
                  sig { params(message: T.nilable(String)).returns(T.attached_class) }
                  def new(message: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element::Embedded::Warning,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded::Element,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogElementCreateResponse::CatalogElementCreateResponse,
            Amocrm::Models::CatalogElementCreateResponse::Problem
          )
        end
    end

    class CatalogElementGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :catalog_id

      # Additional data to include (comma-separated).
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            catalog_id: Integer,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            catalog_id: Integer,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          catalog_id:,
          with: nil, # Additional data to include (comma-separated).
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogElementGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogElementGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogElementGetByIDResponse::Variants]) }
        def variants; end
      end

      class CatalogElement < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :catalog_id

        sig { params(catalog_id: Integer).void }
        attr_writer :catalog_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue
              ]
            ))
        end
        attr_accessor :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_accessor :invoice_link

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_deleted

        sig { params(is_deleted: T::Boolean).void }
        attr_writer :is_deleted

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _embedded:
                Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded,
              _links: T.anything,
              account_id: Integer,
              catalog_id: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T.nilable(
                  T::Array[
                    Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue
                  ]
                ),
              invoice_link: T.nilable(String),
              is_deleted: T::Boolean,
              name: String,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded::OrHash,
              _links: T.anything,
              account_id: Integer,
              catalog_id: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T.nilable(
                T::Array[
                  Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue::OrHash
                ]
              ),
              invoice_link: T.nilable(String),
              is_deleted: T::Boolean,
              name: String,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, account_id: nil, catalog_id: nil, created_at: nil, created_by: nil, custom_fields_values: nil, invoice_link: nil, is_deleted: nil, name: nil, updated_at: nil, updated_by: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          sig { returns(T.nilable(String)) }
          attr_reader :field_name

          sig { params(field_name: String).void }
          attr_writer :field_name

          sig { returns(T.nilable(String)) }
          attr_reader :field_type

          sig { params(field_type: String).void }
          attr_writer :field_type

          sig do
            returns(T::Array[
                Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer,
                field_name: String,
                field_type: String
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer,
                field_name: String,
                field_type: String
              ).returns(T.attached_class)
            end
            def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(T.anything) }
            attr_accessor :value

            sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
            def to_hash; end

            class << self
              sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
              def new(value:, enum_code: nil, enum_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded::Warning
              ))
          end
          attr_reader :warning

          sig do
            params(
              warning: T.nilable(
                  Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded::Warning::OrHash
                )
            ).void
          end
          attr_writer :warning

          sig do
            override
              .returns({
                warning:
                  T.nilable(
                    Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded::Warning
                  )
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                warning: T.nilable(
                  Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded::Warning::OrHash
                )
              ).returns(T.attached_class)
            end
            def new(warning: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Warning < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_accessor :message

            sig { override.returns({ message: T.nilable(String) }) }
            def to_hash; end

            class << self
              sig { params(message: T.nilable(String)).returns(T.attached_class) }
              def new(message: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement::Embedded::Warning,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogElementGetByIDResponse::CatalogElement,
            Amocrm::Models::CatalogElementGetByIDResponse::Problem
          )
        end
    end

    class CatalogElementListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig { returns(T.nilable(Amocrm::CatalogElementListParams::Query::Variants)) }
      attr_reader :query

      sig { params(query: Amocrm::CatalogElementListParams::Query::Variants).void }
      attr_writer :query

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            page: Integer,
            query: Amocrm::CatalogElementListParams::Query::Variants,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            page: Integer,
            query: Amocrm::CatalogElementListParams::Query::Variants,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, limit: nil, page: nil, query: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogElementListParams, Amocrm::Internal::AnyHash)
        end

      module Query
        extend Amocrm::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Amocrm::CatalogElementListParams::Query::Variants]) }
          def variants; end
        end

        Variants = T.type_alias { T.any(String, Integer) }
      end
    end

    module CatalogElementListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogElementListResponse::Variants]) }
        def variants; end
      end

      class CatalogElementListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element
                ]
              ))
          end
          attr_reader :elements

          sig do
            params(
              elements: T::Array[
                  Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::OrHash
                ]
            ).void
          end
          attr_writer :elements

          sig do
            override
              .returns({
                elements:
                  T::Array[
                    Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                elements: T::Array[
                  Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(elements: nil); end
          end

          class Element < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :catalog_id

            sig { params(catalog_id: Integer).void }
            attr_writer :catalog_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_accessor :invoice_link

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_deleted

            sig { params(is_deleted: T::Boolean).void }
            attr_writer :is_deleted

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue
                      ]
                    ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue::OrHash
                    ]
                  ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, catalog_id: nil, created_at: nil, created_by: nil, custom_fields_values: nil, invoice_link: nil, is_deleted: nil, name: nil, updated_at: nil, updated_by: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              sig { returns(T.nilable(String)) }
              attr_reader :field_name

              sig { params(field_name: String).void }
              attr_writer :field_name

              sig { returns(T.nilable(String)) }
              attr_reader :field_type

              sig { params(field_type: String).void }
              attr_writer :field_type

              sig do
                returns(T::Array[
                    Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  ).returns(T.attached_class)
                end
                def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig { returns(T.anything) }
                attr_accessor :value

                sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
                  def new(value:, enum_code: nil, enum_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded::Warning
                  ))
              end
              attr_reader :warning

              sig do
                params(
                  warning: T.nilable(
                      Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                ).void
              end
              attr_writer :warning

              sig do
                override
                  .returns({
                    warning:
                      T.nilable(
                        Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded::Warning
                      )
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    warning: T.nilable(
                      Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                  ).returns(T.attached_class)
                end
                def new(warning: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Warning < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_accessor :message

                sig { override.returns({ message: T.nilable(String) }) }
                def to_hash; end

                class << self
                  sig { params(message: T.nilable(String)).returns(T.attached_class) }
                  def new(message: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element::Embedded::Warning,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded::Element,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogElementListResponse::CatalogElementListResponse,
            Amocrm::Models::CatalogElementListResponse::Problem
          )
        end
    end

    class CatalogElementUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :catalog_id

      sig do
        returns(T.nilable(
            T::Array[Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue]
          ))
      end
      attr_reader :custom_fields_values

      sig do
        params(
          custom_fields_values: T::Array[
              Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue::OrHash
            ]
        ).void
      end
      attr_writer :custom_fields_values

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(String)) }
      attr_reader :request_id

      sig { params(request_id: String).void }
      attr_writer :request_id

      sig do
        override
          .returns({
            catalog_id: Integer,
            custom_fields_values:
              T::Array[
                Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue
              ],
            name: String,
            request_id: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            catalog_id: Integer,
            custom_fields_values: T::Array[
              Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue::OrHash
            ],
            name: String,
            request_id: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(catalog_id:, custom_fields_values: nil, name: nil, request_id: nil, request_options: {}); end
      end

      class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :field_code

        sig { params(field_code: String).void }
        attr_writer :field_code

        sig { returns(T.nilable(Integer)) }
        attr_reader :field_id

        sig { params(field_id: Integer).void }
        attr_writer :field_id

        sig { returns(T.nilable(String)) }
        attr_reader :field_name

        sig { params(field_name: String).void }
        attr_writer :field_name

        sig { returns(T.nilable(String)) }
        attr_reader :field_type

        sig { params(field_type: String).void }
        attr_writer :field_type

        sig do
          returns(T::Array[
              Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue::Value
            ])
        end
        attr_accessor :values

        sig do
          override
            .returns({
              values:
                T::Array[
                  Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue::Value
                ],
              field_code: String,
              field_id: Integer,
              field_name: String,
              field_type: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              values: T::Array[
                Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue::Value::OrHash
              ],
              field_code: String,
              field_id: Integer,
              field_name: String,
              field_type: String
            ).returns(T.attached_class)
          end
          def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue,
              Amocrm::Internal::AnyHash
            )
          end

        class Value < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :enum_code

          sig { params(enum_code: String).void }
          attr_writer :enum_code

          sig { returns(T.nilable(Integer)) }
          attr_reader :enum_id

          sig { params(enum_id: Integer).void }
          attr_writer :enum_id

          sig { returns(T.anything) }
          attr_accessor :value

          sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
          def to_hash; end

          class << self
            sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
            def new(value:, enum_code: nil, enum_id: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue::Value,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CatalogElementUpdateByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CatalogElementUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogElementUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class CatalogElementUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element
                ]
              ))
          end
          attr_reader :elements

          sig do
            params(
              elements: T::Array[
                  Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::OrHash
                ]
            ).void
          end
          attr_writer :elements

          sig do
            override
              .returns({
                elements:
                  T::Array[
                    Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                elements: T::Array[
                  Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(elements: nil); end
          end

          class Element < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :catalog_id

            sig { params(catalog_id: Integer).void }
            attr_writer :catalog_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_accessor :invoice_link

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_deleted

            sig { params(is_deleted: T::Boolean).void }
            attr_writer :is_deleted

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue
                      ]
                    ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  request_id: String,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::OrHash
                    ]
                  ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  request_id: String,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, catalog_id: nil, created_at: nil, created_by: nil, custom_fields_values: nil, invoice_link: nil, is_deleted: nil, name: nil, request_id: nil, updated_at: nil, updated_by: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              sig { returns(T.nilable(String)) }
              attr_reader :field_name

              sig { params(field_name: String).void }
              attr_writer :field_name

              sig { returns(T.nilable(String)) }
              attr_reader :field_type

              sig { params(field_type: String).void }
              attr_writer :field_type

              sig do
                returns(T::Array[
                    Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  ).returns(T.attached_class)
                end
                def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig { returns(T.anything) }
                attr_accessor :value

                sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
                  def new(value:, enum_code: nil, enum_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning
                  ))
              end
              attr_reader :warning

              sig do
                params(
                  warning: T.nilable(
                      Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                ).void
              end
              attr_writer :warning

              sig do
                override
                  .returns({
                    warning:
                      T.nilable(
                        Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning
                      )
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    warning: T.nilable(
                      Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                  ).returns(T.attached_class)
                end
                def new(warning: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Warning < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_accessor :message

                sig { override.returns({ message: T.nilable(String) }) }
                def to_hash; end

                class << self
                  sig { params(message: T.nilable(String)).returns(T.attached_class) }
                  def new(message: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded::Element,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogElementUpdateByIDResponse::CatalogElementUpdateResponse,
            Amocrm::Models::CatalogElementUpdateByIDResponse::Problem
          )
        end
    end

    class CatalogElementUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CatalogElementUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CatalogElementUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CatalogElementUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue
              ]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig do
          override
            .returns({
              id: Integer,
              custom_fields_values:
                T::Array[
                  Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue
                ],
              name: String,
              request_id: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              custom_fields_values: T::Array[
                Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue::OrHash
              ],
              name: String,
              request_id: String
            ).returns(T.attached_class)
          end
          def new(id:, custom_fields_values: nil, name: nil, request_id: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          sig { returns(T.nilable(String)) }
          attr_reader :field_name

          sig { params(field_name: String).void }
          attr_writer :field_name

          sig { returns(T.nilable(String)) }
          attr_reader :field_type

          sig { params(field_type: String).void }
          attr_writer :field_type

          sig do
            returns(T::Array[
                Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer,
                field_name: String,
                field_type: String
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer,
                field_name: String,
                field_type: String
              ).returns(T.attached_class)
            end
            def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(T.anything) }
            attr_accessor :value

            sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
            def to_hash; end

            class << self
              sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
              def new(value:, enum_code: nil, enum_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CatalogElementUpdateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CatalogElementUpdateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogElementUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogElementUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogElementUpdateResponse::Variants]) }
        def variants; end
      end

      class CatalogElementUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element
                ]
              ))
          end
          attr_reader :elements

          sig do
            params(
              elements: T::Array[
                  Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::OrHash
                ]
            ).void
          end
          attr_writer :elements

          sig do
            override
              .returns({
                elements:
                  T::Array[
                    Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                elements: T::Array[
                  Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(elements: nil); end
          end

          class Element < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :catalog_id

            sig { params(catalog_id: Integer).void }
            attr_writer :catalog_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_accessor :invoice_link

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_deleted

            sig { params(is_deleted: T::Boolean).void }
            attr_writer :is_deleted

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue
                      ]
                    ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  request_id: String,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  catalog_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::OrHash
                    ]
                  ),
                  invoice_link: T.nilable(String),
                  is_deleted: T::Boolean,
                  name: String,
                  request_id: String,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, catalog_id: nil, created_at: nil, created_by: nil, custom_fields_values: nil, invoice_link: nil, is_deleted: nil, name: nil, request_id: nil, updated_at: nil, updated_by: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              sig { returns(T.nilable(String)) }
              attr_reader :field_name

              sig { params(field_name: String).void }
              attr_writer :field_name

              sig { returns(T.nilable(String)) }
              attr_reader :field_type

              sig { params(field_type: String).void }
              attr_writer :field_type

              sig do
                returns(T::Array[
                    Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer,
                    field_name: String,
                    field_type: String
                  ).returns(T.attached_class)
                end
                def new(values:, field_code: nil, field_id: nil, field_name: nil, field_type: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig { returns(T.anything) }
                attr_accessor :value

                sig { override.returns({ value: T.anything, enum_code: String, enum_id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(value: T.anything, enum_code: String, enum_id: Integer).returns(T.attached_class) }
                  def new(value:, enum_code: nil, enum_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning
                  ))
              end
              attr_reader :warning

              sig do
                params(
                  warning: T.nilable(
                      Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                ).void
              end
              attr_writer :warning

              sig do
                override
                  .returns({
                    warning:
                      T.nilable(
                        Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning
                      )
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    warning: T.nilable(
                      Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning::OrHash
                    )
                  ).returns(T.attached_class)
                end
                def new(warning: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Warning < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_accessor :message

                sig { override.returns({ message: T.nilable(String) }) }
                def to_hash; end

                class << self
                  sig { params(message: T.nilable(String)).returns(T.attached_class) }
                  def new(message: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element::Embedded::Warning,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded::Element,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogElementUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogElementUpdateResponse::CatalogElementUpdateResponse,
            Amocrm::Models::CatalogElementUpdateResponse::Problem
          )
        end
    end

    class CatalogGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogGetByIDResponse::Variants]) }
        def variants; end
      end

      class Catalog < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_add_elements

        sig { params(can_add_elements: T::Boolean).void }
        attr_writer :can_add_elements

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_be_deleted

        sig { params(can_be_deleted: T::Boolean).void }
        attr_writer :can_be_deleted

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_link_multiple

        sig { params(can_link_multiple: T::Boolean).void }
        attr_writer :can_link_multiple

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_show_in_cards

        sig { params(can_show_in_cards: T::Boolean).void }
        attr_writer :can_show_in_cards

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogGetByIDResponse::Catalog::SDKWidgetCode::Variants
            ))
        end
        attr_accessor :sdk_widget_code

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::Variants
            ))
        end
        attr_reader :type

        sig do
          params(
            type: T.any(
                Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :type

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              can_add_elements: T::Boolean,
              can_be_deleted: T::Boolean,
              can_link_multiple: T::Boolean,
              can_show_in_cards: T::Boolean,
              created_at: Integer,
              created_by: Integer,
              name: String,
              sdk_widget_code:
                T.nilable(
                  Amocrm::Models::CatalogGetByIDResponse::Catalog::SDKWidgetCode::Variants
                ),
              sort: Integer,
              type:
                Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::Variants,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              can_add_elements: T::Boolean,
              can_be_deleted: T::Boolean,
              can_link_multiple: T::Boolean,
              can_show_in_cards: T::Boolean,
              created_at: Integer,
              created_by: Integer,
              name: String,
              sdk_widget_code: T.nilable(
                Amocrm::Models::CatalogGetByIDResponse::Catalog::SDKWidgetCode::Variants
              ),
              sort: Integer,
              type: T.any(
                Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::OrSymbol,
                String
              ),
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, account_id: nil, can_add_elements: nil, can_be_deleted: nil, can_link_multiple: nil, can_show_in_cards: nil, created_at: nil, created_by: nil, name: nil, sdk_widget_code: nil, sort: nil, type: nil, updated_at: nil, updated_by: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogGetByIDResponse::Catalog,
              Amocrm::Internal::AnyHash
            )
          end

        module SDKWidgetCode
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::CatalogGetByIDResponse::Catalog::SDKWidgetCode::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias { T.any(String, Integer) }
        end

        module Type
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::Variants
              ])
            end
            def variants; end
          end

          INVOICES = T.let(
              :invoices,
              Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          PRODUCTS = T.let(
              :products,
              Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::TaggedSymbol
            )

          REGULAR = T.let(
              :regular,
              Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::Models::CatalogGetByIDResponse::Catalog::Type
              )
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::Models::CatalogGetByIDResponse::Catalog::Type::TaggedSymbol,
                String
              )
            end
        end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogGetByIDResponse::Catalog,
            Amocrm::Models::CatalogGetByIDResponse::Problem
          )
        end
    end

    class CatalogListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(limit: nil, page: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogListParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogListResponse::Variants]) }
        def variants; end
      end

      class CatalogListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog
                ]
              ))
          end
          attr_reader :catalogs

          sig do
            params(
              catalogs: T::Array[
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::OrHash
                ]
            ).void
          end
          attr_writer :catalogs

          sig do
            override
              .returns({
                catalogs:
                  T::Array[
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalogs: T::Array[
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalogs: nil); end
          end

          class Catalog < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_add_elements

            sig { params(can_add_elements: T::Boolean).void }
            attr_writer :can_add_elements

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_be_deleted

            sig { params(can_be_deleted: T::Boolean).void }
            attr_writer :can_be_deleted

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_link_multiple

            sig { params(can_link_multiple: T::Boolean).void }
            attr_writer :can_link_multiple

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_show_in_cards

            sig { params(can_show_in_cards: T::Boolean).void }
            attr_writer :can_show_in_cards

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::SDKWidgetCode::Variants
                ))
            end
            attr_accessor :sdk_widget_code

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::Variants
                ))
            end
            attr_reader :type

            sig do
              params(
                type: T.any(
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :type

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  sdk_widget_code:
                    T.nilable(
                      Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::SDKWidgetCode::Variants
                    ),
                  sort: Integer,
                  type:
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::Variants,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  sdk_widget_code: T.nilable(
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ),
                  sort: Integer,
                  type: T.any(
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  ),
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, account_id: nil, can_add_elements: nil, can_be_deleted: nil, can_link_multiple: nil, can_show_in_cards: nil, created_at: nil, created_by: nil, name: nil, sdk_widget_code: nil, sort: nil, type: nil, updated_at: nil, updated_by: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog,
                  Amocrm::Internal::AnyHash
                )
              end

            module SDKWidgetCode
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            module Type
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::Variants
                  ])
                end
                def variants; end
              end

              INVOICES = T.let(
                  :invoices,
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              PRODUCTS = T.let(
                  :products,
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              REGULAR = T.let(
                  :regular,
                  Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded::Catalog::Type::TaggedSymbol,
                    String
                  )
                end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogListResponse::CatalogListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogListResponse::CatalogListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogListResponse::CatalogListResponse,
            Amocrm::Models::CatalogListResponse::Problem
          )
        end
    end

    class CatalogUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :can_add_elements

      sig { params(can_add_elements: T::Boolean).void }
      attr_writer :can_add_elements

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :can_link_multiple

      sig { params(can_link_multiple: T::Boolean).void }
      attr_writer :can_link_multiple

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(String)) }
      attr_reader :request_id

      sig { params(request_id: String).void }
      attr_writer :request_id

      sig { returns(T.nilable(Integer)) }
      attr_reader :sort

      sig { params(sort: Integer).void }
      attr_writer :sort

      sig do
        override
          .returns({
            can_add_elements: T::Boolean,
            can_link_multiple: T::Boolean,
            name: String,
            request_id: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            can_add_elements: T::Boolean,
            can_link_multiple: T::Boolean,
            name: String,
            request_id: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(can_add_elements: nil, can_link_multiple: nil, name: nil, request_id: nil, sort: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogUpdateByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class CatalogUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog
                ]
              ))
          end
          attr_reader :catalogs

          sig do
            params(
              catalogs: T::Array[
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::OrHash
                ]
            ).void
          end
          attr_writer :catalogs

          sig do
            override
              .returns({
                catalogs:
                  T::Array[
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalogs: T::Array[
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalogs: nil); end
          end

          class Catalog < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_add_elements

            sig { params(can_add_elements: T::Boolean).void }
            attr_writer :can_add_elements

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_be_deleted

            sig { params(can_be_deleted: T::Boolean).void }
            attr_writer :can_be_deleted

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_link_multiple

            sig { params(can_link_multiple: T::Boolean).void }
            attr_writer :can_link_multiple

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_show_in_cards

            sig { params(can_show_in_cards: T::Boolean).void }
            attr_writer :can_show_in_cards

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                ))
            end
            attr_accessor :sdk_widget_code

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::Variants
                ))
            end
            attr_reader :type

            sig do
              params(
                type: T.any(
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :type

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  request_id: String,
                  sdk_widget_code:
                    T.nilable(
                      Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                    ),
                  sort: Integer,
                  type:
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::Variants,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  request_id: String,
                  sdk_widget_code: T.nilable(
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ),
                  sort: Integer,
                  type: T.any(
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  ),
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, account_id: nil, can_add_elements: nil, can_be_deleted: nil, can_link_multiple: nil, can_show_in_cards: nil, created_at: nil, created_by: nil, name: nil, request_id: nil, sdk_widget_code: nil, sort: nil, type: nil, updated_at: nil, updated_by: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog,
                  Amocrm::Internal::AnyHash
                )
              end

            module SDKWidgetCode
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            module Type
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::Variants
                  ])
                end
                def variants; end
              end

              INVOICES = T.let(
                  :invoices,
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              PRODUCTS = T.let(
                  :products,
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              REGULAR = T.let(
                  :regular,
                  Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol,
                    String
                  )
                end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogUpdateByIDResponse::CatalogUpdateResponse,
            Amocrm::Models::CatalogUpdateByIDResponse::Problem
          )
        end
    end

    class CatalogUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CatalogUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CatalogUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CatalogUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_add_elements

        sig { params(can_add_elements: T::Boolean).void }
        attr_writer :can_add_elements

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :can_link_multiple

        sig { params(can_link_multiple: T::Boolean).void }
        attr_writer :can_link_multiple

        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          override
            .returns({
              id: Integer,
              can_add_elements: T::Boolean,
              can_link_multiple: T::Boolean,
              name: String,
              request_id: String,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              can_add_elements: T::Boolean,
              can_link_multiple: T::Boolean,
              name: String,
              request_id: String,
              sort: Integer
            ).returns(T.attached_class)
          end
          def new(id:, can_add_elements: nil, can_link_multiple: nil, name: nil, request_id: nil, sort: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::CatalogUpdateParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CatalogUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CatalogUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CatalogUpdateResponse::Variants]) }
        def variants; end
      end

      class CatalogUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog
                ]
              ))
          end
          attr_reader :catalogs

          sig do
            params(
              catalogs: T::Array[
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::OrHash
                ]
            ).void
          end
          attr_writer :catalogs

          sig do
            override
              .returns({
                catalogs:
                  T::Array[
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalogs: T::Array[
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalogs: nil); end
          end

          class Catalog < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_add_elements

            sig { params(can_add_elements: T::Boolean).void }
            attr_writer :can_add_elements

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_be_deleted

            sig { params(can_be_deleted: T::Boolean).void }
            attr_writer :can_be_deleted

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_link_multiple

            sig { params(can_link_multiple: T::Boolean).void }
            attr_writer :can_link_multiple

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :can_show_in_cards

            sig { params(can_show_in_cards: T::Boolean).void }
            attr_writer :can_show_in_cards

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                ))
            end
            attr_accessor :sdk_widget_code

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig do
              returns(T.nilable(
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::Variants
                ))
            end
            attr_reader :type

            sig do
              params(
                type: T.any(
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :type

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  request_id: String,
                  sdk_widget_code:
                    T.nilable(
                      Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                    ),
                  sort: Integer,
                  type:
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::Variants,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  can_add_elements: T::Boolean,
                  can_be_deleted: T::Boolean,
                  can_link_multiple: T::Boolean,
                  can_show_in_cards: T::Boolean,
                  created_at: Integer,
                  created_by: Integer,
                  name: String,
                  request_id: String,
                  sdk_widget_code: T.nilable(
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ),
                  sort: Integer,
                  type: T.any(
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::OrSymbol,
                    String
                  ),
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, account_id: nil, can_add_elements: nil, can_be_deleted: nil, can_link_multiple: nil, can_show_in_cards: nil, created_at: nil, created_by: nil, name: nil, request_id: nil, sdk_widget_code: nil, sort: nil, type: nil, updated_at: nil, updated_by: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog,
                  Amocrm::Internal::AnyHash
                )
              end

            module SDKWidgetCode
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::SDKWidgetCode::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            module Type
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::Variants
                  ])
                end
                def variants; end
              end

              INVOICES = T.let(
                  :invoices,
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              PRODUCTS = T.let(
                  :products,
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              REGULAR = T.let(
                  :regular,
                  Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded::Catalog::Type::TaggedSymbol,
                    String
                  )
                end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CatalogUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CatalogUpdateResponse::CatalogUpdateResponse,
            Amocrm::Models::CatalogUpdateResponse::Problem
          )
        end
    end

    class CompanyCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CompanyCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CompanyCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CompanyCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        # Embedded entities
        sig { returns(T.nilable(Amocrm::CompanyCreateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::CompanyCreateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        # Custom fields payload
        sig do
          returns(T.nilable(
              T::Array[Amocrm::CompanyCreateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::CompanyCreateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        # Tags to attach
        sig { returns(T.nilable(T::Array[Amocrm::CompanyCreateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::CompanyCreateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              _embedded: Amocrm::CompanyCreateParams::Body::Embedded,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T::Array[Amocrm::CompanyCreateParams::Body::CustomFieldsValue],
              name: String,
              request_id: String,
              responsible_user_id: Integer,
              tags_to_add:
                T::Array[Amocrm::CompanyCreateParams::Body::TagsToAdd],
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::CompanyCreateParams::Body::Embedded::OrHash,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T::Array[
                Amocrm::CompanyCreateParams::Body::CustomFieldsValue::OrHash
              ],
              name: String,
              request_id: String,
              responsible_user_id: Integer,
              tags_to_add: T::Array[Amocrm::CompanyCreateParams::Body::TagsToAdd::OrHash],
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            _embedded: nil, # Embedded entities
            created_at: nil,
            created_by: nil,
            custom_fields_values: nil, # Custom fields payload
            name: nil,
            request_id: nil, # Client-side request id
            responsible_user_id: nil,
            tags_to_add: nil, # Tags to attach
            updated_at: nil,
            updated_by: nil
); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyCreateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::CompanyCreateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::CompanyCreateParams::Body::Embedded::Tag]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::CompanyCreateParams::Body::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                tags: T::Array[Amocrm::CompanyCreateParams::Body::Embedded::Tag]
              })
          end
          def to_hash; end

          class << self
            # Embedded entities
            sig do
              params(
                tags: T::Array[
                  Amocrm::CompanyCreateParams::Body::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyCreateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CompanyCreateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::CompanyCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyCreateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CompanyCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CompanyCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CompanyCreateResponse::Variants]) }
        def variants; end
      end

      class CompanyCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded::Company
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                companies: T::Array[
                  Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded::Company::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(companies: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CompanyCreateResponse::CompanyCreateResponse,
            Amocrm::Models::CompanyCreateResponse::Problem
          )
        end
    end

    class CompanyGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CompanyGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CompanyGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CompanyGetByIDResponse::Variants]) }
        def variants; end
      end

      class Company < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::CompanyGetByIDResponse::Company::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :closest_task_at

        sig { params(closest_task_at: Integer).void }
        attr_writer :closest_task_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue
              ]
            ))
        end
        attr_accessor :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _embedded:
                Amocrm::Models::CompanyGetByIDResponse::Company::Embedded,
              _links: T.anything,
              account_id: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T.nilable(
                  T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue
                  ]
                ),
              group_id: Integer,
              name: String,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::OrHash,
              _links: T.anything,
              account_id: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T.nilable(
                T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::OrHash
                ]
              ),
              group_id: Integer,
              name: String,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, account_id: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, group_id: nil, name: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::CatalogElement
                ]
              ))
          end
          attr_reader :catalog_elements

          sig do
            params(
              catalog_elements: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::CatalogElement::OrHash
                ]
            ).void
          end
          attr_writer :catalog_elements

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Customer
                ]
              ))
          end
          attr_reader :customers

          sig do
            params(
              customers: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Customer::OrHash
                ]
            ).void
          end
          attr_writer :customers

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Tag
                ]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                catalog_elements:
                  T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::CatalogElement
                  ],
                contacts:
                  T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Contact
                  ],
                customers:
                  T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Customer
                  ],
                leads:
                  T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Lead
                  ],
                tags:
                  T::Array[
                    Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Tag
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_elements: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::CatalogElement::OrHash
                ],
                contacts: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Contact::OrHash
                ],
                customers: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Customer::OrHash
                ],
                leads: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Lead::OrHash
                ],
                tags: T::Array[
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalog_elements: nil, contacts: nil, customers: nil, leads: nil, tags: nil); end
          end

          class CatalogElement < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::CatalogElement,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Customer < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Customer,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CompanyGetByIDResponse::Company::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyGetByIDResponse::Company::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyGetByIDResponse::Company,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CompanyGetByIDResponse::Company,
            Amocrm::Models::CompanyGetByIDResponse::Problem
          )
        end
    end

    class CompanyListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Filtering parameters
      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      # Pagination limit
      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      # Sorting, e.g. order[updated_at]=asc
      sig { returns(T.nilable(T.anything)) }
      attr_reader :order

      sig { params(order: T.anything).void }
      attr_writer :order

      # Pagination page
      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      # Search by query string or id
      sig { returns(T.nilable(Amocrm::CompanyListParams::Query::Variants)) }
      attr_reader :query

      sig { params(query: Amocrm::CompanyListParams::Query::Variants).void }
      attr_writer :query

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::CompanyListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::CompanyListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          filter: nil, # Filtering parameters
          limit: nil, # Pagination limit
          order: nil, # Sorting, e.g. order[updated_at]=asc
          page: nil, # Pagination page
          query: nil, # Search by query string or id
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CompanyListParams, Amocrm::Internal::AnyHash)
        end

      # Search by query string or id
      module Query
        extend Amocrm::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Amocrm::CompanyListParams::Query::Variants]) }
          def variants; end
        end

        Variants = T.type_alias { T.any(String, Integer) }
      end
    end

    module CompanyListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CompanyListResponse::Variants]) }
        def variants; end
      end

      class CompanyListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                companies: T::Array[
                  Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(companies: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :closest_task_at

            sig { params(closest_task_at: Integer).void }
            attr_writer :closest_task_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue
                      ]
                    ),
                  group_id: Integer,
                  name: String,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::OrHash
                    ]
                  ),
                  group_id: Integer,
                  name: String,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, group_id: nil, name: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::CatalogElement
                    ]
                  ))
              end
              attr_reader :catalog_elements

              sig do
                params(
                  catalog_elements: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::CatalogElement::OrHash
                    ]
                ).void
              end
              attr_writer :catalog_elements

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Contact
                    ]
                  ))
              end
              attr_reader :contacts

              sig do
                params(
                  contacts: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Contact::OrHash
                    ]
                ).void
              end
              attr_writer :contacts

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Customer
                    ]
                  ))
              end
              attr_reader :customers

              sig do
                params(
                  customers: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Customer::OrHash
                    ]
                ).void
              end
              attr_writer :customers

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Lead
                    ]
                  ))
              end
              attr_reader :leads

              sig do
                params(
                  leads: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Lead::OrHash
                    ]
                ).void
              end
              attr_writer :leads

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Tag
                    ]
                  ))
              end
              attr_reader :tags

              sig do
                params(
                  tags: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Tag::OrHash
                    ]
                ).void
              end
              attr_writer :tags

              sig do
                override
                  .returns({
                    catalog_elements:
                      T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::CatalogElement
                      ],
                    contacts:
                      T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Contact
                      ],
                    customers:
                      T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Customer
                      ],
                    leads:
                      T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Lead
                      ],
                    tags:
                      T::Array[
                        Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Tag
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_elements: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::CatalogElement::OrHash
                    ],
                    contacts: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Contact::OrHash
                    ],
                    customers: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Customer::OrHash
                    ],
                    leads: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Lead::OrHash
                    ],
                    tags: T::Array[
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Tag::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(catalog_elements: nil, contacts: nil, customers: nil, leads: nil, tags: nil); end
              end

              class CatalogElement < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::CatalogElement,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Contact < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Contact,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Customer < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Customer,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Lead < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Lead,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Tag < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :color

                sig { params(color: String).void }
                attr_writer :color

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { override.returns({ id: Integer, color: String, name: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
                  def new(id: nil, color: nil, name: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company::Embedded::Tag,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CompanyListResponse::CompanyListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyListResponse::CompanyListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CompanyListResponse::CompanyListResponse,
            Amocrm::Models::CompanyListResponse::Problem
          )
        end
    end

    class CompanyUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Amocrm::CompanyUpdateByIDParams::Embedded)) }
      attr_reader :_embedded

      sig { params(_embedded: Amocrm::CompanyUpdateByIDParams::Embedded::OrHash).void }
      attr_writer :_embedded

      sig { returns(T.nilable(Integer)) }
      attr_reader :created_at

      sig { params(created_at: Integer).void }
      attr_writer :created_at

      sig { returns(T.nilable(Integer)) }
      attr_reader :created_by

      sig { params(created_by: Integer).void }
      attr_writer :created_by

      # Custom fields payload
      sig { returns(T.nilable(
            T::Array[Amocrm::CompanyUpdateByIDParams::CustomFieldsValue]
          )) }
      attr_reader :custom_fields_values

      sig { params(custom_fields_values: T::Array[Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::OrHash]).void }
      attr_writer :custom_fields_values

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(Integer)) }
      attr_reader :responsible_user_id

      sig { params(responsible_user_id: Integer).void }
      attr_writer :responsible_user_id

      # Tags to attach
      sig { returns(T.nilable(T::Array[Amocrm::CompanyUpdateByIDParams::TagsToAdd])) }
      attr_reader :tags_to_add

      sig { params(tags_to_add: T::Array[Amocrm::CompanyUpdateByIDParams::TagsToAdd::OrHash]).void }
      attr_writer :tags_to_add

      # Tags to delete
      sig { returns(T.nilable(T::Array[Amocrm::CompanyUpdateByIDParams::TagsToDelete])) }
      attr_reader :tags_to_delete

      sig { params(tags_to_delete: T::Array[Amocrm::CompanyUpdateByIDParams::TagsToDelete::OrHash]).void }
      attr_writer :tags_to_delete

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_at

      sig { params(updated_at: Integer).void }
      attr_writer :updated_at

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_by

      sig { params(updated_by: Integer).void }
      attr_writer :updated_by

      sig do
        override
          .returns({
            _embedded: Amocrm::CompanyUpdateByIDParams::Embedded,
            created_at: Integer,
            created_by: Integer,
            custom_fields_values:
              T::Array[Amocrm::CompanyUpdateByIDParams::CustomFieldsValue],
            name: String,
            responsible_user_id: Integer,
            tags_to_add: T::Array[Amocrm::CompanyUpdateByIDParams::TagsToAdd],
            tags_to_delete:
              T::Array[Amocrm::CompanyUpdateByIDParams::TagsToDelete],
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            _embedded: Amocrm::CompanyUpdateByIDParams::Embedded::OrHash,
            created_at: Integer,
            created_by: Integer,
            custom_fields_values: T::Array[
              Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::OrHash
            ],
            name: String,
            responsible_user_id: Integer,
            tags_to_add: T::Array[Amocrm::CompanyUpdateByIDParams::TagsToAdd::OrHash],
            tags_to_delete: T::Array[Amocrm::CompanyUpdateByIDParams::TagsToDelete::OrHash],
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          _embedded: nil,
          created_at: nil,
          created_by: nil,
          custom_fields_values: nil, # Custom fields payload
          name: nil,
          responsible_user_id: nil,
          tags_to_add: nil, # Tags to attach
          tags_to_delete: nil, # Tags to delete
          updated_at: nil,
          updated_by: nil,
          request_options: {}
); end
      end

      class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
        # Field code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(String)) }
        attr_reader :field_code

        sig { params(field_code: String).void }
        attr_writer :field_code

        # Use either field_id or field_code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(Integer)) }
        attr_reader :field_id

        sig { params(field_id: Integer).void }
        attr_writer :field_id

        # Values for the field (multiple values allowed)
        sig { returns(T::Array[Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value]) }
        attr_accessor :values

        sig do
          override
            .returns({
              values:
                T::Array[
                  Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value
                ],
              field_code: String,
              field_id: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              values: T::Array[
                Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value::OrHash
              ],
              field_code: String,
              field_id: Integer
            ).returns(T.attached_class)
          end
          def new(
            values:, # Values for the field (multiple values allowed)
            field_code: nil, # Field code (e.g. PHONE/EMAIL)
            field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CompanyUpdateByIDParams::CustomFieldsValue,
              Amocrm::Internal::AnyHash
            )
          end

        class Value < Amocrm::Internal::Type::BaseModel
          # Option code for list/select custom fields (if you use code instead of id)
          sig { returns(T.nilable(String)) }
          attr_reader :enum_code

          sig { params(enum_code: String).void }
          attr_writer :enum_code

          # Option id for list/select custom fields (one of predefined options)
          sig { returns(T.nilable(Integer)) }
          attr_reader :enum_id

          sig { params(enum_id: Integer).void }
          attr_writer :enum_id

          sig { returns(Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value::Value::Variants) }
          attr_accessor :value

          sig do
            override
              .returns({
                value:
                  Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                value: Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              value:,
              enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
              enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value,
                Amocrm::Internal::AnyHash
              )
            end

          module Value
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::Value::Value::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
          end
        end
      end

      class Embedded < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Array[Amocrm::CompanyUpdateByIDParams::Embedded::Tag])) }
        attr_accessor :tags

        sig do
          override
            .returns({
              tags:
                T.nilable(
                  T::Array[Amocrm::CompanyUpdateByIDParams::Embedded::Tag]
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              tags: T.nilable(
                T::Array[Amocrm::CompanyUpdateByIDParams::Embedded::Tag::OrHash]
              )
            ).returns(T.attached_class)
          end
          def new(tags: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CompanyUpdateByIDParams::Embedded,
              Amocrm::Internal::AnyHash
            )
          end

        class Tag < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyUpdateByIDParams::Embedded::Tag,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CompanyUpdateByIDParams, Amocrm::Internal::AnyHash)
        end

      class TagsToAdd < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CompanyUpdateByIDParams::TagsToAdd,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TagsToDelete < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CompanyUpdateByIDParams::TagsToDelete,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    module CompanyUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CompanyUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class CompanyUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded::Company
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                companies: T::Array[
                  Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded::Company::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(companies: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CompanyUpdateByIDResponse::CompanyUpdateResponse,
            Amocrm::Models::CompanyUpdateByIDResponse::Problem
          )
        end
    end

    class CompanyUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CompanyUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CompanyUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CompanyUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::CompanyUpdateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::CompanyUpdateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        # Custom fields payload
        sig do
          returns(T.nilable(
              T::Array[Amocrm::CompanyUpdateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        # Company id
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        # Tags to attach
        sig { returns(T.nilable(T::Array[Amocrm::CompanyUpdateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::CompanyUpdateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        # Tags to delete
        sig { returns(T.nilable(T::Array[Amocrm::CompanyUpdateParams::Body::TagsToDelete])) }
        attr_reader :tags_to_delete

        sig { params(tags_to_delete: T::Array[Amocrm::CompanyUpdateParams::Body::TagsToDelete::OrHash]).void }
        attr_writer :tags_to_delete

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::CompanyUpdateParams::Body::Embedded,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T::Array[Amocrm::CompanyUpdateParams::Body::CustomFieldsValue],
              name: String,
              responsible_user_id: Integer,
              tags_to_add:
                T::Array[Amocrm::CompanyUpdateParams::Body::TagsToAdd],
              tags_to_delete:
                T::Array[Amocrm::CompanyUpdateParams::Body::TagsToDelete],
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::CompanyUpdateParams::Body::Embedded::OrHash,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T::Array[
                Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::OrHash
              ],
              name: String,
              responsible_user_id: Integer,
              tags_to_add: T::Array[Amocrm::CompanyUpdateParams::Body::TagsToAdd::OrHash],
              tags_to_delete: T::Array[Amocrm::CompanyUpdateParams::Body::TagsToDelete::OrHash],
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            id:, # Company id
            _embedded: nil,
            created_at: nil,
            created_by: nil,
            custom_fields_values: nil, # Custom fields payload
            name: nil,
            responsible_user_id: nil,
            tags_to_add: nil, # Tags to attach
            tags_to_delete: nil, # Tags to delete
            updated_at: nil,
            updated_by: nil
); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyUpdateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::CompanyUpdateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::CompanyUpdateParams::Body::Embedded::Tag]
              ))
          end
          attr_accessor :tags

          sig do
            override
              .returns({
                tags:
                  T.nilable(
                    T::Array[Amocrm::CompanyUpdateParams::Body::Embedded::Tag]
                  )
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tags: T.nilable(
                  T::Array[
                    Amocrm::CompanyUpdateParams::Body::Embedded::Tag::OrHash
                  ]
                )
              ).returns(T.attached_class)
            end
            def new(tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyUpdateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CompanyUpdateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::CompanyUpdateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyUpdateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class TagsToDelete < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CompanyUpdateParams::Body::TagsToDelete,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CompanyUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CompanyUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CompanyUpdateResponse::Variants]) }
        def variants; end
      end

      class CompanyUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded::Company
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                companies: T::Array[
                  Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded::Company::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(companies: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CompanyUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CompanyUpdateResponse::CompanyUpdateResponse,
            Amocrm::Models::CompanyUpdateResponse::Problem
          )
        end
    end

    class ContactChatLinkParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::ContactChatLinkParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::ContactChatLinkParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::ContactChatLinkParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :chat_id

        sig { returns(Integer) }
        attr_accessor :contact_id

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { override.returns({ chat_id: String, contact_id: Integer, request_id: String }) }
        def to_hash; end

        class << self
          sig { params(chat_id: String, contact_id: Integer, request_id: String).returns(T.attached_class) }
          def new(chat_id:, contact_id:, request_id: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::ContactChatLinkParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ContactChatLinkParams, Amocrm::Internal::AnyHash)
        end
    end

    module ContactChatLinkResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ContactChatLinkResponse::Variants]) }
        def variants; end
      end

      class ContactChatLinksResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded::Chat
                ]
              ))
          end
          attr_reader :chats

          sig do
            params(
              chats: T::Array[
                  Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded::Chat::OrHash
                ]
            ).void
          end
          attr_writer :chats

          sig do
            override
              .returns({
                chats:
                  T::Array[
                    Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded::Chat
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                chats: T::Array[
                  Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded::Chat::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(chats: nil); end
          end

          class Chat < Amocrm::Internal::Type::BaseModel
            sig { returns(String) }
            attr_accessor :chat_id

            sig { returns(Integer) }
            attr_accessor :contact_id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ chat_id: String, contact_id: Integer, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(chat_id: String, contact_id: Integer, request_id: String).returns(T.attached_class) }
              def new(chat_id:, contact_id:, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded::Chat,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactChatLinkResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ContactChatLinkResponse::ContactChatLinksResponse,
            Amocrm::Models::ContactChatLinkResponse::Problem
          )
        end
    end

    class ContactChatListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { override.returns({ filter: T.anything, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(filter: T.anything, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(filter: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ContactChatListParams, Amocrm::Internal::AnyHash)
        end
    end

    module ContactChatListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ContactChatListResponse::Variants]) }
        def variants; end
      end

      class ContactChatLinksResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded::Chat
                ]
              ))
          end
          attr_reader :chats

          sig do
            params(
              chats: T::Array[
                  Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded::Chat::OrHash
                ]
            ).void
          end
          attr_writer :chats

          sig do
            override
              .returns({
                chats:
                  T::Array[
                    Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded::Chat
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                chats: T::Array[
                  Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded::Chat::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(chats: nil); end
          end

          class Chat < Amocrm::Internal::Type::BaseModel
            sig { returns(String) }
            attr_accessor :chat_id

            sig { returns(Integer) }
            attr_accessor :contact_id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ chat_id: String, contact_id: Integer, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(chat_id: String, contact_id: Integer, request_id: String).returns(T.attached_class) }
              def new(chat_id:, contact_id:, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded::Chat,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactChatListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ContactChatListResponse::ContactChatLinksResponse,
            Amocrm::Models::ContactChatListResponse::Problem
          )
        end
    end

    class ContactCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::ContactCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::ContactCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::ContactCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        # Embedded entities
        sig { returns(T.nilable(Amocrm::ContactCreateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::ContactCreateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        # Custom fields payload
        sig do
          returns(T.nilable(
              T::Array[Amocrm::ContactCreateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::ContactCreateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(T.nilable(String)) }
        attr_reader :first_name

        sig { params(first_name: String).void }
        attr_writer :first_name

        sig { returns(T.nilable(String)) }
        attr_reader :last_name

        sig { params(last_name: String).void }
        attr_writer :last_name

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        # Tags to attach
        sig { returns(T.nilable(T::Array[Amocrm::ContactCreateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::ContactCreateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              _embedded: Amocrm::ContactCreateParams::Body::Embedded,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T::Array[Amocrm::ContactCreateParams::Body::CustomFieldsValue],
              first_name: String,
              last_name: String,
              name: String,
              request_id: String,
              responsible_user_id: Integer,
              tags_to_add:
                T::Array[Amocrm::ContactCreateParams::Body::TagsToAdd],
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::ContactCreateParams::Body::Embedded::OrHash,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T::Array[
                Amocrm::ContactCreateParams::Body::CustomFieldsValue::OrHash
              ],
              first_name: String,
              last_name: String,
              name: String,
              request_id: String,
              responsible_user_id: Integer,
              tags_to_add: T::Array[Amocrm::ContactCreateParams::Body::TagsToAdd::OrHash],
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            _embedded: nil, # Embedded entities
            created_at: nil,
            created_by: nil,
            custom_fields_values: nil, # Custom fields payload
            first_name: nil,
            last_name: nil,
            name: nil,
            request_id: nil, # Client-side request id
            responsible_user_id: nil,
            tags_to_add: nil, # Tags to attach
            updated_at: nil,
            updated_by: nil
); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactCreateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::ContactCreateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::ContactCreateParams::Body::Embedded::Tag]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::ContactCreateParams::Body::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                tags: T::Array[Amocrm::ContactCreateParams::Body::Embedded::Tag]
              })
          end
          def to_hash; end

          class << self
            # Embedded entities
            sig do
              params(
                tags: T::Array[
                  Amocrm::ContactCreateParams::Body::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactCreateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::ContactCreateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::ContactCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactCreateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ContactCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module ContactCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ContactCreateResponse::Variants]) }
        def variants; end
      end

      class ContactCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            override
              .returns({
                contacts:
                  T::Array[
                    Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded::Contact
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                contacts: T::Array[
                  Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded::Contact::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(contacts: nil); end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactCreateResponse::ContactCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactCreateResponse::ContactCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ContactCreateResponse::ContactCreateResponse,
            Amocrm::Models::ContactCreateResponse::Problem
          )
        end
    end

    class ContactGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ContactGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module ContactGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ContactGetByIDResponse::Variants]) }
        def variants; end
      end

      class Contact < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::ContactGetByIDResponse::Contact::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :closest_task_at

        sig { params(closest_task_at: Integer).void }
        attr_writer :closest_task_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue
              ]
            ))
        end
        attr_accessor :custom_fields_values

        sig { returns(T.nilable(String)) }
        attr_reader :first_name

        sig { params(first_name: String).void }
        attr_writer :first_name

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_unsorted

        sig { params(is_unsorted: T::Boolean).void }
        attr_writer :is_unsorted

        sig { returns(T.nilable(String)) }
        attr_reader :last_name

        sig { params(last_name: String).void }
        attr_writer :last_name

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _embedded:
                Amocrm::Models::ContactGetByIDResponse::Contact::Embedded,
              _links: T.anything,
              account_id: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T.nilable(
                  T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue
                  ]
                ),
              first_name: String,
              group_id: Integer,
              is_unsorted: T::Boolean,
              last_name: String,
              name: String,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::OrHash,
              _links: T.anything,
              account_id: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T.nilable(
                T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::OrHash
                ]
              ),
              first_name: String,
              group_id: Integer,
              is_unsorted: T::Boolean,
              last_name: String,
              name: String,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, account_id: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, first_name: nil, group_id: nil, is_unsorted: nil, last_name: nil, name: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::CatalogElement
                ]
              ))
          end
          attr_reader :catalog_elements

          sig do
            params(
              catalog_elements: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::CatalogElement::OrHash
                ]
            ).void
          end
          attr_writer :catalog_elements

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Customer
                ]
              ))
          end
          attr_reader :customers

          sig do
            params(
              customers: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Customer::OrHash
                ]
            ).void
          end
          attr_writer :customers

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig { returns(T.nilable(T::Array[T.anything])) }
          attr_reader :social_profiles

          sig { params(social_profiles: T::Array[T.anything]).void }
          attr_writer :social_profiles

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Tag
                ]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                catalog_elements:
                  T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::CatalogElement
                  ],
                companies:
                  T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Company
                  ],
                customers:
                  T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Customer
                  ],
                leads:
                  T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Lead
                  ],
                social_profiles: T::Array[T.anything],
                tags:
                  T::Array[
                    Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Tag
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_elements: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::CatalogElement::OrHash
                ],
                companies: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Company::OrHash
                ],
                customers: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Customer::OrHash
                ],
                leads: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Lead::OrHash
                ],
                social_profiles: T::Array[T.anything],
                tags: T::Array[
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalog_elements: nil, companies: nil, customers: nil, leads: nil, social_profiles: nil, tags: nil); end
          end

          class CatalogElement < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::CatalogElement,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Customer < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Customer,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactGetByIDResponse::Contact::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactGetByIDResponse::Contact::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactGetByIDResponse::Contact,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ContactGetByIDResponse::Contact,
            Amocrm::Models::ContactGetByIDResponse::Problem
          )
        end
    end

    class ContactListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Filtering parameters
      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      # Pagination limit
      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      # Sorting, e.g. order[updated_at]=asc
      sig { returns(T.nilable(T.anything)) }
      attr_reader :order

      sig { params(order: T.anything).void }
      attr_writer :order

      # Pagination page
      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      # Search by query string or id
      sig { returns(T.nilable(Amocrm::ContactListParams::Query::Variants)) }
      attr_reader :query

      sig { params(query: Amocrm::ContactListParams::Query::Variants).void }
      attr_writer :query

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::ContactListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::ContactListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          filter: nil, # Filtering parameters
          limit: nil, # Pagination limit
          order: nil, # Sorting, e.g. order[updated_at]=asc
          page: nil, # Pagination page
          query: nil, # Search by query string or id
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ContactListParams, Amocrm::Internal::AnyHash)
        end

      # Search by query string or id
      module Query
        extend Amocrm::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Amocrm::ContactListParams::Query::Variants]) }
          def variants; end
        end

        Variants = T.type_alias { T.any(String, Integer) }
      end
    end

    module ContactListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ContactListResponse::Variants]) }
        def variants; end
      end

      class ContactListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::ContactListResponse::ContactListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::ContactListResponse::ContactListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            override
              .returns({
                contacts:
                  T::Array[
                    Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                contacts: T::Array[
                  Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(contacts: nil); end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :closest_task_at

            sig { params(closest_task_at: Integer).void }
            attr_writer :closest_task_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(String)) }
            attr_reader :first_name

            sig { params(first_name: String).void }
            attr_writer :first_name

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_unsorted

            sig { params(is_unsorted: T::Boolean).void }
            attr_writer :is_unsorted

            sig { returns(T.nilable(String)) }
            attr_reader :last_name

            sig { params(last_name: String).void }
            attr_writer :last_name

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue
                      ]
                    ),
                  first_name: String,
                  group_id: Integer,
                  is_unsorted: T::Boolean,
                  last_name: String,
                  name: String,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::OrHash
                    ]
                  ),
                  first_name: String,
                  group_id: Integer,
                  is_unsorted: T::Boolean,
                  last_name: String,
                  name: String,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, first_name: nil, group_id: nil, is_unsorted: nil, last_name: nil, name: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::CatalogElement
                    ]
                  ))
              end
              attr_reader :catalog_elements

              sig do
                params(
                  catalog_elements: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::CatalogElement::OrHash
                    ]
                ).void
              end
              attr_writer :catalog_elements

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Company
                    ]
                  ))
              end
              attr_reader :companies

              sig do
                params(
                  companies: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Company::OrHash
                    ]
                ).void
              end
              attr_writer :companies

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Customer
                    ]
                  ))
              end
              attr_reader :customers

              sig do
                params(
                  customers: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Customer::OrHash
                    ]
                ).void
              end
              attr_writer :customers

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Lead
                    ]
                  ))
              end
              attr_reader :leads

              sig do
                params(
                  leads: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Lead::OrHash
                    ]
                ).void
              end
              attr_writer :leads

              sig { returns(T.nilable(T::Array[T.anything])) }
              attr_reader :social_profiles

              sig { params(social_profiles: T::Array[T.anything]).void }
              attr_writer :social_profiles

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Tag
                    ]
                  ))
              end
              attr_reader :tags

              sig do
                params(
                  tags: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Tag::OrHash
                    ]
                ).void
              end
              attr_writer :tags

              sig do
                override
                  .returns({
                    catalog_elements:
                      T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::CatalogElement
                      ],
                    companies:
                      T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Company
                      ],
                    customers:
                      T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Customer
                      ],
                    leads:
                      T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Lead
                      ],
                    social_profiles: T::Array[T.anything],
                    tags:
                      T::Array[
                        Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Tag
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_elements: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::CatalogElement::OrHash
                    ],
                    companies: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Company::OrHash
                    ],
                    customers: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Customer::OrHash
                    ],
                    leads: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Lead::OrHash
                    ],
                    social_profiles: T::Array[T.anything],
                    tags: T::Array[
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Tag::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(catalog_elements: nil, companies: nil, customers: nil, leads: nil, social_profiles: nil, tags: nil); end
              end

              class CatalogElement < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::CatalogElement,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Company < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Company,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Customer < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Customer,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Lead < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Lead,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Tag < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :color

                sig { params(color: String).void }
                attr_writer :color

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { override.returns({ id: Integer, color: String, name: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
                  def new(id: nil, color: nil, name: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact::Embedded::Tag,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactListResponse::ContactListResponse::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactListResponse::ContactListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactListResponse::ContactListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ContactListResponse::ContactListResponse,
            Amocrm::Models::ContactListResponse::Problem
          )
        end
    end

    class ContactUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Amocrm::ContactUpdateByIDParams::Embedded)) }
      attr_reader :_embedded

      sig { params(_embedded: Amocrm::ContactUpdateByIDParams::Embedded::OrHash).void }
      attr_writer :_embedded

      sig { returns(T.nilable(Integer)) }
      attr_reader :created_at

      sig { params(created_at: Integer).void }
      attr_writer :created_at

      sig { returns(T.nilable(Integer)) }
      attr_reader :created_by

      sig { params(created_by: Integer).void }
      attr_writer :created_by

      # Custom fields payload
      sig { returns(T.nilable(
            T::Array[Amocrm::ContactUpdateByIDParams::CustomFieldsValue]
          )) }
      attr_reader :custom_fields_values

      sig { params(custom_fields_values: T::Array[Amocrm::ContactUpdateByIDParams::CustomFieldsValue::OrHash]).void }
      attr_writer :custom_fields_values

      sig { returns(T.nilable(String)) }
      attr_reader :first_name

      sig { params(first_name: String).void }
      attr_writer :first_name

      sig { returns(T.nilable(String)) }
      attr_reader :last_name

      sig { params(last_name: String).void }
      attr_writer :last_name

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(Integer)) }
      attr_reader :responsible_user_id

      sig { params(responsible_user_id: Integer).void }
      attr_writer :responsible_user_id

      # Tags to attach
      sig { returns(T.nilable(T::Array[Amocrm::ContactUpdateByIDParams::TagsToAdd])) }
      attr_reader :tags_to_add

      sig { params(tags_to_add: T::Array[Amocrm::ContactUpdateByIDParams::TagsToAdd::OrHash]).void }
      attr_writer :tags_to_add

      # Tags to delete
      sig { returns(T.nilable(T::Array[Amocrm::ContactUpdateByIDParams::TagsToDelete])) }
      attr_reader :tags_to_delete

      sig { params(tags_to_delete: T::Array[Amocrm::ContactUpdateByIDParams::TagsToDelete::OrHash]).void }
      attr_writer :tags_to_delete

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_at

      sig { params(updated_at: Integer).void }
      attr_writer :updated_at

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_by

      sig { params(updated_by: Integer).void }
      attr_writer :updated_by

      sig do
        override
          .returns({
            _embedded: Amocrm::ContactUpdateByIDParams::Embedded,
            created_at: Integer,
            created_by: Integer,
            custom_fields_values:
              T::Array[Amocrm::ContactUpdateByIDParams::CustomFieldsValue],
            first_name: String,
            last_name: String,
            name: String,
            responsible_user_id: Integer,
            tags_to_add: T::Array[Amocrm::ContactUpdateByIDParams::TagsToAdd],
            tags_to_delete:
              T::Array[Amocrm::ContactUpdateByIDParams::TagsToDelete],
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            _embedded: Amocrm::ContactUpdateByIDParams::Embedded::OrHash,
            created_at: Integer,
            created_by: Integer,
            custom_fields_values: T::Array[
              Amocrm::ContactUpdateByIDParams::CustomFieldsValue::OrHash
            ],
            first_name: String,
            last_name: String,
            name: String,
            responsible_user_id: Integer,
            tags_to_add: T::Array[Amocrm::ContactUpdateByIDParams::TagsToAdd::OrHash],
            tags_to_delete: T::Array[Amocrm::ContactUpdateByIDParams::TagsToDelete::OrHash],
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          _embedded: nil,
          created_at: nil,
          created_by: nil,
          custom_fields_values: nil, # Custom fields payload
          first_name: nil,
          last_name: nil,
          name: nil,
          responsible_user_id: nil,
          tags_to_add: nil, # Tags to attach
          tags_to_delete: nil, # Tags to delete
          updated_at: nil,
          updated_by: nil,
          request_options: {}
); end
      end

      class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
        # Field code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(String)) }
        attr_reader :field_code

        sig { params(field_code: String).void }
        attr_writer :field_code

        # Use either field_id or field_code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(Integer)) }
        attr_reader :field_id

        sig { params(field_id: Integer).void }
        attr_writer :field_id

        # Values for the field (multiple values allowed)
        sig { returns(T::Array[Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value]) }
        attr_accessor :values

        sig do
          override
            .returns({
              values:
                T::Array[
                  Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value
                ],
              field_code: String,
              field_id: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              values: T::Array[
                Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value::OrHash
              ],
              field_code: String,
              field_id: Integer
            ).returns(T.attached_class)
          end
          def new(
            values:, # Values for the field (multiple values allowed)
            field_code: nil, # Field code (e.g. PHONE/EMAIL)
            field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::ContactUpdateByIDParams::CustomFieldsValue,
              Amocrm::Internal::AnyHash
            )
          end

        class Value < Amocrm::Internal::Type::BaseModel
          # Option code for list/select custom fields (if you use code instead of id)
          sig { returns(T.nilable(String)) }
          attr_reader :enum_code

          sig { params(enum_code: String).void }
          attr_writer :enum_code

          # Option id for list/select custom fields (one of predefined options)
          sig { returns(T.nilable(Integer)) }
          attr_reader :enum_id

          sig { params(enum_id: Integer).void }
          attr_writer :enum_id

          sig { returns(Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value::Value::Variants) }
          attr_accessor :value

          sig do
            override
              .returns({
                value:
                  Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                value: Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              value:,
              enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
              enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value,
                Amocrm::Internal::AnyHash
              )
            end

          module Value
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::ContactUpdateByIDParams::CustomFieldsValue::Value::Value::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
          end
        end
      end

      class Embedded < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Array[Amocrm::ContactUpdateByIDParams::Embedded::Tag])) }
        attr_accessor :tags

        sig do
          override
            .returns({
              tags:
                T.nilable(
                  T::Array[Amocrm::ContactUpdateByIDParams::Embedded::Tag]
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              tags: T.nilable(
                T::Array[Amocrm::ContactUpdateByIDParams::Embedded::Tag::OrHash]
              )
            ).returns(T.attached_class)
          end
          def new(tags: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::ContactUpdateByIDParams::Embedded,
              Amocrm::Internal::AnyHash
            )
          end

        class Tag < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactUpdateByIDParams::Embedded::Tag,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ContactUpdateByIDParams, Amocrm::Internal::AnyHash)
        end

      class TagsToAdd < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::ContactUpdateByIDParams::TagsToAdd,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TagsToDelete < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::ContactUpdateByIDParams::TagsToDelete,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    module ContactUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ContactUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class ContactUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            override
              .returns({
                contacts:
                  T::Array[
                    Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded::Contact
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                contacts: T::Array[
                  Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded::Contact::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(contacts: nil); end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ContactUpdateByIDResponse::ContactUpdateResponse,
            Amocrm::Models::ContactUpdateByIDResponse::Problem
          )
        end
    end

    class ContactUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::ContactUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::ContactUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::ContactUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::ContactUpdateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::ContactUpdateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        # Custom fields payload
        sig do
          returns(T.nilable(
              T::Array[Amocrm::ContactUpdateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::ContactUpdateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(T.nilable(String)) }
        attr_reader :first_name

        sig { params(first_name: String).void }
        attr_writer :first_name

        # Contact id
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :last_name

        sig { params(last_name: String).void }
        attr_writer :last_name

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        # Tags to attach
        sig { returns(T.nilable(T::Array[Amocrm::ContactUpdateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::ContactUpdateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        # Tags to delete
        sig { returns(T.nilable(T::Array[Amocrm::ContactUpdateParams::Body::TagsToDelete])) }
        attr_reader :tags_to_delete

        sig { params(tags_to_delete: T::Array[Amocrm::ContactUpdateParams::Body::TagsToDelete::OrHash]).void }
        attr_writer :tags_to_delete

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::ContactUpdateParams::Body::Embedded,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T::Array[Amocrm::ContactUpdateParams::Body::CustomFieldsValue],
              first_name: String,
              last_name: String,
              name: String,
              responsible_user_id: Integer,
              tags_to_add:
                T::Array[Amocrm::ContactUpdateParams::Body::TagsToAdd],
              tags_to_delete:
                T::Array[Amocrm::ContactUpdateParams::Body::TagsToDelete],
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::ContactUpdateParams::Body::Embedded::OrHash,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T::Array[
                Amocrm::ContactUpdateParams::Body::CustomFieldsValue::OrHash
              ],
              first_name: String,
              last_name: String,
              name: String,
              responsible_user_id: Integer,
              tags_to_add: T::Array[Amocrm::ContactUpdateParams::Body::TagsToAdd::OrHash],
              tags_to_delete: T::Array[Amocrm::ContactUpdateParams::Body::TagsToDelete::OrHash],
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            id:, # Contact id
            _embedded: nil,
            created_at: nil,
            created_by: nil,
            custom_fields_values: nil, # Custom fields payload
            first_name: nil,
            last_name: nil,
            name: nil,
            responsible_user_id: nil,
            tags_to_add: nil, # Tags to attach
            tags_to_delete: nil, # Tags to delete
            updated_at: nil,
            updated_by: nil
); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactUpdateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::ContactUpdateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::ContactUpdateParams::Body::Embedded::Tag]
              ))
          end
          attr_accessor :tags

          sig do
            override
              .returns({
                tags:
                  T.nilable(
                    T::Array[Amocrm::ContactUpdateParams::Body::Embedded::Tag]
                  )
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tags: T.nilable(
                  T::Array[
                    Amocrm::ContactUpdateParams::Body::Embedded::Tag::OrHash
                  ]
                )
              ).returns(T.attached_class)
            end
            def new(tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactUpdateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::ContactUpdateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::ContactUpdateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactUpdateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class TagsToDelete < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::ContactUpdateParams::Body::TagsToDelete,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ContactUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module ContactUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ContactUpdateResponse::Variants]) }
        def variants; end
      end

      class ContactUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            override
              .returns({
                contacts:
                  T::Array[
                    Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded::Contact
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                contacts: T::Array[
                  Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded::Contact::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(contacts: nil); end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ContactUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ContactUpdateResponse::ContactUpdateResponse,
            Amocrm::Models::ContactUpdateResponse::Problem
          )
        end
    end

    class CustomFieldCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CustomFieldCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomFieldCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomFieldCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :code

        sig { params(code: String).void }
        attr_writer :code

        sig { returns(T.nilable(T::Array[T.anything])) }
        attr_reader :enums

        sig { params(enums: T::Array[T.anything]).void }
        attr_writer :enums

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_deletable

        sig { params(is_deletable: T::Boolean).void }
        attr_writer :is_deletable

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_multiple

        sig { params(is_multiple: T::Boolean).void }
        attr_writer :is_multiple

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_required

        sig { params(is_required: T::Boolean).void }
        attr_writer :is_required

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_visible

        sig { params(is_visible: T::Boolean).void }
        attr_writer :is_visible

        sig { returns(String) }
        attr_accessor :name

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(T.anything)) }
        attr_reader :settings

        sig { params(settings: T.anything).void }
        attr_writer :settings

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { returns(String) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: String,
              type: String,
              code: String,
              enums: T::Array[T.anything],
              group_id: Integer,
              is_deletable: T::Boolean,
              is_multiple: T::Boolean,
              is_required: T::Boolean,
              is_visible: T::Boolean,
              request_id: String,
              settings: T.anything,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              type: String,
              code: String,
              enums: T::Array[T.anything],
              group_id: Integer,
              is_deletable: T::Boolean,
              is_multiple: T::Boolean,
              is_required: T::Boolean,
              is_visible: T::Boolean,
              request_id: String,
              settings: T.anything,
              sort: Integer
            ).returns(T.attached_class)
          end
          def new(
            name:,
            type:,
            code: nil,
            enums: nil,
            group_id: nil,
            is_deletable: nil,
            is_multiple: nil,
            is_required: nil,
            is_visible: nil,
            request_id: nil, # Client-side request id
            settings: nil,
            sort: nil
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomFieldCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldCreateResponse::Variants]) }
        def variants; end
      end

      class CustomFieldCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded::CustomField
                ]
              ))
          end
          attr_reader :custom_fields

          sig do
            params(
              custom_fields: T::Array[
                  Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded::CustomField::OrHash
                ]
            ).void
          end
          attr_writer :custom_fields

          sig do
            override
              .returns({
                custom_fields:
                  T::Array[
                    Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded::CustomField
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                custom_fields: T::Array[
                  Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded::CustomField::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(custom_fields: nil); end
          end

          class CustomField < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, name: String, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String, request_id: String).returns(T.attached_class) }
              def new(id: nil, name: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded::CustomField,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomFieldCreateResponse::CustomFieldCreateResponse,
            Amocrm::Models::CustomFieldCreateResponse::Problem
          )
        end
    end

    class CustomFieldDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :entity_type

      sig { override.returns({ entity_type: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(entity_type: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(entity_type:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldDeleteByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomFieldDeleteByIDResponse::Problem
          )
        end
    end

    class CustomFieldGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :entity_type

      sig { override.returns({ entity_type: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(entity_type: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(entity_type:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldGetByIDResponse::Variants]) }
        def variants; end
      end

      class CustomField < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :code

        sig { params(code: String).void }
        attr_writer :code

        sig { returns(T.nilable(String)) }
        attr_reader :entity_type

        sig { params(entity_type: String).void }
        attr_writer :entity_type

        sig { returns(T.nilable(T::Array[T.anything])) }
        attr_reader :enums

        sig { params(enums: T::Array[T.anything]).void }
        attr_writer :enums

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_deletable

        sig { params(is_deletable: T::Boolean).void }
        attr_writer :is_deletable

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_multiple

        sig { params(is_multiple: T::Boolean).void }
        attr_writer :is_multiple

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_required

        sig { params(is_required: T::Boolean).void }
        attr_writer :is_required

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_visible

        sig { params(is_visible: T::Boolean).void }
        attr_writer :is_visible

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(T.anything)) }
        attr_reader :settings

        sig { params(settings: T.anything).void }
        attr_writer :settings

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig do
          override
            .returns({
              id: Integer,
              code: String,
              entity_type: String,
              enums: T::Array[T.anything],
              group_id: Integer,
              is_deletable: T::Boolean,
              is_multiple: T::Boolean,
              is_required: T::Boolean,
              is_visible: T::Boolean,
              name: String,
              settings: T.anything,
              sort: Integer,
              type: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              code: String,
              entity_type: String,
              enums: T::Array[T.anything],
              group_id: Integer,
              is_deletable: T::Boolean,
              is_multiple: T::Boolean,
              is_required: T::Boolean,
              is_visible: T::Boolean,
              name: String,
              settings: T.anything,
              sort: Integer,
              type: String
            ).returns(T.attached_class)
          end
          def new(id: nil, code: nil, entity_type: nil, enums: nil, group_id: nil, is_deletable: nil, is_multiple: nil, is_required: nil, is_visible: nil, name: nil, settings: nil, sort: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGetByIDResponse::CustomField,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomFieldGetByIDResponse::CustomField,
            Amocrm::Models::CustomFieldGetByIDResponse::Problem
          )
        end
    end

    class CustomFieldGroupCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CustomFieldGroupCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomFieldGroupCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomFieldGroupCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :name

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { override.returns({ name: String, request_id: String, sort: Integer }) }
        def to_hash; end

        class << self
          sig { params(name: String, request_id: String, sort: Integer).returns(T.attached_class) }
          def new(
            name:,
            request_id: nil, # Client-side request id
            sort: nil
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomFieldGroupCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldGroupCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldGroupCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldGroupCreateResponse::Variants]) }
        def variants; end
      end

      class CustomFieldGroupCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded::Group
                ]
              ))
          end
          attr_reader :groups

          sig do
            params(
              groups: T::Array[
                  Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded::Group::OrHash
                ]
            ).void
          end
          attr_writer :groups

          sig do
            override
              .returns({
                groups:
                  T::Array[
                    Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded::Group
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                groups: T::Array[
                  Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded::Group::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(groups: nil); end
          end

          class Group < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, name: String, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String, request_id: String).returns(T.attached_class) }
              def new(id: nil, name: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded::Group,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomFieldGroupCreateResponse::CustomFieldGroupCreateResponse,
            Amocrm::Models::CustomFieldGroupCreateResponse::Problem
          )
        end
    end

    class CustomFieldGroupDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :entity_type

      sig { override.returns({ entity_type: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(entity_type: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(entity_type:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomFieldGroupDeleteByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomFieldGroupDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldGroupDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomFieldGroupDeleteByIDResponse::Problem
          )
        end
    end

    class CustomFieldGroupGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :entity_type

      sig { override.returns({ entity_type: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(entity_type: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(entity_type:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomFieldGroupGetByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomFieldGroupGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldGroupGetByIDResponse::Variants]) }
        def variants; end
      end

      class CustomFieldGroup < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_predefined

        sig { params(is_predefined: T::Boolean).void }
        attr_writer :is_predefined

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          override
            .returns({
              id: Integer,
              is_predefined: T::Boolean,
              name: String,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig { params(id: Integer, is_predefined: T::Boolean, name: String, sort: Integer).returns(T.attached_class) }
          def new(id: nil, is_predefined: nil, name: nil, sort: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupGetByIDResponse::CustomFieldGroup,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomFieldGroupGetByIDResponse::CustomFieldGroup,
            Amocrm::Models::CustomFieldGroupGetByIDResponse::Problem
          )
        end
    end

    class CustomFieldGroupListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(limit: nil, page: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldGroupListParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldGroupListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldGroupListResponse::Variants]) }
        def variants; end
      end

      class CustomFieldGroupListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded::Group
                ]
              ))
          end
          attr_reader :groups

          sig do
            params(
              groups: T::Array[
                  Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded::Group::OrHash
                ]
            ).void
          end
          attr_writer :groups

          sig do
            override
              .returns({
                groups:
                  T::Array[
                    Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded::Group
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                groups: T::Array[
                  Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded::Group::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(groups: nil); end
          end

          class Group < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_predefined

            sig { params(is_predefined: T::Boolean).void }
            attr_writer :is_predefined

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig do
              override
                .returns({
                  id: Integer,
                  is_predefined: T::Boolean,
                  name: String,
                  sort: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  is_predefined: T::Boolean,
                  name: String,
                  sort: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, is_predefined: nil, name: nil, sort: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded::Group,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomFieldGroupListResponse::CustomFieldGroupListResponse,
            Amocrm::Models::CustomFieldGroupListResponse::Problem
          )
        end
    end

    class CustomFieldGroupUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :entity_type

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(Integer)) }
      attr_reader :sort

      sig { params(sort: Integer).void }
      attr_writer :sort

      sig do
        override
          .returns({
            entity_type: String,
            name: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: String,
            name: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, name: nil, sort: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomFieldGroupUpdateByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomFieldGroupUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldGroupUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldGroupUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomFieldGroupUpdateByIDResponse::Problem
          )
        end
    end

    class CustomFieldListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(limit: nil, page: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldListParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldListResponse::Variants]) }
        def variants; end
      end

      class CustomFieldListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded::CustomField
                ]
              ))
          end
          attr_reader :custom_fields

          sig do
            params(
              custom_fields: T::Array[
                  Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded::CustomField::OrHash
                ]
            ).void
          end
          attr_writer :custom_fields

          sig do
            override
              .returns({
                custom_fields:
                  T::Array[
                    Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded::CustomField
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                custom_fields: T::Array[
                  Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded::CustomField::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(custom_fields: nil); end
          end

          class CustomField < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :code

            sig { params(code: String).void }
            attr_writer :code

            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(T::Array[T.anything])) }
            attr_reader :enums

            sig { params(enums: T::Array[T.anything]).void }
            attr_writer :enums

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_deletable

            sig { params(is_deletable: T::Boolean).void }
            attr_writer :is_deletable

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_multiple

            sig { params(is_multiple: T::Boolean).void }
            attr_writer :is_multiple

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_required

            sig { params(is_required: T::Boolean).void }
            attr_writer :is_required

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_visible

            sig { params(is_visible: T::Boolean).void }
            attr_writer :is_visible

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(T.anything)) }
            attr_reader :settings

            sig { params(settings: T.anything).void }
            attr_writer :settings

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig { returns(T.nilable(String)) }
            attr_reader :type

            sig { params(type: String).void }
            attr_writer :type

            sig do
              override
                .returns({
                  id: Integer,
                  code: String,
                  entity_type: String,
                  enums: T::Array[T.anything],
                  group_id: Integer,
                  is_deletable: T::Boolean,
                  is_multiple: T::Boolean,
                  is_required: T::Boolean,
                  is_visible: T::Boolean,
                  name: String,
                  settings: T.anything,
                  sort: Integer,
                  type: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  code: String,
                  entity_type: String,
                  enums: T::Array[T.anything],
                  group_id: Integer,
                  is_deletable: T::Boolean,
                  is_multiple: T::Boolean,
                  is_required: T::Boolean,
                  is_visible: T::Boolean,
                  name: String,
                  settings: T.anything,
                  sort: Integer,
                  type: String
                ).returns(T.attached_class)
              end
              def new(id: nil, code: nil, entity_type: nil, enums: nil, group_id: nil, is_deletable: nil, is_multiple: nil, is_required: nil, is_visible: nil, name: nil, settings: nil, sort: nil, type: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded::CustomField,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomFieldListResponse::CustomFieldListResponse,
            Amocrm::Models::CustomFieldListResponse::Problem
          )
        end
    end

    class CustomFieldUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :code

      sig { params(code: String).void }
      attr_writer :code

      sig { returns(String) }
      attr_accessor :entity_type

      sig { returns(T.nilable(T::Array[T.anything])) }
      attr_reader :enums

      sig { params(enums: T::Array[T.anything]).void }
      attr_writer :enums

      sig { returns(T.nilable(Integer)) }
      attr_reader :group_id

      sig { params(group_id: Integer).void }
      attr_writer :group_id

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_deletable

      sig { params(is_deletable: T::Boolean).void }
      attr_writer :is_deletable

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_multiple

      sig { params(is_multiple: T::Boolean).void }
      attr_writer :is_multiple

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_required

      sig { params(is_required: T::Boolean).void }
      attr_writer :is_required

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_visible

      sig { params(is_visible: T::Boolean).void }
      attr_writer :is_visible

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(T.anything)) }
      attr_reader :settings

      sig { params(settings: T.anything).void }
      attr_writer :settings

      sig { returns(T.nilable(Integer)) }
      attr_reader :sort

      sig { params(sort: Integer).void }
      attr_writer :sort

      sig { returns(T.nilable(String)) }
      attr_reader :type

      sig { params(type: String).void }
      attr_writer :type

      sig do
        override
          .returns({
            entity_type: String,
            code: String,
            enums: T::Array[T.anything],
            group_id: Integer,
            is_deletable: T::Boolean,
            is_multiple: T::Boolean,
            is_required: T::Boolean,
            is_visible: T::Boolean,
            name: String,
            settings: T.anything,
            sort: Integer,
            type: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: String,
            code: String,
            enums: T::Array[T.anything],
            group_id: Integer,
            is_deletable: T::Boolean,
            is_multiple: T::Boolean,
            is_required: T::Boolean,
            is_visible: T::Boolean,
            name: String,
            settings: T.anything,
            sort: Integer,
            type: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, code: nil, enums: nil, group_id: nil, is_deletable: nil, is_multiple: nil, is_required: nil, is_visible: nil, name: nil, settings: nil, sort: nil, type: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldUpdateByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomFieldUpdateByIDResponse::Problem
          )
        end
    end

    class CustomFieldUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CustomFieldUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomFieldUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomFieldUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :code

        sig { params(code: String).void }
        attr_writer :code

        sig { returns(T.nilable(T::Array[T.anything])) }
        attr_reader :enums

        sig { params(enums: T::Array[T.anything]).void }
        attr_writer :enums

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        # Custom field id
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_deletable

        sig { params(is_deletable: T::Boolean).void }
        attr_writer :is_deletable

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_multiple

        sig { params(is_multiple: T::Boolean).void }
        attr_writer :is_multiple

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_required

        sig { params(is_required: T::Boolean).void }
        attr_writer :is_required

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_visible

        sig { params(is_visible: T::Boolean).void }
        attr_writer :is_visible

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(T.anything)) }
        attr_reader :settings

        sig { params(settings: T.anything).void }
        attr_writer :settings

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig do
          override
            .returns({
              id: Integer,
              code: String,
              enums: T::Array[T.anything],
              group_id: Integer,
              is_deletable: T::Boolean,
              is_multiple: T::Boolean,
              is_required: T::Boolean,
              is_visible: T::Boolean,
              name: String,
              settings: T.anything,
              sort: Integer,
              type: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              code: String,
              enums: T::Array[T.anything],
              group_id: Integer,
              is_deletable: T::Boolean,
              is_multiple: T::Boolean,
              is_required: T::Boolean,
              is_visible: T::Boolean,
              name: String,
              settings: T.anything,
              sort: Integer,
              type: String
            ).returns(T.attached_class)
          end
          def new(
            id:, # Custom field id
            code: nil,
            enums: nil,
            group_id: nil,
            is_deletable: nil,
            is_multiple: nil,
            is_required: nil,
            is_visible: nil,
            name: nil,
            settings: nil,
            sort: nil,
            type: nil
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomFieldUpdateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomFieldUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomFieldUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomFieldUpdateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomFieldUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(T.anything, Amocrm::Models::CustomFieldUpdateResponse::Problem)
        end
    end

    class CustomerBonusPointChangeParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :earn

      sig { returns(Integer) }
      attr_accessor :redeem

      sig do
        override
          .returns({
            earn: Integer,
            redeem: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            earn: Integer,
            redeem: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(earn:, redeem:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerBonusPointChangeParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerBonusPointChangeResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerBonusPointChangeResponse::Variants]) }
        def variants; end
      end

      class CustomerBonusPointsResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :bonus_points

        sig { params(bonus_points: Integer).void }
        attr_writer :bonus_points

        sig { override.returns({ bonus_points: Integer }) }
        def to_hash; end

        class << self
          sig { params(bonus_points: Integer).returns(T.attached_class) }
          def new(bonus_points: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerBonusPointChangeResponse::CustomerBonusPointsResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerBonusPointChangeResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerBonusPointChangeResponse::CustomerBonusPointsResponse,
            Amocrm::Models::CustomerBonusPointChangeResponse::Problem
          )
        end
    end

    class CustomerCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CustomerCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomerCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomerCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::CustomerCreateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::CustomerCreateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig do
          returns(T.nilable(
              T::Array[Amocrm::CustomerCreateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::CustomerCreateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :main_user_id

        sig { params(main_user_id: Integer).void }
        attr_writer :main_user_id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :next_date

        sig { params(next_date: Integer).void }
        attr_writer :next_date

        sig { returns(T.nilable(Integer)) }
        attr_reader :next_price

        sig { params(next_price: Integer).void }
        attr_writer :next_price

        sig { returns(T.nilable(Integer)) }
        attr_reader :periodicity

        sig { params(periodicity: Integer).void }
        attr_writer :periodicity

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :status_id

        sig { params(status_id: Integer).void }
        attr_writer :status_id

        sig { returns(T.nilable(T::Array[Amocrm::CustomerCreateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::CustomerCreateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              _embedded: Amocrm::CustomerCreateParams::Body::Embedded,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T::Array[Amocrm::CustomerCreateParams::Body::CustomFieldsValue],
              main_user_id: Integer,
              name: String,
              next_date: Integer,
              next_price: Integer,
              periodicity: Integer,
              request_id: String,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add:
                T::Array[Amocrm::CustomerCreateParams::Body::TagsToAdd],
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::CustomerCreateParams::Body::Embedded::OrHash,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T::Array[
                Amocrm::CustomerCreateParams::Body::CustomFieldsValue::OrHash
              ],
              main_user_id: Integer,
              name: String,
              next_date: Integer,
              next_price: Integer,
              periodicity: Integer,
              request_id: String,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add: T::Array[Amocrm::CustomerCreateParams::Body::TagsToAdd::OrHash],
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, created_at: nil, created_by: nil, custom_fields_values: nil, main_user_id: nil, name: nil, next_date: nil, next_price: nil, periodicity: nil, request_id: nil, responsible_user_id: nil, status_id: nil, tags_to_add: nil, updated_by: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerCreateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::CustomerCreateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::CustomerCreateParams::Body::Embedded::Segment]
              ))
          end
          attr_reader :segments

          sig do
            params(
              segments: T::Array[
                  Amocrm::CustomerCreateParams::Body::Embedded::Segment::OrHash
                ]
            ).void
          end
          attr_writer :segments

          sig do
            returns(T.nilable(
                T::Array[Amocrm::CustomerCreateParams::Body::Embedded::Tag]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::CustomerCreateParams::Body::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                segments:
                  T::Array[
                    Amocrm::CustomerCreateParams::Body::Embedded::Segment
                  ],
                tags:
                  T::Array[Amocrm::CustomerCreateParams::Body::Embedded::Tag]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                segments: T::Array[
                  Amocrm::CustomerCreateParams::Body::Embedded::Segment::OrHash
                ],
                tags: T::Array[
                  Amocrm::CustomerCreateParams::Body::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(segments: nil, tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerCreateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Segment < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CustomerCreateParams::Body::Embedded::Segment,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CustomerCreateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::CustomerCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerCreateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerCreateResponse::Variants]) }
        def variants; end
      end

      class CustomerCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded::Customer
                ]
              ))
          end
          attr_reader :customers

          sig do
            params(
              customers: T::Array[
                  Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded::Customer::OrHash
                ]
            ).void
          end
          attr_writer :customers

          sig do
            override
              .returns({
                customers:
                  T::Array[
                    Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded::Customer
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                customers: T::Array[
                  Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded::Customer::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(customers: nil); end
          end

          class Customer < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded::Customer,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerCreateResponse::CustomerCreateResponse,
            Amocrm::Models::CustomerCreateResponse::Problem
          )
        end
    end

    class CustomerGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerGetByIDResponse::Variants]) }
        def variants; end
      end

      class Customer < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :average_check

        sig { params(average_check: Integer).void }
        attr_writer :average_check

        sig { returns(T.nilable(Integer)) }
        attr_reader :closest_task_at

        sig { params(closest_task_at: Integer).void }
        attr_writer :closest_task_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue
              ]
            ))
        end
        attr_accessor :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_deleted

        sig { params(is_deleted: T::Boolean).void }
        attr_writer :is_deleted

        sig { returns(T.nilable(Integer)) }
        attr_reader :ltv

        sig { params(ltv: Integer).void }
        attr_writer :ltv

        sig { returns(T.nilable(Integer)) }
        attr_reader :main_user_id

        sig { params(main_user_id: Integer).void }
        attr_writer :main_user_id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :next_date

        sig { params(next_date: Integer).void }
        attr_writer :next_date

        sig { returns(T.nilable(Integer)) }
        attr_reader :next_price

        sig { params(next_price: Integer).void }
        attr_writer :next_price

        sig { returns(T.nilable(Integer)) }
        attr_reader :periodicity

        sig { params(periodicity: Integer).void }
        attr_writer :periodicity

        sig { returns(T.nilable(Integer)) }
        attr_reader :purchases_count

        sig { params(purchases_count: Integer).void }
        attr_writer :purchases_count

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :status_id

        sig { params(status_id: Integer).void }
        attr_writer :status_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _embedded:
                Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded,
              _links: T.anything,
              account_id: Integer,
              average_check: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T.nilable(
                  T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue
                  ]
                ),
              group_id: Integer,
              is_deleted: T::Boolean,
              ltv: Integer,
              main_user_id: Integer,
              name: String,
              next_date: Integer,
              next_price: Integer,
              periodicity: Integer,
              purchases_count: Integer,
              responsible_user_id: Integer,
              status_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::OrHash,
              _links: T.anything,
              account_id: Integer,
              average_check: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T.nilable(
                T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::OrHash
                ]
              ),
              group_id: Integer,
              is_deleted: T::Boolean,
              ltv: Integer,
              main_user_id: Integer,
              name: String,
              next_date: Integer,
              next_price: Integer,
              periodicity: Integer,
              purchases_count: Integer,
              responsible_user_id: Integer,
              status_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, account_id: nil, average_check: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, group_id: nil, is_deleted: nil, ltv: nil, main_user_id: nil, name: nil, next_date: nil, next_price: nil, periodicity: nil, purchases_count: nil, responsible_user_id: nil, status_id: nil, updated_at: nil, updated_by: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig do
              returns(Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value::Value::Variants)
            end
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::CatalogElement
                ]
              ))
          end
          attr_reader :catalog_elements

          sig do
            params(
              catalog_elements: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::CatalogElement::OrHash
                ]
            ).void
          end
          attr_writer :catalog_elements

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Segment
                ]
              ))
          end
          attr_reader :segments

          sig do
            params(
              segments: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Segment::OrHash
                ]
            ).void
          end
          attr_writer :segments

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Tag
                ]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                catalog_elements:
                  T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::CatalogElement
                  ],
                companies:
                  T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Company
                  ],
                contacts:
                  T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Contact
                  ],
                segments:
                  T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Segment
                  ],
                tags:
                  T::Array[
                    Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Tag
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_elements: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::CatalogElement::OrHash
                ],
                companies: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Contact::OrHash
                ],
                segments: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Segment::OrHash
                ],
                tags: T::Array[
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalog_elements: nil, companies: nil, contacts: nil, segments: nil, tags: nil); end
          end

          class CatalogElement < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::CatalogElement,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Segment < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Segment,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerGetByIDResponse::Customer::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerGetByIDResponse::Customer,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerGetByIDResponse::Customer,
            Amocrm::Models::CustomerGetByIDResponse::Problem
          )
        end
    end

    class CustomerListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(T.anything)) }
      attr_reader :order

      sig { params(order: T.anything).void }
      attr_writer :order

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig { returns(T.nilable(Amocrm::CustomerListParams::Query::Variants)) }
      attr_reader :query

      sig { params(query: Amocrm::CustomerListParams::Query::Variants).void }
      attr_writer :query

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::CustomerListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::CustomerListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          filter: nil,
          limit: nil,
          order: nil,
          page: nil,
          query: nil,
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerListParams, Amocrm::Internal::AnyHash)
        end

      module Query
        extend Amocrm::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Amocrm::CustomerListParams::Query::Variants]) }
          def variants; end
        end

        Variants = T.type_alias { T.any(String, Integer) }
      end
    end

    module CustomerListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerListResponse::Variants]) }
        def variants; end
      end

      class CustomerListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer
                ]
              ))
          end
          attr_reader :customers

          sig do
            params(
              customers: T::Array[
                  Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::OrHash
                ]
            ).void
          end
          attr_writer :customers

          sig do
            override
              .returns({
                customers:
                  T::Array[
                    Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                customers: T::Array[
                  Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(customers: nil); end
          end

          class Customer < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :average_check

            sig { params(average_check: Integer).void }
            attr_writer :average_check

            sig { returns(T.nilable(Integer)) }
            attr_reader :closest_task_at

            sig { params(closest_task_at: Integer).void }
            attr_writer :closest_task_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_deleted

            sig { params(is_deleted: T::Boolean).void }
            attr_writer :is_deleted

            sig { returns(T.nilable(Integer)) }
            attr_reader :ltv

            sig { params(ltv: Integer).void }
            attr_writer :ltv

            sig { returns(T.nilable(Integer)) }
            attr_reader :main_user_id

            sig { params(main_user_id: Integer).void }
            attr_writer :main_user_id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :next_date

            sig { params(next_date: Integer).void }
            attr_writer :next_date

            sig { returns(T.nilable(Integer)) }
            attr_reader :next_price

            sig { params(next_price: Integer).void }
            attr_writer :next_price

            sig { returns(T.nilable(Integer)) }
            attr_reader :periodicity

            sig { params(periodicity: Integer).void }
            attr_writer :periodicity

            sig { returns(T.nilable(Integer)) }
            attr_reader :purchases_count

            sig { params(purchases_count: Integer).void }
            attr_writer :purchases_count

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  average_check: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue
                      ]
                    ),
                  group_id: Integer,
                  is_deleted: T::Boolean,
                  ltv: Integer,
                  main_user_id: Integer,
                  name: String,
                  next_date: Integer,
                  next_price: Integer,
                  periodicity: Integer,
                  purchases_count: Integer,
                  responsible_user_id: Integer,
                  status_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  average_check: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::OrHash
                    ]
                  ),
                  group_id: Integer,
                  is_deleted: T::Boolean,
                  ltv: Integer,
                  main_user_id: Integer,
                  name: String,
                  next_date: Integer,
                  next_price: Integer,
                  periodicity: Integer,
                  purchases_count: Integer,
                  responsible_user_id: Integer,
                  status_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, average_check: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, group_id: nil, is_deleted: nil, ltv: nil, main_user_id: nil, name: nil, next_date: nil, next_price: nil, periodicity: nil, purchases_count: nil, responsible_user_id: nil, status_id: nil, updated_at: nil, updated_by: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::CatalogElement
                    ]
                  ))
              end
              attr_reader :catalog_elements

              sig do
                params(
                  catalog_elements: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::CatalogElement::OrHash
                    ]
                ).void
              end
              attr_writer :catalog_elements

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Company
                    ]
                  ))
              end
              attr_reader :companies

              sig do
                params(
                  companies: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Company::OrHash
                    ]
                ).void
              end
              attr_writer :companies

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Contact
                    ]
                  ))
              end
              attr_reader :contacts

              sig do
                params(
                  contacts: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Contact::OrHash
                    ]
                ).void
              end
              attr_writer :contacts

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Segment
                    ]
                  ))
              end
              attr_reader :segments

              sig do
                params(
                  segments: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Segment::OrHash
                    ]
                ).void
              end
              attr_writer :segments

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Tag
                    ]
                  ))
              end
              attr_reader :tags

              sig do
                params(
                  tags: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Tag::OrHash
                    ]
                ).void
              end
              attr_writer :tags

              sig do
                override
                  .returns({
                    catalog_elements:
                      T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::CatalogElement
                      ],
                    companies:
                      T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Company
                      ],
                    contacts:
                      T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Contact
                      ],
                    segments:
                      T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Segment
                      ],
                    tags:
                      T::Array[
                        Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Tag
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_elements: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::CatalogElement::OrHash
                    ],
                    companies: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Company::OrHash
                    ],
                    contacts: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Contact::OrHash
                    ],
                    segments: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Segment::OrHash
                    ],
                    tags: T::Array[
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Tag::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(catalog_elements: nil, companies: nil, contacts: nil, segments: nil, tags: nil); end
              end

              class CatalogElement < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::CatalogElement,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Company < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Company,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Contact < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Contact,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Segment < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Segment,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Tag < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :color

                sig { params(color: String).void }
                attr_writer :color

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { override.returns({ id: Integer, color: String, name: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
                  def new(id: nil, color: nil, name: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer::Embedded::Tag,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded::Customer,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerListResponse::CustomerListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerListResponse::CustomerListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerListResponse::CustomerListResponse,
            Amocrm::Models::CustomerListResponse::Problem
          )
        end
    end

    class CustomerSegmentCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CustomerSegmentCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomerSegmentCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomerSegmentCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue
              ]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig do
          override
            .returns({
              name: String,
              color: String,
              custom_fields_values:
                T::Array[
                  Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue
                ],
              request_id: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              color: String,
              custom_fields_values: T::Array[
                Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::OrHash
              ],
              request_id: String
            ).returns(T.attached_class)
          end
          def new(name:, color: nil, custom_fields_values: nil, request_id: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::CustomerSegmentCreateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerSegmentCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerSegmentCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerSegmentCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerSegmentCreateResponse::Variants]) }
        def variants; end
      end

      class CustomerSegmentCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded::Segment
                ]
              ))
          end
          attr_reader :segments

          sig do
            params(
              segments: T::Array[
                  Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded::Segment::OrHash
                ]
            ).void
          end
          attr_writer :segments

          sig do
            override
              .returns({
                segments:
                  T::Array[
                    Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded::Segment
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                segments: T::Array[
                  Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded::Segment::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(segments: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Segment < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse::Embedded::Segment,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerSegmentCreateResponse::CustomerSegmentCreateResponse,
            Amocrm::Models::CustomerSegmentCreateResponse::Problem
          )
        end
    end

    class CustomerSegmentDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerSegmentDeleteByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerSegmentDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerSegmentDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomerSegmentDeleteByIDResponse::Problem
          )
        end
    end

    class CustomerSegmentGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerSegmentGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerSegmentGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerSegmentGetByIDResponse::Variants]) }
        def variants; end
      end

      class CustomerSegment < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue
              ]
            ))
        end
        attr_accessor :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :customers_count

        sig { params(customers_count: Integer).void }
        attr_writer :customers_count

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig do
          override
            .returns({
              id: Integer,
              color: String,
              created_at: Integer,
              custom_fields_values:
                T.nilable(
                  T::Array[
                    Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue
                  ]
                ),
              customers_count: Integer,
              name: String,
              updated_at: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              color: String,
              created_at: Integer,
              custom_fields_values: T.nilable(
                T::Array[
                  Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::OrHash
                ]
              ),
              customers_count: Integer,
              name: String,
              updated_at: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, color: nil, created_at: nil, custom_fields_values: nil, customers_count: nil, name: nil, updated_at: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig do
              returns(Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value::Value::Variants)
            end
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerSegmentGetByIDResponse::CustomerSegment,
            Amocrm::Models::CustomerSegmentGetByIDResponse::Problem
          )
        end
    end

    class CustomerSegmentListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerSegmentListParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerSegmentListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerSegmentListResponse::Variants]) }
        def variants; end
      end

      class CustomerSegmentListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment
                ]
              ))
          end
          attr_reader :segments

          sig do
            params(
              segments: T::Array[
                  Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::OrHash
                ]
            ).void
          end
          attr_writer :segments

          sig do
            override
              .returns({
                segments:
                  T::Array[
                    Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                segments: T::Array[
                  Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(segments: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Segment < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :customers_count

            sig { params(customers_count: Integer).void }
            attr_writer :customers_count

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  color: String,
                  created_at: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue
                      ]
                    ),
                  customers_count: Integer,
                  name: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  color: String,
                  created_at: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::OrHash
                    ]
                  ),
                  customers_count: Integer,
                  name: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, color: nil, created_at: nil, custom_fields_values: nil, customers_count: nil, name: nil, updated_at: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse::Embedded::Segment,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerSegmentListResponse::CustomerSegmentListResponse,
            Amocrm::Models::CustomerSegmentListResponse::Problem
          )
        end
    end

    class CustomerSegmentUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :color

      sig { params(color: String).void }
      attr_writer :color

      sig do
        returns(T.nilable(
            T::Array[Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue]
          ))
      end
      attr_reader :custom_fields_values

      sig do
        params(
          custom_fields_values: T::Array[
              Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::OrHash
            ]
        ).void
      end
      attr_writer :custom_fields_values

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig do
        override
          .returns({
            color: String,
            custom_fields_values:
              T::Array[
                Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue
              ],
            name: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            color: String,
            custom_fields_values: T::Array[
              Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::OrHash
            ],
            name: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(color: nil, custom_fields_values: nil, name: nil, request_options: {}); end
      end

      class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
        # Field code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(String)) }
        attr_reader :field_code

        sig { params(field_code: String).void }
        attr_writer :field_code

        # Use either field_id or field_code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(Integer)) }
        attr_reader :field_id

        sig { params(field_id: Integer).void }
        attr_writer :field_id

        # Values for the field (multiple values allowed)
        sig do
          returns(T::Array[
              Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value
            ])
        end
        attr_accessor :values

        sig do
          override
            .returns({
              values:
                T::Array[
                  Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value
                ],
              field_code: String,
              field_id: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              values: T::Array[
                Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value::OrHash
              ],
              field_code: String,
              field_id: Integer
            ).returns(T.attached_class)
          end
          def new(
            values:, # Values for the field (multiple values allowed)
            field_code: nil, # Field code (e.g. PHONE/EMAIL)
            field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue,
              Amocrm::Internal::AnyHash
            )
          end

        class Value < Amocrm::Internal::Type::BaseModel
          # Option code for list/select custom fields (if you use code instead of id)
          sig { returns(T.nilable(String)) }
          attr_reader :enum_code

          sig { params(enum_code: String).void }
          attr_writer :enum_code

          # Option id for list/select custom fields (one of predefined options)
          sig { returns(T.nilable(Integer)) }
          attr_reader :enum_id

          sig { params(enum_id: Integer).void }
          attr_writer :enum_id

          sig { returns(Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value::Value::Variants) }
          attr_accessor :value

          sig do
            override
              .returns({
                value:
                  Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                value: Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              value:,
              enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
              enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value,
                Amocrm::Internal::AnyHash
              )
            end

          module Value
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::Value::Value::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
          end
        end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerSegmentUpdateByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerSegmentUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerSegmentUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerSegmentUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomerSegmentUpdateByIDResponse::Problem
          )
        end
    end

    class CustomerStatusCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CustomerStatusCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomerStatusCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomerStatusCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { override.returns({ name: String, color: String, request_id: String, sort: Integer }) }
        def to_hash; end

        class << self
          sig { params(name: String, color: String, request_id: String, sort: Integer).returns(T.attached_class) }
          def new(name:, color: nil, request_id: nil, sort: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerStatusCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerStatusCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerStatusCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerStatusCreateResponse::Variants]) }
        def variants; end
      end

      class CustomerStatusCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded::Status
                ]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[
                    Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded::Status
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerStatusCreateResponse::CustomerStatusCreateResponse,
            Amocrm::Models::CustomerStatusCreateResponse::Problem
          )
        end
    end

    class CustomerStatusDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerStatusDeleteByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerStatusDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerStatusDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomerStatusDeleteByIDResponse::Problem
          )
        end
    end

    class CustomerStatusGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerStatusGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerStatusGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerStatusGetByIDResponse::Variants]) }
        def variants; end
      end

      class CustomerStatus < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig do
          override
            .returns({
              id: Integer,
              color: String,
              name: String,
              sort: Integer,
              type: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              color: String,
              name: String,
              sort: Integer,
              type: String
            ).returns(T.attached_class)
          end
          def new(id: nil, color: nil, name: nil, sort: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusGetByIDResponse::CustomerStatus,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerStatusGetByIDResponse::CustomerStatus,
            Amocrm::Models::CustomerStatusGetByIDResponse::Problem
          )
        end
    end

    class CustomerStatusListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerStatusListParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerStatusListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerStatusListResponse::Variants]) }
        def variants; end
      end

      class CustomerStatusListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded::Status
                ]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[
                    Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded::Status
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig { returns(T.nilable(String)) }
            attr_reader :type

            sig { params(type: String).void }
            attr_writer :type

            sig do
              override
                .returns({
                  id: Integer,
                  color: String,
                  name: String,
                  sort: Integer,
                  type: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  color: String,
                  name: String,
                  sort: Integer,
                  type: String
                ).returns(T.attached_class)
              end
              def new(id: nil, color: nil, name: nil, sort: nil, type: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerStatusListResponse::CustomerStatusListResponse,
            Amocrm::Models::CustomerStatusListResponse::Problem
          )
        end
    end

    class CustomerStatusUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :color

      sig { params(color: String).void }
      attr_writer :color

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(Integer)) }
      attr_reader :sort

      sig { params(sort: Integer).void }
      attr_writer :sort

      sig do
        override
          .returns({
            color: String,
            name: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            color: String,
            name: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(color: nil, name: nil, sort: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerStatusUpdateByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerStatusUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerStatusUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerStatusUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomerStatusUpdateByIDResponse::Problem
          )
        end
    end

    class CustomerTransactionCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :accrue_bonus

      sig { params(accrue_bonus: T::Boolean).void }
      attr_writer :accrue_bonus

      sig { returns(T::Array[Amocrm::CustomerTransactionCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomerTransactionCreateParams::Body],
            accrue_bonus: T::Boolean,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomerTransactionCreateParams::Body::OrHash],
            accrue_bonus: T::Boolean,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, accrue_bonus: nil, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :comment

        sig { params(comment: String).void }
        attr_writer :comment

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(Integer) }
        attr_accessor :price

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig do
          override
            .returns({
              price: Integer,
              comment: String,
              created_at: Integer,
              created_by: Integer,
              request_id: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              price: Integer,
              comment: String,
              created_at: Integer,
              created_by: Integer,
              request_id: String
            ).returns(T.attached_class)
          end
          def new(price:, comment: nil, created_at: nil, created_by: nil, request_id: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerTransactionCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerTransactionCreateParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerTransactionCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerTransactionCreateResponse::Variants]) }
        def variants; end
      end

      class CustomerTransactionCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded::Transaction
                ]
              ))
          end
          attr_reader :transactions

          sig do
            params(
              transactions: T::Array[
                  Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded::Transaction::OrHash
                ]
            ).void
          end
          attr_writer :transactions

          sig do
            override
              .returns({
                transactions:
                  T::Array[
                    Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded::Transaction
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                transactions: T::Array[
                  Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded::Transaction::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(transactions: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Transaction < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse::Embedded::Transaction,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerTransactionCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerTransactionCreateResponse::CustomerTransactionCreateResponse,
            Amocrm::Models::CustomerTransactionCreateResponse::Problem
          )
        end
    end

    class CustomerTransactionDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :customer_id

      sig { override.returns({ customer_id: Integer, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(customer_id: Integer, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(customer_id:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerTransactionDeleteByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerTransactionDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::CustomerTransactionDeleteByIDResponse::Variants
          ])
        end
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerTransactionDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            T.anything,
            Amocrm::Models::CustomerTransactionDeleteByIDResponse::Problem
          )
        end
    end

    class CustomerTransactionListByCustomerParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, limit: nil, page: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerTransactionListByCustomerParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerTransactionListByCustomerResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::CustomerTransactionListByCustomerResponse::Variants
          ])
        end
        def variants; end
      end

      class CustomerTransactionListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded::Transaction
                ]
              ))
          end
          attr_reader :transactions

          sig do
            params(
              transactions: T::Array[
                  Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded::Transaction::OrHash
                ]
            ).void
          end
          attr_writer :transactions

          sig do
            override
              .returns({
                transactions:
                  T::Array[
                    Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded::Transaction
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                transactions: T::Array[
                  Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded::Transaction::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(transactions: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Transaction < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(String)) }
            attr_reader :comment

            sig { params(comment: String).void }
            attr_writer :comment

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :customer_id

            sig { params(customer_id: Integer).void }
            attr_writer :customer_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :price

            sig { params(price: Integer).void }
            attr_writer :price

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  comment: String,
                  created_at: Integer,
                  created_by: Integer,
                  customer_id: Integer,
                  price: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  comment: String,
                  created_at: Integer,
                  created_by: Integer,
                  customer_id: Integer,
                  price: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, comment: nil, created_at: nil, created_by: nil, customer_id: nil, price: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse::Embedded::Transaction,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerTransactionListByCustomerResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerTransactionListByCustomerResponse::CustomerTransactionListResponse,
            Amocrm::Models::CustomerTransactionListByCustomerResponse::Problem
          )
        end
    end

    class CustomerTransactionListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, limit: nil, page: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::CustomerTransactionListParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module CustomerTransactionListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerTransactionListResponse::Variants]) }
        def variants; end
      end

      class CustomerTransactionListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded::Transaction
                ]
              ))
          end
          attr_reader :transactions

          sig do
            params(
              transactions: T::Array[
                  Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded::Transaction::OrHash
                ]
            ).void
          end
          attr_writer :transactions

          sig do
            override
              .returns({
                transactions:
                  T::Array[
                    Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded::Transaction
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                transactions: T::Array[
                  Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded::Transaction::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(transactions: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Transaction < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(String)) }
            attr_reader :comment

            sig { params(comment: String).void }
            attr_writer :comment

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :customer_id

            sig { params(customer_id: Integer).void }
            attr_writer :customer_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :price

            sig { params(price: Integer).void }
            attr_writer :price

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  comment: String,
                  created_at: Integer,
                  created_by: Integer,
                  customer_id: Integer,
                  price: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  comment: String,
                  created_at: Integer,
                  created_by: Integer,
                  customer_id: Integer,
                  price: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, comment: nil, created_at: nil, created_by: nil, customer_id: nil, price: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse::Embedded::Transaction,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerTransactionListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerTransactionListResponse::CustomerTransactionListResponse,
            Amocrm::Models::CustomerTransactionListResponse::Problem
          )
        end
    end

    class CustomerUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Amocrm::CustomerUpdateByIDParams::Embedded)) }
      attr_reader :_embedded

      sig { params(_embedded: Amocrm::CustomerUpdateByIDParams::Embedded::OrHash).void }
      attr_writer :_embedded

      sig { returns(T.nilable(
            T::Array[Amocrm::CustomerUpdateByIDParams::CustomFieldsValue]
          )) }
      attr_reader :custom_fields_values

      sig do
        params(
          custom_fields_values: T::Array[
              Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::OrHash
            ]
        ).void
      end
      attr_writer :custom_fields_values

      sig { returns(T.nilable(Integer)) }
      attr_reader :main_user_id

      sig { params(main_user_id: Integer).void }
      attr_writer :main_user_id

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(Integer)) }
      attr_reader :next_date

      sig { params(next_date: Integer).void }
      attr_writer :next_date

      sig { returns(T.nilable(Integer)) }
      attr_reader :next_price

      sig { params(next_price: Integer).void }
      attr_writer :next_price

      sig { returns(T.nilable(Integer)) }
      attr_reader :periodicity

      sig { params(periodicity: Integer).void }
      attr_writer :periodicity

      sig { returns(T.nilable(Integer)) }
      attr_reader :responsible_user_id

      sig { params(responsible_user_id: Integer).void }
      attr_writer :responsible_user_id

      sig { returns(T.nilable(Integer)) }
      attr_reader :status_id

      sig { params(status_id: Integer).void }
      attr_writer :status_id

      sig { returns(T.nilable(T::Array[Amocrm::CustomerUpdateByIDParams::TagsToAdd])) }
      attr_reader :tags_to_add

      sig { params(tags_to_add: T::Array[Amocrm::CustomerUpdateByIDParams::TagsToAdd::OrHash]).void }
      attr_writer :tags_to_add

      sig { returns(T.nilable(T::Array[Amocrm::CustomerUpdateByIDParams::TagsToDelete])) }
      attr_reader :tags_to_delete

      sig { params(tags_to_delete: T::Array[Amocrm::CustomerUpdateByIDParams::TagsToDelete::OrHash]).void }
      attr_writer :tags_to_delete

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_at

      sig { params(updated_at: Integer).void }
      attr_writer :updated_at

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_by

      sig { params(updated_by: Integer).void }
      attr_writer :updated_by

      sig do
        override
          .returns({
            _embedded: Amocrm::CustomerUpdateByIDParams::Embedded,
            custom_fields_values:
              T::Array[Amocrm::CustomerUpdateByIDParams::CustomFieldsValue],
            main_user_id: Integer,
            name: String,
            next_date: Integer,
            next_price: Integer,
            periodicity: Integer,
            responsible_user_id: Integer,
            status_id: Integer,
            tags_to_add: T::Array[Amocrm::CustomerUpdateByIDParams::TagsToAdd],
            tags_to_delete:
              T::Array[Amocrm::CustomerUpdateByIDParams::TagsToDelete],
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            _embedded: Amocrm::CustomerUpdateByIDParams::Embedded::OrHash,
            custom_fields_values: T::Array[
              Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::OrHash
            ],
            main_user_id: Integer,
            name: String,
            next_date: Integer,
            next_price: Integer,
            periodicity: Integer,
            responsible_user_id: Integer,
            status_id: Integer,
            tags_to_add: T::Array[Amocrm::CustomerUpdateByIDParams::TagsToAdd::OrHash],
            tags_to_delete: T::Array[Amocrm::CustomerUpdateByIDParams::TagsToDelete::OrHash],
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(_embedded: nil, custom_fields_values: nil, main_user_id: nil, name: nil, next_date: nil, next_price: nil, periodicity: nil, responsible_user_id: nil, status_id: nil, tags_to_add: nil, tags_to_delete: nil, updated_at: nil, updated_by: nil, request_options: {}); end
      end

      class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
        # Field code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(String)) }
        attr_reader :field_code

        sig { params(field_code: String).void }
        attr_writer :field_code

        # Use either field_id or field_code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(Integer)) }
        attr_reader :field_id

        sig { params(field_id: Integer).void }
        attr_writer :field_id

        # Values for the field (multiple values allowed)
        sig { returns(T::Array[Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value]) }
        attr_accessor :values

        sig do
          override
            .returns({
              values:
                T::Array[
                  Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value
                ],
              field_code: String,
              field_id: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              values: T::Array[
                Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value::OrHash
              ],
              field_code: String,
              field_id: Integer
            ).returns(T.attached_class)
          end
          def new(
            values:, # Values for the field (multiple values allowed)
            field_code: nil, # Field code (e.g. PHONE/EMAIL)
            field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerUpdateByIDParams::CustomFieldsValue,
              Amocrm::Internal::AnyHash
            )
          end

        class Value < Amocrm::Internal::Type::BaseModel
          # Option code for list/select custom fields (if you use code instead of id)
          sig { returns(T.nilable(String)) }
          attr_reader :enum_code

          sig { params(enum_code: String).void }
          attr_writer :enum_code

          # Option id for list/select custom fields (one of predefined options)
          sig { returns(T.nilable(Integer)) }
          attr_reader :enum_id

          sig { params(enum_id: Integer).void }
          attr_writer :enum_id

          sig { returns(Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value::Value::Variants) }
          attr_accessor :value

          sig do
            override
              .returns({
                value:
                  Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                value: Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              value:,
              enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
              enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value,
                Amocrm::Internal::AnyHash
              )
            end

          module Value
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::Value::Value::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
          end
        end
      end

      class Embedded < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              T::Array[Amocrm::CustomerUpdateByIDParams::Embedded::Segment]
            ))
        end
        attr_accessor :segments

        sig { returns(T.nilable(T::Array[Amocrm::CustomerUpdateByIDParams::Embedded::Tag])) }
        attr_accessor :tags

        sig do
          override
            .returns({
              segments:
                T.nilable(
                  T::Array[Amocrm::CustomerUpdateByIDParams::Embedded::Segment]
                ),
              tags:
                T.nilable(
                  T::Array[Amocrm::CustomerUpdateByIDParams::Embedded::Tag]
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              segments: T.nilable(
                T::Array[
                  Amocrm::CustomerUpdateByIDParams::Embedded::Segment::OrHash
                ]
              ),
              tags: T.nilable(
                T::Array[
                  Amocrm::CustomerUpdateByIDParams::Embedded::Tag::OrHash
                ]
              )
            ).returns(T.attached_class)
          end
          def new(segments: nil, tags: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerUpdateByIDParams::Embedded,
              Amocrm::Internal::AnyHash
            )
          end

        class Segment < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T.anything)) }
          attr_reader :_links

          sig { params(_links: T.anything).void }
          attr_writer :_links

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { override.returns({ id: Integer, _links: T.anything }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
            def new(id: nil, _links: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerUpdateByIDParams::Embedded::Segment,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class Tag < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerUpdateByIDParams::Embedded::Tag,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerUpdateByIDParams, Amocrm::Internal::AnyHash)
        end

      class TagsToAdd < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerUpdateByIDParams::TagsToAdd,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TagsToDelete < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::CustomerUpdateByIDParams::TagsToDelete,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    module CustomerUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class CustomerUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded::Customer
                ]
              ))
          end
          attr_reader :customers

          sig do
            params(
              customers: T::Array[
                  Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded::Customer::OrHash
                ]
            ).void
          end
          attr_writer :customers

          sig do
            override
              .returns({
                customers:
                  T::Array[
                    Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded::Customer
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                customers: T::Array[
                  Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded::Customer::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(customers: nil); end
          end

          class Customer < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded::Customer,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerUpdateByIDResponse::CustomerUpdateResponse,
            Amocrm::Models::CustomerUpdateByIDResponse::Problem
          )
        end
    end

    class CustomerUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::CustomerUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::CustomerUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::CustomerUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::CustomerUpdateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::CustomerUpdateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig do
          returns(T.nilable(
              T::Array[Amocrm::CustomerUpdateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(Integer)) }
        attr_reader :main_user_id

        sig { params(main_user_id: Integer).void }
        attr_writer :main_user_id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :next_date

        sig { params(next_date: Integer).void }
        attr_writer :next_date

        sig { returns(T.nilable(Integer)) }
        attr_reader :next_price

        sig { params(next_price: Integer).void }
        attr_writer :next_price

        sig { returns(T.nilable(Integer)) }
        attr_reader :periodicity

        sig { params(periodicity: Integer).void }
        attr_writer :periodicity

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :status_id

        sig { params(status_id: Integer).void }
        attr_writer :status_id

        sig { returns(T.nilable(T::Array[Amocrm::CustomerUpdateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::CustomerUpdateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        sig do
          returns(T.nilable(
              T::Array[Amocrm::CustomerUpdateParams::Body::TagsToDelete]
            ))
        end
        attr_reader :tags_to_delete

        sig { params(tags_to_delete: T::Array[Amocrm::CustomerUpdateParams::Body::TagsToDelete::OrHash]).void }
        attr_writer :tags_to_delete

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::CustomerUpdateParams::Body::Embedded,
              custom_fields_values:
                T::Array[Amocrm::CustomerUpdateParams::Body::CustomFieldsValue],
              main_user_id: Integer,
              name: String,
              next_date: Integer,
              next_price: Integer,
              periodicity: Integer,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add:
                T::Array[Amocrm::CustomerUpdateParams::Body::TagsToAdd],
              tags_to_delete:
                T::Array[Amocrm::CustomerUpdateParams::Body::TagsToDelete],
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::CustomerUpdateParams::Body::Embedded::OrHash,
              custom_fields_values: T::Array[
                Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::OrHash
              ],
              main_user_id: Integer,
              name: String,
              next_date: Integer,
              next_price: Integer,
              periodicity: Integer,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add: T::Array[Amocrm::CustomerUpdateParams::Body::TagsToAdd::OrHash],
              tags_to_delete: T::Array[
                Amocrm::CustomerUpdateParams::Body::TagsToDelete::OrHash
              ],
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id:, _embedded: nil, custom_fields_values: nil, main_user_id: nil, name: nil, next_date: nil, next_price: nil, periodicity: nil, responsible_user_id: nil, status_id: nil, tags_to_add: nil, tags_to_delete: nil, updated_at: nil, updated_by: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerUpdateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::CustomerUpdateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::CustomerUpdateParams::Body::Embedded::Segment]
              ))
          end
          attr_accessor :segments

          sig do
            returns(T.nilable(
                T::Array[Amocrm::CustomerUpdateParams::Body::Embedded::Tag]
              ))
          end
          attr_accessor :tags

          sig do
            override
              .returns({
                segments:
                  T.nilable(
                    T::Array[
                      Amocrm::CustomerUpdateParams::Body::Embedded::Segment
                    ]
                  ),
                tags:
                  T.nilable(
                    T::Array[Amocrm::CustomerUpdateParams::Body::Embedded::Tag]
                  )
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                segments: T.nilable(
                  T::Array[
                    Amocrm::CustomerUpdateParams::Body::Embedded::Segment::OrHash
                  ]
                ),
                tags: T.nilable(
                  T::Array[
                    Amocrm::CustomerUpdateParams::Body::Embedded::Tag::OrHash
                  ]
                )
              ).returns(T.attached_class)
            end
            def new(segments: nil, tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerUpdateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Segment < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CustomerUpdateParams::Body::Embedded::Segment,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::CustomerUpdateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::CustomerUpdateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerUpdateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class TagsToDelete < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::CustomerUpdateParams::Body::TagsToDelete,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomerUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomerUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomerUpdateResponse::Variants]) }
        def variants; end
      end

      class CustomerUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded::Customer
                ]
              ))
          end
          attr_reader :customers

          sig do
            params(
              customers: T::Array[
                  Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded::Customer::OrHash
                ]
            ).void
          end
          attr_writer :customers

          sig do
            override
              .returns({
                customers:
                  T::Array[
                    Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded::Customer
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                customers: T::Array[
                  Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded::Customer::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(customers: nil); end
          end

          class Customer < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded::Customer,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomerUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomerUpdateResponse::CustomerUpdateResponse,
            Amocrm::Models::CustomerUpdateResponse::Problem
          )
        end
    end

    class CustomersModeSetModeParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Boolean) }
      attr_accessor :is_enabled

      sig { returns(Amocrm::CustomersModeSetModeParams::Mode::OrSymbol) }
      attr_accessor :mode

      sig do
        override
          .returns({
            is_enabled: T::Boolean,
            mode: Amocrm::CustomersModeSetModeParams::Mode::OrSymbol,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            is_enabled: T::Boolean,
            mode: Amocrm::CustomersModeSetModeParams::Mode::OrSymbol,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(is_enabled:, mode:, request_options: {}); end
      end

      module Mode
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::CustomersModeSetModeParams::Mode::TaggedSymbol]) }
          def values; end
        end

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        PERIODICITY = T.let(
            :periodicity,
            Amocrm::CustomersModeSetModeParams::Mode::TaggedSymbol
          )

        SEGMENTS = T.let(
            :segments,
            Amocrm::CustomersModeSetModeParams::Mode::TaggedSymbol
          )

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::CustomersModeSetModeParams::Mode)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::CustomersModeSetModeParams, Amocrm::Internal::AnyHash)
        end
    end

    module CustomersModeSetModeResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::CustomersModeSetModeResponse::Variants]) }
        def variants; end
      end

      class CustomerModeResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_enabled

        sig { params(is_enabled: T::Boolean).void }
        attr_writer :is_enabled

        sig do
          returns(T.nilable(
              Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode::TaggedSymbol
            ))
        end
        attr_reader :mode

        sig { params(mode: Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode::OrSymbol).void }
        attr_writer :mode

        sig do
          override
            .returns({
              is_enabled: T::Boolean,
              mode:
                Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode::TaggedSymbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              is_enabled: T::Boolean,
              mode: Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode::OrSymbol
            ).returns(T.attached_class)
          end
          def new(is_enabled: nil, mode: nil); end
        end

        module Mode
          extend Amocrm::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode::TaggedSymbol
              ])
            end
            def values; end
          end

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          PERIODICITY = T.let(
              :periodicity,
              Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode::TaggedSymbol
            )

          SEGMENTS = T.let(
              :segments,
              Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse::Mode
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::CustomersModeSetModeResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::CustomersModeSetModeResponse::CustomerModeResponse,
            Amocrm::Models::CustomersModeSetModeResponse::Problem
          )
        end
    end

    class EntityFollowerAddParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityFollowerAddParams::Body]) }
      attr_accessor :body

      sig { returns(Amocrm::EntityFollowerAddParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type: Amocrm::EntityFollowerAddParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityFollowerAddParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityFollowerAddParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityFollowerAddParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(Integer) }
        attr_accessor :user_id

        sig { override.returns({ user_id: Integer }) }
        def to_hash; end

        class << self
          sig { params(user_id: Integer).returns(T.attached_class) }
          def new(user_id:); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityFollowerAddParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityFollowerAddParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityFollowerAddParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityFollowerAddParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityFollowerAddParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityFollowerAddParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityFollowerAddParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityFollowerAddParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityFollowerAddResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityFollowerAddResponse::Variants]) }
        def variants; end
      end

      class EntityFollowerCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded::Follower
                ]
              ))
          end
          attr_reader :followers

          sig do
            params(
              followers: T::Array[
                  Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded::Follower::OrHash
                ]
            ).void
          end
          attr_writer :followers

          sig do
            override
              .returns({
                followers:
                  T::Array[
                    Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded::Follower
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                followers: T::Array[
                  Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded::Follower::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(followers: nil); end
          end

          class Follower < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :user_id

            sig { params(user_id: Integer).void }
            attr_writer :user_id

            sig { override.returns({ user_id: Integer }) }
            def to_hash; end

            class << self
              sig { params(user_id: Integer).returns(T.attached_class) }
              def new(user_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded::Follower,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityFollowerAddResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityFollowerAddResponse::EntityFollowerCreateResponse,
            Amocrm::Models::EntityFollowerAddResponse::Problem
          )
        end
    end

    class EntityFollowerListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Amocrm::EntityFollowerListParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            entity_type: Amocrm::EntityFollowerListParams::EntityType::OrSymbol,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityFollowerListParams::EntityType::OrSymbol,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, limit: nil, page: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityFollowerListParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityFollowerListParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityFollowerListParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityFollowerListParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityFollowerListParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityFollowerListParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityFollowerListParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityFollowerListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityFollowerListResponse::Variants]) }
        def variants; end
      end

      class EntityFollowerListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded,
              _links: T.anything,
              _page: Integer,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded::Follower
                ]
              ))
          end
          attr_reader :followers

          sig do
            params(
              followers: T::Array[
                  Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded::Follower::OrHash
                ]
            ).void
          end
          attr_writer :followers

          sig do
            override
              .returns({
                followers:
                  T::Array[
                    Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded::Follower
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                followers: T::Array[
                  Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded::Follower::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(followers: nil); end
          end

          class Follower < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :user_id

            sig { params(user_id: Integer).void }
            attr_writer :user_id

            sig do
              override
                .returns({
                  id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  user_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  user_id: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, created_at: nil, created_by: nil, user_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded::Follower,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityFollowerListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityFollowerListResponse::EntityFollowerListResponse,
            Amocrm::Models::EntityFollowerListResponse::Problem
          )
        end
    end

    class EntityFollowerRemoveParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityFollowerRemoveParams::Body]) }
      attr_accessor :body

      sig { returns(Amocrm::EntityFollowerRemoveParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityFollowerRemoveParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityFollowerRemoveParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityFollowerRemoveParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityFollowerRemoveParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(Integer) }
        attr_accessor :user_id

        sig { override.returns({ user_id: Integer }) }
        def to_hash; end

        class << self
          sig { params(user_id: Integer).returns(T.attached_class) }
          def new(user_id:); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityFollowerRemoveParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityFollowerRemoveParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityFollowerRemoveParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityFollowerRemoveParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityFollowerRemoveParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityFollowerRemoveParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityFollowerRemoveParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityFollowerRemoveParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityFollowerRemoveResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityFollowerRemoveResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityFollowerRemoveResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityFollowerRemoveResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityFollowerRemoveResponse::EmptyResponse,
            Amocrm::Models::EntityFollowerRemoveResponse::Problem
          )
        end
    end

    class EntityLinkLinkByEntityParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityLinkLinkByEntityParams::Body]) }
      attr_accessor :body

      sig { returns(Amocrm::EntityLinkLinkByEntityParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityLinkLinkByEntityParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityLinkLinkByEntityParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityLinkLinkByEntityParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityLinkLinkByEntityParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :entity_type

        sig do
          params(
            entity_type: T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :entity_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :metadata

        sig { params(metadata: T.anything).void }
        attr_writer :metadata

        sig { returns(T.nilable(Integer)) }
        attr_reader :to_entity_id

        sig { params(to_entity_id: Integer).void }
        attr_writer :to_entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :to_entity_type

        sig do
          params(
            to_entity_type: T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :to_entity_type

        sig do
          override
            .returns({
              entity_id: Integer,
              entity_type:
                T.any(
                  Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::OrSymbol,
                  String
                ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type:
                T.any(
                  Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::OrSymbol,
                  String
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              entity_id: Integer,
              entity_type: T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::OrSymbol,
                String
              ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type: T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::OrSymbol,
                String
              )
            ).returns(T.attached_class)
          end
          def new(entity_id: nil, entity_type: nil, metadata: nil, to_entity_id: nil, to_entity_type: nil); end
        end

        module EntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::Variants
              ])
            end
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::EntityLinkLinkByEntityParams::Body::EntityType
              )
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::EntityType::TaggedSymbol,
                String
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityLinkLinkByEntityParams::Body,
              Amocrm::Internal::AnyHash
            )
          end

        module ToEntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::Variants
              ])
            end
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType
              )
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkLinkByEntityParams::Body::ToEntityType::TaggedSymbol,
                String
              )
            end
        end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityLinkLinkByEntityParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityLinkLinkByEntityParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityLinkLinkByEntityParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityLinkLinkByEntityParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityLinkLinkByEntityParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityLinkLinkByEntityParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityLinkLinkByEntityParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityLinkLinkByEntityResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityLinkLinkByEntityResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkLinkByEntityResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkLinkByEntityResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityLinkLinkByEntityResponse::EmptyResponse,
            Amocrm::Models::EntityLinkLinkByEntityResponse::Problem
          )
        end
    end

    class EntityLinkLinkParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityLinkLinkParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::EntityLinkLinkParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::EntityLinkLinkParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkLinkParams::Body::EntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :entity_type

        sig do
          params(
            entity_type: T.any(
                Amocrm::EntityLinkLinkParams::Body::EntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :entity_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :metadata

        sig { params(metadata: T.anything).void }
        attr_writer :metadata

        sig { returns(T.nilable(Integer)) }
        attr_reader :to_entity_id

        sig { params(to_entity_id: Integer).void }
        attr_writer :to_entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkLinkParams::Body::ToEntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :to_entity_type

        sig do
          params(
            to_entity_type: T.any(
                Amocrm::EntityLinkLinkParams::Body::ToEntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :to_entity_type

        sig do
          override
            .returns({
              entity_id: Integer,
              entity_type:
                T.any(
                  Amocrm::EntityLinkLinkParams::Body::EntityType::OrSymbol,
                  String
                ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type:
                T.any(
                  Amocrm::EntityLinkLinkParams::Body::ToEntityType::OrSymbol,
                  String
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              entity_id: Integer,
              entity_type: T.any(
                Amocrm::EntityLinkLinkParams::Body::EntityType::OrSymbol,
                String
              ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type: T.any(
                Amocrm::EntityLinkLinkParams::Body::ToEntityType::OrSymbol,
                String
              )
            ).returns(T.attached_class)
          end
          def new(entity_id: nil, entity_type: nil, metadata: nil, to_entity_id: nil, to_entity_type: nil); end
        end

        module EntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Amocrm::EntityLinkLinkParams::Body::EntityType::Variants]) }
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkLinkParams::Body::EntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkLinkParams::Body::EntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkLinkParams::Body::EntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkLinkParams::Body::EntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Amocrm::EntityLinkLinkParams::Body::EntityType)
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkLinkParams::Body::EntityType::TaggedSymbol,
                String
              )
            end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::EntityLinkLinkParams::Body, Amocrm::Internal::AnyHash)
          end

        module ToEntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::EntityLinkLinkParams::Body::ToEntityType::Variants
              ])
            end
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkLinkParams::Body::ToEntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkLinkParams::Body::ToEntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkLinkParams::Body::ToEntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkLinkParams::Body::ToEntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Amocrm::EntityLinkLinkParams::Body::ToEntityType)
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkLinkParams::Body::ToEntityType::TaggedSymbol,
                String
              )
            end
        end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityLinkLinkParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityLinkLinkParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityLinkLinkParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityLinkLinkParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(:leads, Amocrm::EntityLinkLinkParams::EntityType::TaggedSymbol)

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityLinkLinkParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityLinkLinkParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityLinkLinkResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityLinkLinkResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkLinkResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkLinkResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityLinkLinkResponse::EmptyResponse,
            Amocrm::Models::EntityLinkLinkResponse::Problem
          )
        end
    end

    class EntityLinkListByEntityParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Amocrm::EntityLinkListByEntityParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityLinkListByEntityParams::EntityType::OrSymbol,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityLinkListByEntityParams::EntityType::OrSymbol,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityLinkListByEntityParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityLinkListByEntityParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityLinkListByEntityParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityLinkListByEntityParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityLinkListByEntityParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityLinkListByEntityParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityLinkListByEntityParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityLinkListByEntityResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityLinkListByEntityResponse::Variants]) }
        def variants; end
      end

      class EntityLinksResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link
                ]
              ))
          end
          attr_reader :links

          sig do
            params(
              links: T::Array[
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::OrHash
                ]
            ).void
          end
          attr_writer :links

          sig do
            override
              .returns({
                links:
                  T::Array[
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                links: T::Array[
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(links: nil); end
          end

          class Link < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::Variants
                ))
            end
            attr_reader :entity_type

            sig do
              params(
                entity_type: T.any(
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :entity_type

            sig { returns(T.nilable(T.anything)) }
            attr_reader :metadata

            sig { params(metadata: T.anything).void }
            attr_writer :metadata

            sig { returns(T.nilable(Integer)) }
            attr_reader :to_entity_id

            sig { params(to_entity_id: Integer).void }
            attr_writer :to_entity_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::Variants
                ))
            end
            attr_reader :to_entity_type

            sig do
              params(
                to_entity_type: T.any(
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :to_entity_type

            sig do
              override
                .returns({
                  entity_id: Integer,
                  entity_type:
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::Variants,
                  metadata: T.anything,
                  to_entity_id: Integer,
                  to_entity_type:
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::Variants
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  entity_id: Integer,
                  entity_type: T.any(
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::OrSymbol,
                    String
                  ),
                  metadata: T.anything,
                  to_entity_id: Integer,
                  to_entity_type: T.any(
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::OrSymbol,
                    String
                  )
                ).returns(T.attached_class)
              end
              def new(entity_id: nil, entity_type: nil, metadata: nil, to_entity_id: nil, to_entity_type: nil); end
            end

            module EntityType
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::Variants
                  ])
                end
                def variants; end
              end

              COMPANIES = T.let(
                  :companies,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              CONTACTS = T.let(
                  :contacts,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              CUSTOMERS = T.let(
                  :customers,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              LEADS = T.let(
                  :leads,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol,
                    String
                  )
                end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link,
                  Amocrm::Internal::AnyHash
                )
              end

            module ToEntityType
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::Variants
                  ])
                end
                def variants; end
              end

              COMPANIES = T.let(
                  :companies,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              CONTACTS = T.let(
                  :contacts,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              CUSTOMERS = T.let(
                  :customers,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              LEADS = T.let(
                  :leads,
                  Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol,
                    String
                  )
                end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkListByEntityResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityLinkListByEntityResponse::EntityLinksResponse,
            Amocrm::Models::EntityLinkListByEntityResponse::Problem
          )
        end
    end

    class EntityLinkListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { override.returns({ filter: T.anything, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(filter: T.anything, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(filter: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityLinkListParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityLinkListParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityLinkListParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityLinkListParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(:leads, Amocrm::EntityLinkListParams::EntityType::TaggedSymbol)

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityLinkListParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityLinkListParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityLinkListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityLinkListResponse::Variants]) }
        def variants; end
      end

      class EntityLinksResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link
                ]
              ))
          end
          attr_reader :links

          sig do
            params(
              links: T::Array[
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::OrHash
                ]
            ).void
          end
          attr_writer :links

          sig do
            override
              .returns({
                links:
                  T::Array[
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                links: T::Array[
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(links: nil); end
          end

          class Link < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::Variants
                ))
            end
            attr_reader :entity_type

            sig do
              params(
                entity_type: T.any(
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :entity_type

            sig { returns(T.nilable(T.anything)) }
            attr_reader :metadata

            sig { params(metadata: T.anything).void }
            attr_writer :metadata

            sig { returns(T.nilable(Integer)) }
            attr_reader :to_entity_id

            sig { params(to_entity_id: Integer).void }
            attr_writer :to_entity_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::Variants
                ))
            end
            attr_reader :to_entity_type

            sig do
              params(
                to_entity_type: T.any(
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::OrSymbol,
                    String
                  )
              ).void
            end
            attr_writer :to_entity_type

            sig do
              override
                .returns({
                  entity_id: Integer,
                  entity_type:
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::Variants,
                  metadata: T.anything,
                  to_entity_id: Integer,
                  to_entity_type:
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::Variants
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  entity_id: Integer,
                  entity_type: T.any(
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::OrSymbol,
                    String
                  ),
                  metadata: T.anything,
                  to_entity_id: Integer,
                  to_entity_type: T.any(
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::OrSymbol,
                    String
                  )
                ).returns(T.attached_class)
              end
              def new(entity_id: nil, entity_type: nil, metadata: nil, to_entity_id: nil, to_entity_type: nil); end
            end

            module EntityType
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::Variants
                  ])
                end
                def variants; end
              end

              COMPANIES = T.let(
                  :companies,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              CONTACTS = T.let(
                  :contacts,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              CUSTOMERS = T.let(
                  :customers,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              LEADS = T.let(
                  :leads,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::EntityType::TaggedSymbol,
                    String
                  )
                end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link,
                  Amocrm::Internal::AnyHash
                )
              end

            module ToEntityType
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::Variants
                  ])
                end
                def variants; end
              end

              COMPANIES = T.let(
                  :companies,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              CONTACTS = T.let(
                  :contacts,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              CUSTOMERS = T.let(
                  :customers,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              LEADS = T.let(
                  :leads,
                  Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType
                  )
                end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded::Link::ToEntityType::TaggedSymbol,
                    String
                  )
                end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityLinkListResponse::EntityLinksResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkListResponse::EntityLinksResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityLinkListResponse::EntityLinksResponse,
            Amocrm::Models::EntityLinkListResponse::Problem
          )
        end
    end

    class EntityLinkUnlinkByEntityParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityLinkUnlinkByEntityParams::Body]) }
      attr_accessor :body

      sig { returns(Amocrm::EntityLinkUnlinkByEntityParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityLinkUnlinkByEntityParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityLinkUnlinkByEntityParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityLinkUnlinkByEntityParams::EntityType::OrSymbol,
            body: T::Array[Amocrm::EntityLinkUnlinkByEntityParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :entity_type

        sig do
          params(
            entity_type: T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :entity_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :metadata

        sig { params(metadata: T.anything).void }
        attr_writer :metadata

        sig { returns(T.nilable(Integer)) }
        attr_reader :to_entity_id

        sig { params(to_entity_id: Integer).void }
        attr_writer :to_entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :to_entity_type

        sig do
          params(
            to_entity_type: T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :to_entity_type

        sig do
          override
            .returns({
              entity_id: Integer,
              entity_type:
                T.any(
                  Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::OrSymbol,
                  String
                ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type:
                T.any(
                  Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::OrSymbol,
                  String
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              entity_id: Integer,
              entity_type: T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::OrSymbol,
                String
              ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type: T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::OrSymbol,
                String
              )
            ).returns(T.attached_class)
          end
          def new(entity_id: nil, entity_type: nil, metadata: nil, to_entity_id: nil, to_entity_type: nil); end
        end

        module EntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::Variants
              ])
            end
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType
              )
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::EntityType::TaggedSymbol,
                String
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityLinkUnlinkByEntityParams::Body,
              Amocrm::Internal::AnyHash
            )
          end

        module ToEntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::Variants
              ])
            end
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType
              )
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkUnlinkByEntityParams::Body::ToEntityType::TaggedSymbol,
                String
              )
            end
        end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityLinkUnlinkByEntityParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityLinkUnlinkByEntityParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityLinkUnlinkByEntityParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityLinkUnlinkByEntityParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityLinkUnlinkByEntityParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityLinkUnlinkByEntityParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::EntityLinkUnlinkByEntityParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module EntityLinkUnlinkByEntityResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityLinkUnlinkByEntityResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkUnlinkByEntityResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkUnlinkByEntityResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityLinkUnlinkByEntityResponse::EmptyResponse,
            Amocrm::Models::EntityLinkUnlinkByEntityResponse::Problem
          )
        end
    end

    class EntityLinkUnlinkParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityLinkUnlinkParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::EntityLinkUnlinkParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::EntityLinkUnlinkParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkUnlinkParams::Body::EntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :entity_type

        sig do
          params(
            entity_type: T.any(
                Amocrm::EntityLinkUnlinkParams::Body::EntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :entity_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :metadata

        sig { params(metadata: T.anything).void }
        attr_writer :metadata

        sig { returns(T.nilable(Integer)) }
        attr_reader :to_entity_id

        sig { params(to_entity_id: Integer).void }
        attr_writer :to_entity_id

        sig do
          returns(T.nilable(
              T.any(
                Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::OrSymbol,
                String
              )
            ))
        end
        attr_reader :to_entity_type

        sig do
          params(
            to_entity_type: T.any(
                Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::OrSymbol,
                String
              )
          ).void
        end
        attr_writer :to_entity_type

        sig do
          override
            .returns({
              entity_id: Integer,
              entity_type:
                T.any(
                  Amocrm::EntityLinkUnlinkParams::Body::EntityType::OrSymbol,
                  String
                ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type:
                T.any(
                  Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::OrSymbol,
                  String
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              entity_id: Integer,
              entity_type: T.any(
                Amocrm::EntityLinkUnlinkParams::Body::EntityType::OrSymbol,
                String
              ),
              metadata: T.anything,
              to_entity_id: Integer,
              to_entity_type: T.any(
                Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::OrSymbol,
                String
              )
            ).returns(T.attached_class)
          end
          def new(entity_id: nil, entity_type: nil, metadata: nil, to_entity_id: nil, to_entity_type: nil); end
        end

        module EntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::EntityLinkUnlinkParams::Body::EntityType::Variants
              ])
            end
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkUnlinkParams::Body::EntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkUnlinkParams::Body::EntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkUnlinkParams::Body::EntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkUnlinkParams::Body::EntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Amocrm::EntityLinkUnlinkParams::Body::EntityType)
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkUnlinkParams::Body::EntityType::TaggedSymbol,
                String
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityLinkUnlinkParams::Body,
              Amocrm::Internal::AnyHash
            )
          end

        module ToEntityType
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::Variants
              ])
            end
            def variants; end
          end

          COMPANIES = T.let(
              :companies,
              Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::TaggedSymbol
            )

          CONTACTS = T.let(
              :contacts,
              Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::TaggedSymbol
            )

          CUSTOMERS = T.let(
              :customers,
              Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::TaggedSymbol
            )

          LEADS = T.let(
              :leads,
              Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Amocrm::EntityLinkUnlinkParams::Body::ToEntityType)
            end

          Variants = T.type_alias do
              T.any(
                Amocrm::EntityLinkUnlinkParams::Body::ToEntityType::TaggedSymbol,
                String
              )
            end
        end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityLinkUnlinkParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityLinkUnlinkParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityLinkUnlinkParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityLinkUnlinkParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityLinkUnlinkParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityLinkUnlinkParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityLinkUnlinkParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityLinkUnlinkResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityLinkUnlinkResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkUnlinkResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityLinkUnlinkResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityLinkUnlinkResponse::EmptyResponse,
            Amocrm::Models::EntityLinkUnlinkResponse::Problem
          )
        end
    end

    class EntityNoteCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityNoteCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::EntityNoteCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::EntityNoteCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_need_to_trigger_digital_pipeline

        sig { params(is_need_to_trigger_digital_pipeline: T::Boolean).void }
        attr_writer :is_need_to_trigger_digital_pipeline

        sig { returns(String) }
        attr_accessor :note_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :params

        sig { params(params: T.anything).void }
        attr_writer :params

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              note_type: String,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              is_need_to_trigger_digital_pipeline: T::Boolean,
              params: T.anything,
              request_id: String,
              responsible_user_id: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              note_type: String,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              is_need_to_trigger_digital_pipeline: T::Boolean,
              params: T.anything,
              request_id: String,
              responsible_user_id: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            note_type:,
            created_at: nil,
            created_by: nil,
            entity_id: nil,
            is_need_to_trigger_digital_pipeline: nil,
            params: nil,
            request_id: nil, # Client-side request id
            responsible_user_id: nil,
            updated_by: nil
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityNoteCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityNoteCreateParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNoteCreateParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNoteCreateParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNoteCreateParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNoteCreateParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityNoteCreateParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityNoteCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityNoteCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityNoteCreateResponse::Variants]) }
        def variants; end
      end

      class NoteCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, entity_id: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNoteCreateResponse::NoteCreateResponse,
            Amocrm::Models::EntityNoteCreateResponse::Problem
          )
        end
    end

    class EntityNoteGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Amocrm::EntityNoteGetByIDParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            entity_type: Amocrm::EntityNoteGetByIDParams::EntityType::OrSymbol,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNoteGetByIDParams::EntityType::OrSymbol,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, with: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityNoteGetByIDParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNoteGetByIDParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNoteGetByIDParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNoteGetByIDParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNoteGetByIDParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityNoteGetByIDParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityNoteGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityNoteGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityNoteGetByIDResponse::Variants]) }
        def variants; end
      end

      class Note < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_pinned

        sig { params(is_pinned: T::Boolean).void }
        attr_writer :is_pinned

        sig { returns(T.nilable(String)) }
        attr_reader :note_type

        sig { params(note_type: String).void }
        attr_writer :note_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :params

        sig { params(params: T.anything).void }
        attr_writer :params

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              group_id: Integer,
              is_pinned: T::Boolean,
              note_type: String,
              params: T.anything,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              group_id: Integer,
              is_pinned: T::Boolean,
              note_type: String,
              params: T.anything,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, account_id: nil, created_at: nil, created_by: nil, entity_id: nil, group_id: nil, is_pinned: nil, note_type: nil, params: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteGetByIDResponse::Note,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNoteGetByIDResponse::Note,
            Amocrm::Models::EntityNoteGetByIDResponse::Problem
          )
        end
    end

    class EntityNoteListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, limit: nil, page: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityNoteListParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNoteListParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNoteListParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNoteListParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(:leads, Amocrm::EntityNoteListParams::EntityType::TaggedSymbol)

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityNoteListParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityNoteListParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityNoteListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityNoteListResponse::Variants]) }
        def variants; end
      end

      class NoteListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_pinned

            sig { params(is_pinned: T::Boolean).void }
            attr_writer :is_pinned

            sig { returns(T.nilable(String)) }
            attr_reader :note_type

            sig { params(note_type: String).void }
            attr_writer :note_type

            sig { returns(T.nilable(T.anything)) }
            attr_reader :params

            sig { params(params: T.anything).void }
            attr_writer :params

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  entity_id: Integer,
                  group_id: Integer,
                  is_pinned: T::Boolean,
                  note_type: String,
                  params: T.anything,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  entity_id: Integer,
                  group_id: Integer,
                  is_pinned: T::Boolean,
                  note_type: String,
                  params: T.anything,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, account_id: nil, created_at: nil, created_by: nil, entity_id: nil, group_id: nil, is_pinned: nil, note_type: nil, params: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNoteListResponse::NoteListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteListResponse::NoteListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNoteListResponse::NoteListResponse,
            Amocrm::Models::EntityNoteListResponse::Problem
          )
        end
    end

    class EntityNotePinParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Amocrm::EntityNotePinParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type: Amocrm::EntityNotePinParams::EntityType::OrSymbol,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNotePinParams::EntityType::OrSymbol,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityNotePinParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNotePinParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNotePinParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNotePinParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(:leads, Amocrm::EntityNotePinParams::EntityType::TaggedSymbol)

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityNotePinParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityNotePinParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityNotePinResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityNotePinResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotePinResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotePinResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNotePinResponse::EmptyResponse,
            Amocrm::Models::EntityNotePinResponse::Problem
          )
        end
    end

    class EntityNoteUnpinParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Amocrm::EntityNoteUnpinParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type: Amocrm::EntityNoteUnpinParams::EntityType::OrSymbol,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNoteUnpinParams::EntityType::OrSymbol,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityNoteUnpinParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNoteUnpinParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNoteUnpinParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNoteUnpinParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(:leads, Amocrm::EntityNoteUnpinParams::EntityType::TaggedSymbol)

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityNoteUnpinParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityNoteUnpinParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityNoteUnpinResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityNoteUnpinResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteUnpinResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteUnpinResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNoteUnpinResponse::EmptyResponse,
            Amocrm::Models::EntityNoteUnpinResponse::Problem
          )
        end
    end

    class EntityNoteUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :entity_id

      sig { params(entity_id: Integer).void }
      attr_writer :entity_id

      sig { returns(Amocrm::EntityNoteUpdateByIDParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig { returns(T.nilable(String)) }
      attr_reader :note_type

      sig { params(note_type: String).void }
      attr_writer :note_type

      sig { returns(T.nilable(T.anything)) }
      attr_reader :params

      sig { params(params: T.anything).void }
      attr_writer :params

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_at

      sig { params(updated_at: Integer).void }
      attr_writer :updated_at

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_by

      sig { params(updated_by: Integer).void }
      attr_writer :updated_by

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityNoteUpdateByIDParams::EntityType::OrSymbol,
            entity_id: Integer,
            note_type: String,
            params: T.anything,
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNoteUpdateByIDParams::EntityType::OrSymbol,
            entity_id: Integer,
            note_type: String,
            params: T.anything,
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, entity_id: nil, note_type: nil, params: nil, updated_at: nil, updated_by: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityNoteUpdateByIDParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNoteUpdateByIDParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNoteUpdateByIDParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNoteUpdateByIDParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNoteUpdateByIDParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityNoteUpdateByIDParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityNoteUpdateByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityNoteUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityNoteUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class NoteCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, entity_id: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNoteUpdateByIDResponse::NoteCreateResponse,
            Amocrm::Models::EntityNoteUpdateByIDResponse::Problem
          )
        end
    end

    class EntityNoteUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityNoteUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::EntityNoteUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::EntityNoteUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        # Note id
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :note_type

        sig { params(note_type: String).void }
        attr_writer :note_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :params

        sig { params(params: T.anything).void }
        attr_writer :params

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              entity_id: Integer,
              note_type: String,
              params: T.anything,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              entity_id: Integer,
              note_type: String,
              params: T.anything,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            id:, # Note id
            entity_id: nil,
            note_type: nil,
            params: nil,
            updated_at: nil,
            updated_by: nil
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityNoteUpdateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::EntityNoteUpdateParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNoteUpdateParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNoteUpdateParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNoteUpdateParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNoteUpdateParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::EntityNoteUpdateParams::EntityType)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EntityNoteUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module EntityNoteUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EntityNoteUpdateResponse::Variants]) }
        def variants; end
      end

      class NoteCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, entity_id: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNoteUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNoteUpdateResponse::NoteCreateResponse,
            Amocrm::Models::EntityNoteUpdateResponse::Problem
          )
        end
    end

    class EntityNotesByParentCreateByParentParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityNotesByParentCreateByParentParams::Body]) }
      attr_accessor :body

      sig { returns(Amocrm::EntityNotesByParentCreateByParentParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityNotesByParentCreateByParentParams::EntityType::OrSymbol,
            body:
              T::Array[Amocrm::EntityNotesByParentCreateByParentParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNotesByParentCreateByParentParams::EntityType::OrSymbol,
            body: T::Array[
              Amocrm::EntityNotesByParentCreateByParentParams::Body::OrHash
            ],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_need_to_trigger_digital_pipeline

        sig { params(is_need_to_trigger_digital_pipeline: T::Boolean).void }
        attr_writer :is_need_to_trigger_digital_pipeline

        sig { returns(String) }
        attr_accessor :note_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :params

        sig { params(params: T.anything).void }
        attr_writer :params

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              note_type: String,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              is_need_to_trigger_digital_pipeline: T::Boolean,
              params: T.anything,
              request_id: String,
              responsible_user_id: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              note_type: String,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              is_need_to_trigger_digital_pipeline: T::Boolean,
              params: T.anything,
              request_id: String,
              responsible_user_id: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            note_type:,
            created_at: nil,
            created_by: nil,
            entity_id: nil,
            is_need_to_trigger_digital_pipeline: nil,
            params: nil,
            request_id: nil, # Client-side request id
            responsible_user_id: nil,
            updated_by: nil
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityNotesByParentCreateByParentParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityNotesByParentCreateByParentParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNotesByParentCreateByParentParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNotesByParentCreateByParentParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNotesByParentCreateByParentParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNotesByParentCreateByParentParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(
              Symbol,
              Amocrm::EntityNotesByParentCreateByParentParams::EntityType
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::EntityNotesByParentCreateByParentParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module EntityNotesByParentCreateByParentResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::EntityNotesByParentCreateByParentResponse::Variants
          ])
        end
        def variants; end
      end

      class NoteCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, entity_id: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentCreateByParentResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNotesByParentCreateByParentResponse::NoteCreateResponse,
            Amocrm::Models::EntityNotesByParentCreateByParentResponse::Problem
          )
        end
    end

    class EntityNotesByParentGetByParentIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :entity_id

      sig { returns(Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::OrSymbol,
            entity_id: Integer,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::OrSymbol,
            entity_id: Integer,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, entity_id:, with: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(
              Symbol,
              Amocrm::EntityNotesByParentGetByParentIDParams::EntityType
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::EntityNotesByParentGetByParentIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module EntityNotesByParentGetByParentIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::EntityNotesByParentGetByParentIDResponse::Variants
          ])
        end
        def variants; end
      end

      class Note < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_pinned

        sig { params(is_pinned: T::Boolean).void }
        attr_writer :is_pinned

        sig { returns(T.nilable(String)) }
        attr_reader :note_type

        sig { params(note_type: String).void }
        attr_writer :note_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :params

        sig { params(params: T.anything).void }
        attr_writer :params

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              group_id: Integer,
              is_pinned: T::Boolean,
              note_type: String,
              params: T.anything,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              group_id: Integer,
              is_pinned: T::Boolean,
              note_type: String,
              params: T.anything,
              responsible_user_id: Integer,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, account_id: nil, created_at: nil, created_by: nil, entity_id: nil, group_id: nil, is_pinned: nil, note_type: nil, params: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentGetByParentIDResponse::Note,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentGetByParentIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNotesByParentGetByParentIDResponse::Note,
            Amocrm::Models::EntityNotesByParentGetByParentIDResponse::Problem
          )
        end
    end

    class EntityNotesByParentListByParentParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Amocrm::EntityNotesByParentListByParentParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityNotesByParentListByParentParams::EntityType::OrSymbol,
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNotesByParentListByParentParams::EntityType::OrSymbol,
            filter: T.anything,
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, filter: nil, limit: nil, page: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityNotesByParentListByParentParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNotesByParentListByParentParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNotesByParentListByParentParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNotesByParentListByParentParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNotesByParentListByParentParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(
              Symbol,
              Amocrm::EntityNotesByParentListByParentParams::EntityType
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::EntityNotesByParentListByParentParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module EntityNotesByParentListByParentResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::EntityNotesByParentListByParentResponse::Variants
          ])
        end
        def variants; end
      end

      class NoteListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_pinned

            sig { params(is_pinned: T::Boolean).void }
            attr_writer :is_pinned

            sig { returns(T.nilable(String)) }
            attr_reader :note_type

            sig { params(note_type: String).void }
            attr_writer :note_type

            sig { returns(T.nilable(T.anything)) }
            attr_reader :params

            sig { params(params: T.anything).void }
            attr_writer :params

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  entity_id: Integer,
                  group_id: Integer,
                  is_pinned: T::Boolean,
                  note_type: String,
                  params: T.anything,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  entity_id: Integer,
                  group_id: Integer,
                  is_pinned: T::Boolean,
                  note_type: String,
                  params: T.anything,
                  responsible_user_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, account_id: nil, created_at: nil, created_by: nil, entity_id: nil, group_id: nil, is_pinned: nil, note_type: nil, params: nil, responsible_user_id: nil, updated_at: nil, updated_by: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentListByParentResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNotesByParentListByParentResponse::NoteListResponse,
            Amocrm::Models::EntityNotesByParentListByParentResponse::Problem
          )
        end
    end

    class EntityNotesByParentUpdateByParentIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :body_entity_id

      sig { params(body_entity_id: Integer).void }
      attr_writer :body_entity_id

      sig { returns(Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig { returns(T.nilable(String)) }
      attr_reader :note_type

      sig { params(note_type: String).void }
      attr_writer :note_type

      sig { returns(T.nilable(T.anything)) }
      attr_reader :params

      sig { params(params: T.anything).void }
      attr_writer :params

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_at

      sig { params(updated_at: Integer).void }
      attr_writer :updated_at

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_by

      sig { params(updated_by: Integer).void }
      attr_writer :updated_by

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::OrSymbol,
            body_entity_id: Integer,
            note_type: String,
            params: T.anything,
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::OrSymbol,
            body_entity_id: Integer,
            note_type: String,
            params: T.anything,
            updated_at: Integer,
            updated_by: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, body_entity_id: nil, note_type: nil, params: nil, updated_at: nil, updated_by: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(
              Symbol,
              Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::EntityNotesByParentUpdateByParentIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module EntityNotesByParentUpdateByParentIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::Variants
          ])
        end
        def variants; end
      end

      class NoteCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, entity_id: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::NoteCreateResponse,
            Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::Problem
          )
        end
    end

    class EntityNotesByParentUpdateByParentParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::EntityNotesByParentUpdateByParentParams::Body]) }
      attr_accessor :body

      sig { returns(Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::OrSymbol) }
      attr_accessor :entity_type

      sig do
        override
          .returns({
            entity_type:
              Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::OrSymbol,
            body:
              T::Array[Amocrm::EntityNotesByParentUpdateByParentParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            entity_type: Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::OrSymbol,
            body: T::Array[
              Amocrm::EntityNotesByParentUpdateByParentParams::Body::OrHash
            ],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(entity_type:, body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        # Note id
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :note_type

        sig { params(note_type: String).void }
        attr_writer :note_type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :params

        sig { params(params: T.anything).void }
        attr_writer :params

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              entity_id: Integer,
              note_type: String,
              params: T.anything,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              entity_id: Integer,
              note_type: String,
              params: T.anything,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            id:, # Note id
            entity_id: nil,
            note_type: nil,
            params: nil,
            updated_at: nil,
            updated_by: nil
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::EntityNotesByParentUpdateByParentParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::TaggedSymbol
            ])
          end
          def values; end
        end

        COMPANIES = T.let(
            :companies,
            Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::TaggedSymbol
          )

        CONTACTS = T.let(
            :contacts,
            Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::TaggedSymbol
          )

        CUSTOMERS = T.let(
            :customers,
            Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::TaggedSymbol
          )

        LEADS = T.let(
            :leads,
            Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(
              Symbol,
              Amocrm::EntityNotesByParentUpdateByParentParams::EntityType
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::EntityNotesByParentUpdateByParentParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module EntityNotesByParentUpdateByParentResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::EntityNotesByParentUpdateByParentResponse::Variants
          ])
        end
        def variants; end
      end

      class NoteCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded::Note
                ]
              ))
          end
          attr_reader :notes

          sig do
            params(
              notes: T::Array[
                  Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
            ).void
          end
          attr_writer :notes

          sig do
            override
              .returns({
                notes:
                  T::Array[
                    Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded::Note
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                notes: T::Array[
                  Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded::Note::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(notes: nil); end
          end

          class Note < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  entity_id: Integer,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, entity_id: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded::Note,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EntityNotesByParentUpdateByParentResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EntityNotesByParentUpdateByParentResponse::NoteCreateResponse,
            Amocrm::Models::EntityNotesByParentUpdateByParentResponse::Problem
          )
        end
    end

    class EventGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EventGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module EventGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EventGetByIDResponse::Variants]) }
        def variants; end
      end

      class Event < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(String)) }
        attr_reader :entity_type

        sig { params(entity_type: String).void }
        attr_writer :entity_type

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { returns(T.nilable(T.anything)) }
        attr_reader :value_after

        sig { params(value_after: T.anything).void }
        attr_writer :value_after

        sig { returns(T.nilable(T.anything)) }
        attr_reader :value_before

        sig { params(value_before: T.anything).void }
        attr_writer :value_before

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              entity_type: String,
              type: String,
              value_after: T.anything,
              value_before: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              created_at: Integer,
              created_by: Integer,
              entity_id: Integer,
              entity_type: String,
              type: String,
              value_after: T.anything,
              value_before: T.anything
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, created_at: nil, created_by: nil, entity_id: nil, entity_type: nil, type: nil, value_after: nil, value_before: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EventGetByIDResponse::Event,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EventGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EventGetByIDResponse::Event,
            Amocrm::Models::EventGetByIDResponse::Problem
          )
        end
    end

    class EventListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, limit: nil, page: nil, with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EventListParams, Amocrm::Internal::AnyHash)
        end
    end

    module EventListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EventListResponse::Variants]) }
        def variants; end
      end

      class EventListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EventListResponse::EventListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::EventListResponse::EventListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EventListResponse::EventListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EventListResponse::EventListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::EventListResponse::EventListResponse::Embedded::Event
                ]
              ))
          end
          attr_reader :events

          sig do
            params(
              events: T::Array[
                  Amocrm::Models::EventListResponse::EventListResponse::Embedded::Event::OrHash
                ]
            ).void
          end
          attr_writer :events

          sig do
            override
              .returns({
                events:
                  T::Array[
                    Amocrm::Models::EventListResponse::EventListResponse::Embedded::Event
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                events: T::Array[
                  Amocrm::Models::EventListResponse::EventListResponse::Embedded::Event::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(events: nil); end
          end

          class Event < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :type

            sig { params(type: String).void }
            attr_writer :type

            sig { returns(T.nilable(T.anything)) }
            attr_reader :value_after

            sig { params(value_after: T.anything).void }
            attr_writer :value_after

            sig { returns(T.nilable(T.anything)) }
            attr_reader :value_before

            sig { params(value_before: T.anything).void }
            attr_writer :value_before

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  created_at: Integer,
                  created_by: Integer,
                  entity_id: Integer,
                  entity_type: String,
                  type: String,
                  value_after: T.anything,
                  value_before: T.anything
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  created_at: Integer,
                  created_by: Integer,
                  entity_id: Integer,
                  entity_type: String,
                  type: String,
                  value_after: T.anything,
                  value_before: T.anything
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, created_at: nil, created_by: nil, entity_id: nil, entity_type: nil, type: nil, value_after: nil, value_before: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::EventListResponse::EventListResponse::Embedded::Event,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EventListResponse::EventListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EventListResponse::EventListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EventListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EventListResponse::EventListResponse,
            Amocrm::Models::EventListResponse::Problem
          )
        end
    end

    class EventListTypesParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :language_code

      sig { params(language_code: String).void }
      attr_writer :language_code

      sig { override.returns({ language_code: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig do
          params(
            language_code: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(language_code: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::EventListTypesParams, Amocrm::Internal::AnyHash)
        end
    end

    module EventListTypesResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::EventListTypesResponse::Variants]) }
        def variants; end
      end

      class EventTypesResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::EventListTypesResponse::EventTypesResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::EventListTypesResponse::EventTypesResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::EventListTypesResponse::EventTypesResponse::Embedded
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::EventListTypesResponse::EventTypesResponse::Embedded::OrHash
            ).returns(T.attached_class)
          end
          def new(_embedded: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Array[T.anything])) }
          attr_reader :types

          sig { params(types: T::Array[T.anything]).void }
          attr_writer :types

          sig { override.returns({ types: T::Array[T.anything] }) }
          def to_hash; end

          class << self
            sig { params(types: T::Array[T.anything]).returns(T.attached_class) }
            def new(types: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::EventListTypesResponse::EventTypesResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EventListTypesResponse::EventTypesResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::EventListTypesResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::EventListTypesResponse::EventTypesResponse,
            Amocrm::Models::EventListTypesResponse::Problem
          )
        end
    end

    class LeadCreateComplexParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::LeadCreateComplexParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::LeadCreateComplexParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::LeadCreateComplexParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        # Embedded entities (lead/contact/company/source)
        sig { returns(T.nilable(Amocrm::LeadCreateComplexParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::LeadCreateComplexParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :closed_at

        sig { params(closed_at: Integer).void }
        attr_writer :closed_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        # Custom fields payload
        sig do
          returns(T.nilable(
              T::Array[Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :loss_reason_id

        sig { params(loss_reason_id: Integer).void }
        attr_writer :loss_reason_id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :price

        sig { params(price: Integer).void }
        attr_writer :price

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :status_id

        sig { params(status_id: Integer).void }
        attr_writer :status_id

        # Tags to attach
        sig do
          returns(T.nilable(
              T::Array[Amocrm::LeadCreateComplexParams::Body::TagsToAdd]
            ))
        end
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::LeadCreateComplexParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        # Website visitor uid from tracking; links this lead to a site visit
        sig { returns(T.nilable(String)) }
        attr_reader :visitor_uid

        sig { params(visitor_uid: String).void }
        attr_writer :visitor_uid

        sig do
          override
            .returns({
              _embedded: Amocrm::LeadCreateComplexParams::Body::Embedded,
              closed_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T::Array[
                  Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue
                ],
              group_id: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              request_id: String,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add:
                T::Array[Amocrm::LeadCreateComplexParams::Body::TagsToAdd],
              updated_at: Integer,
              updated_by: Integer,
              visitor_uid: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::LeadCreateComplexParams::Body::Embedded::OrHash,
              closed_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T::Array[
                Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::OrHash
              ],
              group_id: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              request_id: String,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add: T::Array[
                Amocrm::LeadCreateComplexParams::Body::TagsToAdd::OrHash
              ],
              updated_at: Integer,
              updated_by: Integer,
              visitor_uid: String
            ).returns(T.attached_class)
          end
          def new(
            _embedded: nil, # Embedded entities (lead/contact/company/source)
            closed_at: nil,
            created_at: nil,
            created_by: nil,
            custom_fields_values: nil, # Custom fields payload
            group_id: nil,
            loss_reason_id: nil,
            name: nil,
            pipeline_id: nil,
            price: nil,
            request_id: nil, # Client-side request id
            responsible_user_id: nil,
            status_id: nil,
            tags_to_add: nil, # Tags to attach
            updated_at: nil,
            updated_by: nil,
            visitor_uid: nil # Website visitor uid from tracking; links this lead to a site visit
); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateComplexParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            returns(T.nilable(
                Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata
              ))
          end
          attr_reader :metadata

          sig { params(metadata: Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::OrHash).void }
          attr_writer :metadata

          sig { returns(T.nilable(Amocrm::LeadCreateComplexParams::Body::Embedded::Source)) }
          attr_reader :source

          sig { params(source: Amocrm::LeadCreateComplexParams::Body::Embedded::Source::OrHash).void }
          attr_writer :source

          sig do
            returns(T.nilable(
                T::Array[Amocrm::LeadCreateComplexParams::Body::Embedded::Tag]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Company
                  ],
                contacts:
                  T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Contact
                  ],
                metadata:
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata,
                source: Amocrm::LeadCreateComplexParams::Body::Embedded::Source,
                tags:
                  T::Array[Amocrm::LeadCreateComplexParams::Body::Embedded::Tag]
              })
          end
          def to_hash; end

          class << self
            # Embedded entities (lead/contact/company/source)
            sig do
              params(
                companies: T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::OrHash
                ],
                metadata: Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::OrHash,
                source: Amocrm::LeadCreateComplexParams::Body::Embedded::Source::OrHash,
                tags: T::Array[
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(companies: nil, contacts: nil, metadata: nil, source: nil, tags: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String).returns(T.attached_class) }
              def new(id: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            # Custom fields payload (same as contact create API)
            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue
                  ]
                ))
            end
            attr_reader :custom_fields_values

            sig do
              params(
                custom_fields_values: T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ]
              ).void
            end
            attr_writer :custom_fields_values

            sig { returns(T.nilable(String)) }
            attr_reader :first_name

            sig { params(first_name: String).void }
            attr_writer :first_name

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :last_name

            sig { params(last_name: String).void }
            attr_writer :last_name

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              override
                .returns({
                  id: Integer,
                  custom_fields_values:
                    T::Array[
                      Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue
                    ],
                  first_name: String,
                  last_name: String,
                  name: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  custom_fields_values: T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ],
                  first_name: String,
                  last_name: String,
                  name: String
                ).returns(T.attached_class)
              end
              def new(
                id: nil,
                custom_fields_values: nil, # Custom fields payload (same as contact create API)
                first_name: nil,
                last_name: nil,
                name: nil
); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::LeadCreateComplexParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Metadata < Amocrm::Internal::Type::BaseModel
            # Unsorted category
            sig do
              returns(T.nilable(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::OrSymbol
                ))
            end
            attr_reader :category

            sig do
              params(
                category: Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::OrSymbol
              ).void
            end
            attr_writer :category

            # Form id in your system (string or numeric)
            sig do
              returns(T.nilable(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::FormID::Variants
                ))
            end
            attr_reader :form_id

            sig { params(form_id: Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::FormID::Variants).void }
            attr_writer :form_id

            # Form name (shown in amoCRM)
            sig { returns(T.nilable(String)) }
            attr_reader :form_name

            sig { params(form_name: String).void }
            attr_writer :form_name

            # Page URL where form lives
            sig { returns(T.nilable(String)) }
            attr_reader :form_page

            sig { params(form_page: String).void }
            attr_writer :form_page

            # Unix timestamp (seconds) when the form was submitted
            sig { returns(T.nilable(Integer)) }
            attr_reader :form_sent_at

            sig { params(form_sent_at: Integer).void }
            attr_writer :form_sent_at

            # Form type code from amoCRM, use only if you know it
            sig { returns(T.nilable(Integer)) }
            attr_reader :form_type

            sig { params(form_type: Integer).void }
            attr_writer :form_type

            # IP address of the submitter
            sig { returns(T.nilable(String)) }
            attr_reader :ip

            sig { params(ip: String).void }
            attr_writer :ip

            # Referrer URL
            sig { returns(T.nilable(String)) }
            attr_reader :referer

            sig { params(referer: String).void }
            attr_writer :referer

            # Visitor uid from tracking, if you have it
            sig { returns(T.nilable(String)) }
            attr_reader :visitor_uid

            sig { params(visitor_uid: String).void }
            attr_writer :visitor_uid

            sig do
              override
                .returns({
                  category:
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::OrSymbol,
                  form_id:
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::FormID::Variants,
                  form_name: String,
                  form_page: String,
                  form_sent_at: Integer,
                  form_type: Integer,
                  ip: String,
                  referer: String,
                  visitor_uid: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  category: Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::OrSymbol,
                  form_id: Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::FormID::Variants,
                  form_name: String,
                  form_page: String,
                  form_sent_at: Integer,
                  form_type: Integer,
                  ip: String,
                  referer: String,
                  visitor_uid: String
                ).returns(T.attached_class)
              end
              def new(
                category: nil, # Unsorted category
                form_id: nil, # Form id in your system (string or numeric)
                form_name: nil, # Form name (shown in amoCRM)
                form_page: nil, # Page URL where form lives
                form_sent_at: nil, # Unix timestamp (seconds) when the form was submitted
                form_type: nil, # Form type code from amoCRM, use only if you know it
                ip: nil, # IP address of the submitter
                referer: nil, # Referrer URL
                visitor_uid: nil # Visitor uid from tracking, if you have it
); end
            end

            # Unsorted category
            module Category
              extend Amocrm::Internal::Type::Enum

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::TaggedSymbol
                  ])
                end
                def values; end
              end

              CHATS = T.let(
                  :chats,
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              FORMS = T.let(
                  :forms,
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              MAIL = T.let(
                  :mail,
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              SIP = T.let(
                  :sip,
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::Category
                  )
                end
            end

            # Form id in your system (string or numeric)
            module FormID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata::FormID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Metadata,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadCreateComplexParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            # External id in your system
            sig do
              returns(T.nilable(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig do
              params(
                external_id: Amocrm::LeadCreateComplexParams::Body::Embedded::Source::ExternalID::Variants
              ).void
            end
            attr_writer :external_id

            # Source type
            sig { returns(T.nilable(String)) }
            attr_reader :type

            sig { params(type: String).void }
            attr_writer :type

            sig do
              override
                .returns({
                  external_id:
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Source::ExternalID::Variants,
                  type: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  external_id: Amocrm::LeadCreateComplexParams::Body::Embedded::Source::ExternalID::Variants,
                  type: String
                ).returns(T.attached_class)
              end
              def new(
                external_id: nil, # External id in your system
                type: nil # Source type
); end
            end

            # External id in your system
            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateComplexParams::Body::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateComplexParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::LeadCreateComplexParams::Body,
              Amocrm::Internal::AnyHash
            )
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadCreateComplexParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::LeadCreateComplexParams, Amocrm::Internal::AnyHash)
        end
    end

    module LeadCreateComplexResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::LeadCreateComplexResponse::Variants]) }
        def variants; end
      end

      class LeadComplexCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                leads:
                  T::Array[
                    Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                leads: T::Array[
                  Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(leads: nil); end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :company_id

            sig { params(company_id: Integer).void }
            attr_writer :company_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :contact_id

            sig { params(contact_id: Integer).void }
            attr_writer :contact_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :merged

            sig { params(merged: T::Boolean).void }
            attr_writer :merged

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              override
                .returns({
                  id: Integer,
                  company_id: Integer,
                  contact_id: Integer,
                  merged: T::Boolean,
                  request_id: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  company_id: Integer,
                  contact_id: Integer,
                  merged: T::Boolean,
                  request_id: String
                ).returns(T.attached_class)
              end
              def new(id: nil, company_id: nil, contact_id: nil, merged: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadCreateComplexResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::LeadCreateComplexResponse::LeadComplexCreateResponse,
            Amocrm::Models::LeadCreateComplexResponse::Problem
          )
        end
    end

    class LeadCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::LeadCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::LeadCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::LeadCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        # Embedded entities (lead/contact/company/source)
        sig { returns(T.nilable(Amocrm::LeadCreateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::LeadCreateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :closed_at

        sig { params(closed_at: Integer).void }
        attr_writer :closed_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        # Custom fields payload
        sig do
          returns(T.nilable(
              T::Array[Amocrm::LeadCreateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::LeadCreateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :loss_reason_id

        sig { params(loss_reason_id: Integer).void }
        attr_writer :loss_reason_id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :price

        sig { params(price: Integer).void }
        attr_writer :price

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :status_id

        sig { params(status_id: Integer).void }
        attr_writer :status_id

        # Tags to attach
        sig { returns(T.nilable(T::Array[Amocrm::LeadCreateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::LeadCreateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        # Website visitor uid from tracking; links this lead to a site visit
        sig { returns(T.nilable(String)) }
        attr_reader :visitor_uid

        sig { params(visitor_uid: String).void }
        attr_writer :visitor_uid

        sig do
          override
            .returns({
              _embedded: Amocrm::LeadCreateParams::Body::Embedded,
              closed_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T::Array[Amocrm::LeadCreateParams::Body::CustomFieldsValue],
              group_id: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              request_id: String,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add: T::Array[Amocrm::LeadCreateParams::Body::TagsToAdd],
              updated_at: Integer,
              updated_by: Integer,
              visitor_uid: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::LeadCreateParams::Body::Embedded::OrHash,
              closed_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T::Array[
                Amocrm::LeadCreateParams::Body::CustomFieldsValue::OrHash
              ],
              group_id: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              request_id: String,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add: T::Array[Amocrm::LeadCreateParams::Body::TagsToAdd::OrHash],
              updated_at: Integer,
              updated_by: Integer,
              visitor_uid: String
            ).returns(T.attached_class)
          end
          def new(
            _embedded: nil, # Embedded entities (lead/contact/company/source)
            closed_at: nil,
            created_at: nil,
            created_by: nil,
            custom_fields_values: nil, # Custom fields payload
            group_id: nil,
            loss_reason_id: nil,
            name: nil,
            pipeline_id: nil,
            price: nil,
            request_id: nil, # Client-side request id
            responsible_user_id: nil,
            status_id: nil,
            tags_to_add: nil, # Tags to attach
            updated_at: nil,
            updated_by: nil,
            visitor_uid: nil # Website visitor uid from tracking; links this lead to a site visit
); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig { returns(T::Array[Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value]) }
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadCreateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::LeadCreateParams::Body::Embedded::Company]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::LeadCreateParams::Body::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[Amocrm::LeadCreateParams::Body::Embedded::Contact]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::LeadCreateParams::Body::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig { returns(T.nilable(Amocrm::LeadCreateParams::Body::Embedded::Metadata)) }
          attr_reader :metadata

          sig { params(metadata: Amocrm::LeadCreateParams::Body::Embedded::Metadata::OrHash).void }
          attr_writer :metadata

          sig { returns(T.nilable(Amocrm::LeadCreateParams::Body::Embedded::Source)) }
          attr_reader :source

          sig { params(source: Amocrm::LeadCreateParams::Body::Embedded::Source::OrHash).void }
          attr_writer :source

          sig { returns(T.nilable(T::Array[Amocrm::LeadCreateParams::Body::Embedded::Tag])) }
          attr_reader :tags

          sig { params(tags: T::Array[Amocrm::LeadCreateParams::Body::Embedded::Tag::OrHash]).void }
          attr_writer :tags

          sig do
            override
              .returns({
                companies:
                  T::Array[Amocrm::LeadCreateParams::Body::Embedded::Company],
                contacts:
                  T::Array[Amocrm::LeadCreateParams::Body::Embedded::Contact],
                metadata: Amocrm::LeadCreateParams::Body::Embedded::Metadata,
                source: Amocrm::LeadCreateParams::Body::Embedded::Source,
                tags: T::Array[Amocrm::LeadCreateParams::Body::Embedded::Tag]
              })
          end
          def to_hash; end

          class << self
            # Embedded entities (lead/contact/company/source)
            sig do
              params(
                companies: T::Array[
                  Amocrm::LeadCreateParams::Body::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::LeadCreateParams::Body::Embedded::Contact::OrHash
                ],
                metadata: Amocrm::LeadCreateParams::Body::Embedded::Metadata::OrHash,
                source: Amocrm::LeadCreateParams::Body::Embedded::Source::OrHash,
                tags: T::Array[Amocrm::LeadCreateParams::Body::Embedded::Tag::OrHash]
              ).returns(T.attached_class)
            end
            def new(companies: nil, contacts: nil, metadata: nil, source: nil, tags: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String).returns(T.attached_class) }
              def new(id: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateParams::Body::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            # Custom fields payload (same as contact create API)
            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue
                  ]
                ))
            end
            attr_reader :custom_fields_values

            sig do
              params(
                custom_fields_values: T::Array[
                    Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ]
              ).void
            end
            attr_writer :custom_fields_values

            sig { returns(T.nilable(String)) }
            attr_reader :first_name

            sig { params(first_name: String).void }
            attr_writer :first_name

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :last_name

            sig { params(last_name: String).void }
            attr_writer :last_name

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              override
                .returns({
                  id: Integer,
                  custom_fields_values:
                    T::Array[
                      Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue
                    ],
                  first_name: String,
                  last_name: String,
                  name: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  custom_fields_values: T::Array[
                    Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ],
                  first_name: String,
                  last_name: String,
                  name: String
                ).returns(T.attached_class)
              end
              def new(
                id: nil,
                custom_fields_values: nil, # Custom fields payload (same as contact create API)
                first_name: nil,
                last_name: nil,
                name: nil
); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::LeadCreateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateParams::Body::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Metadata < Amocrm::Internal::Type::BaseModel
            # Unsorted category
            sig do
              returns(T.nilable(
                  Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::OrSymbol
                ))
            end
            attr_reader :category

            sig { params(category: Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::OrSymbol).void }
            attr_writer :category

            # Form id in your system (string or numeric)
            sig do
              returns(T.nilable(
                  Amocrm::LeadCreateParams::Body::Embedded::Metadata::FormID::Variants
                ))
            end
            attr_reader :form_id

            sig { params(form_id: Amocrm::LeadCreateParams::Body::Embedded::Metadata::FormID::Variants).void }
            attr_writer :form_id

            # Form name (shown in amoCRM)
            sig { returns(T.nilable(String)) }
            attr_reader :form_name

            sig { params(form_name: String).void }
            attr_writer :form_name

            # Page URL where form lives
            sig { returns(T.nilable(String)) }
            attr_reader :form_page

            sig { params(form_page: String).void }
            attr_writer :form_page

            # Unix timestamp (seconds) when the form was submitted
            sig { returns(T.nilable(Integer)) }
            attr_reader :form_sent_at

            sig { params(form_sent_at: Integer).void }
            attr_writer :form_sent_at

            # Form type code from amoCRM, use only if you know it
            sig { returns(T.nilable(Integer)) }
            attr_reader :form_type

            sig { params(form_type: Integer).void }
            attr_writer :form_type

            # IP address of the submitter
            sig { returns(T.nilable(String)) }
            attr_reader :ip

            sig { params(ip: String).void }
            attr_writer :ip

            # Referrer URL
            sig { returns(T.nilable(String)) }
            attr_reader :referer

            sig { params(referer: String).void }
            attr_writer :referer

            # Visitor uid from tracking, if you have it
            sig { returns(T.nilable(String)) }
            attr_reader :visitor_uid

            sig { params(visitor_uid: String).void }
            attr_writer :visitor_uid

            sig do
              override
                .returns({
                  category:
                    Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::OrSymbol,
                  form_id:
                    Amocrm::LeadCreateParams::Body::Embedded::Metadata::FormID::Variants,
                  form_name: String,
                  form_page: String,
                  form_sent_at: Integer,
                  form_type: Integer,
                  ip: String,
                  referer: String,
                  visitor_uid: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  category: Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::OrSymbol,
                  form_id: Amocrm::LeadCreateParams::Body::Embedded::Metadata::FormID::Variants,
                  form_name: String,
                  form_page: String,
                  form_sent_at: Integer,
                  form_type: Integer,
                  ip: String,
                  referer: String,
                  visitor_uid: String
                ).returns(T.attached_class)
              end
              def new(
                category: nil, # Unsorted category
                form_id: nil, # Form id in your system (string or numeric)
                form_name: nil, # Form name (shown in amoCRM)
                form_page: nil, # Page URL where form lives
                form_sent_at: nil, # Unix timestamp (seconds) when the form was submitted
                form_type: nil, # Form type code from amoCRM, use only if you know it
                ip: nil, # IP address of the submitter
                referer: nil, # Referrer URL
                visitor_uid: nil # Visitor uid from tracking, if you have it
); end
            end

            # Unsorted category
            module Category
              extend Amocrm::Internal::Type::Enum

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                  ])
                end
                def values; end
              end

              CHATS = T.let(
                  :chats,
                  Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              FORMS = T.let(
                  :forms,
                  Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              MAIL = T.let(
                  :mail,
                  Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              SIP = T.let(
                  :sip,
                  Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::LeadCreateParams::Body::Embedded::Metadata::Category
                  )
                end
            end

            # Form id in your system (string or numeric)
            module FormID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateParams::Body::Embedded::Metadata::FormID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateParams::Body::Embedded::Metadata,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadCreateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            # External id in your system
            sig do
              returns(T.nilable(
                  Amocrm::LeadCreateParams::Body::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig { params(external_id: Amocrm::LeadCreateParams::Body::Embedded::Source::ExternalID::Variants).void }
            attr_writer :external_id

            # Source type
            sig { returns(T.nilable(String)) }
            attr_reader :type

            sig { params(type: String).void }
            attr_writer :type

            sig do
              override
                .returns({
                  external_id:
                    Amocrm::LeadCreateParams::Body::Embedded::Source::ExternalID::Variants,
                  type: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  external_id: Amocrm::LeadCreateParams::Body::Embedded::Source::ExternalID::Variants,
                  type: String
                ).returns(T.attached_class)
              end
              def new(
                external_id: nil, # External id in your system
                type: nil # Source type
); end
            end

            # External id in your system
            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadCreateParams::Body::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateParams::Body::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadCreateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::LeadCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadCreateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::LeadCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module LeadCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::LeadCreateResponse::Variants]) }
        def variants; end
      end

      class LeadCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                leads:
                  T::Array[
                    Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                leads: T::Array[
                  Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(leads: nil); end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::LeadCreateResponse::LeadCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadCreateResponse::LeadCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::LeadCreateResponse::LeadCreateResponse,
            Amocrm::Models::LeadCreateResponse::Problem
          )
        end
    end

    class LeadGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::LeadGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module LeadGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::LeadGetByIDResponse::Variants]) }
        def variants; end
      end

      class Lead < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::LeadGetByIDResponse::Lead::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :closed_at

        sig { params(closed_at: Integer).void }
        attr_writer :closed_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :closest_task_at

        sig { params(closest_task_at: Integer).void }
        attr_writer :closest_task_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue
              ]
            ))
        end
        attr_accessor :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_deleted

        sig { params(is_deleted: T::Boolean).void }
        attr_writer :is_deleted

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_price_modified_by_robot

        sig { params(is_price_modified_by_robot: T::Boolean).void }
        attr_writer :is_price_modified_by_robot

        sig { returns(T.nilable(Integer)) }
        attr_reader :labor_cost

        sig { params(labor_cost: Integer).void }
        attr_writer :labor_cost

        sig { returns(T.nilable(Integer)) }
        attr_reader :loss_reason_id

        sig { params(loss_reason_id: Integer).void }
        attr_writer :loss_reason_id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :price

        sig { params(price: Integer).void }
        attr_writer :price

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_accessor :score

        sig { returns(T.nilable(Integer)) }
        attr_reader :source_id

        sig { params(source_id: Integer).void }
        attr_writer :source_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :status_id

        sig { params(status_id: Integer).void }
        attr_writer :status_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig { returns(T.nilable(String)) }
        attr_reader :visitor_uid

        sig { params(visitor_uid: String).void }
        attr_writer :visitor_uid

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded,
              _links: T.anything,
              account_id: Integer,
              closed_at: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values:
                T.nilable(
                  T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue
                  ]
                ),
              group_id: Integer,
              is_deleted: T::Boolean,
              is_price_modified_by_robot: T::Boolean,
              labor_cost: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              responsible_user_id: Integer,
              score: T.nilable(Integer),
              source_id: Integer,
              status_id: Integer,
              updated_at: Integer,
              updated_by: Integer,
              visitor_uid: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::OrHash,
              _links: T.anything,
              account_id: Integer,
              closed_at: Integer,
              closest_task_at: Integer,
              created_at: Integer,
              created_by: Integer,
              custom_fields_values: T.nilable(
                T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::OrHash
                ]
              ),
              group_id: Integer,
              is_deleted: T::Boolean,
              is_price_modified_by_robot: T::Boolean,
              labor_cost: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              responsible_user_id: Integer,
              score: T.nilable(Integer),
              source_id: Integer,
              status_id: Integer,
              updated_at: Integer,
              updated_by: Integer,
              visitor_uid: String
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, account_id: nil, closed_at: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, group_id: nil, is_deleted: nil, is_price_modified_by_robot: nil, labor_cost: nil, loss_reason_id: nil, name: nil, pipeline_id: nil, price: nil, responsible_user_id: nil, score: nil, source_id: nil, status_id: nil, updated_at: nil, updated_by: nil, visitor_uid: nil); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig do
            returns(T::Array[
                Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value
              ])
          end
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::CatalogElement
                ]
              ))
          end
          attr_reader :catalog_elements

          sig do
            params(
              catalog_elements: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::CatalogElement::OrHash
                ]
            ).void
          end
          attr_writer :catalog_elements

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            returns(T.nilable(
                Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::LossReason
              ))
          end
          attr_reader :loss_reason

          sig { params(loss_reason: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::LossReason::OrHash).void }
          attr_writer :loss_reason

          sig do
            returns(T.nilable(
                Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source
              ))
          end
          attr_reader :source

          sig { params(source: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source::OrHash).void }
          attr_writer :source

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Tag
                ]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                catalog_elements:
                  T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::CatalogElement
                  ],
                companies:
                  T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Company
                  ],
                contacts:
                  T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Contact
                  ],
                loss_reason:
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::LossReason,
                source:
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source,
                tags:
                  T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Tag
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_elements: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::CatalogElement::OrHash
                ],
                companies: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Contact::OrHash
                ],
                loss_reason: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::LossReason::OrHash,
                source: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source::OrHash,
                tags: T::Array[
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(catalog_elements: nil, companies: nil, contacts: nil, loss_reason: nil, source: nil, tags: nil); end
          end

          class CatalogElement < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T.anything)) }
            attr_reader :metadata

            sig { params(metadata: T.anything).void }
            attr_writer :metadata

            sig { override.returns({ id: Integer, metadata: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, metadata: T.anything).returns(T.attached_class) }
              def new(id: nil, metadata: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::CatalogElement,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer).returns(T.attached_class) }
              def new(id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_main

            sig { params(is_main: T::Boolean).void }
            attr_writer :is_main

            sig { override.returns({ id: Integer, is_main: T::Boolean }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, is_main: T::Boolean).returns(T.attached_class) }
              def new(id: nil, is_main: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class LossReason < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String).returns(T.attached_class) }
              def new(id: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::LossReason,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::LeadGetByIDResponse::Lead::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            # External id in your system
            sig do
              returns(T.nilable(
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig do
              params(
                external_id: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source::ExternalID::Variants
              ).void
            end
            attr_writer :external_id

            # Source type
            sig { returns(T.nilable(String)) }
            attr_reader :type

            sig { params(type: String).void }
            attr_writer :type

            sig do
              override
                .returns({
                  external_id:
                    Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source::ExternalID::Variants,
                  type: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  external_id: Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source::ExternalID::Variants,
                  type: String
                ).returns(T.attached_class)
              end
              def new(
                external_id: nil, # External id in your system
                type: nil # Source type
); end
            end

            # External id in your system
            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadGetByIDResponse::Lead::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadGetByIDResponse::Lead,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::LeadGetByIDResponse::Lead,
            Amocrm::Models::LeadGetByIDResponse::Problem
          )
        end
    end

    class LeadListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Filtering parameters, see filters API
      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      # Pagination limit
      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      # Sorting, e.g. order[updated_at]=asc
      sig { returns(T.nilable(T.anything)) }
      attr_reader :order

      sig { params(order: T.anything).void }
      attr_writer :order

      # Pagination page
      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      # Search by query string or id
      sig { returns(T.nilable(Amocrm::LeadListParams::Query::Variants)) }
      attr_reader :query

      sig { params(query: Amocrm::LeadListParams::Query::Variants).void }
      attr_writer :query

      # Expand related entities; comma-separated values
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::LeadListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::LeadListParams::Query::Variants,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          filter: nil, # Filtering parameters, see filters API
          limit: nil, # Pagination limit
          order: nil, # Sorting, e.g. order[updated_at]=asc
          page: nil, # Pagination page
          query: nil, # Search by query string or id
          with: nil, # Expand related entities; comma-separated values
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::LeadListParams, Amocrm::Internal::AnyHash)
        end

      # Search by query string or id
      module Query
        extend Amocrm::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Amocrm::LeadListParams::Query::Variants]) }
          def variants; end
        end

        Variants = T.type_alias { T.any(String, Integer) }
      end
    end

    module LeadListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::LeadListResponse::Variants]) }
        def variants; end
      end

      class LeadListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::LeadListResponse::LeadListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::LeadListResponse::LeadListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                leads:
                  T::Array[
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                leads: T::Array[
                  Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(leads: nil); end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :closed_at

            sig { params(closed_at: Integer).void }
            attr_writer :closed_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :closest_task_at

            sig { params(closest_task_at: Integer).void }
            attr_writer :closest_task_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue
                  ]
                ))
            end
            attr_accessor :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_deleted

            sig { params(is_deleted: T::Boolean).void }
            attr_writer :is_deleted

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_price_modified_by_robot

            sig { params(is_price_modified_by_robot: T::Boolean).void }
            attr_writer :is_price_modified_by_robot

            sig { returns(T.nilable(Integer)) }
            attr_reader :labor_cost

            sig { params(labor_cost: Integer).void }
            attr_writer :labor_cost

            sig { returns(T.nilable(Integer)) }
            attr_reader :loss_reason_id

            sig { params(loss_reason_id: Integer).void }
            attr_writer :loss_reason_id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :price

            sig { params(price: Integer).void }
            attr_writer :price

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig { returns(T.nilable(Integer)) }
            attr_accessor :score

            sig { returns(T.nilable(Integer)) }
            attr_reader :source_id

            sig { params(source_id: Integer).void }
            attr_writer :source_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig { returns(T.nilable(String)) }
            attr_reader :visitor_uid

            sig { params(visitor_uid: String).void }
            attr_writer :visitor_uid

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  closed_at: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue
                      ]
                    ),
                  group_id: Integer,
                  is_deleted: T::Boolean,
                  is_price_modified_by_robot: T::Boolean,
                  labor_cost: Integer,
                  loss_reason_id: Integer,
                  name: String,
                  pipeline_id: Integer,
                  price: Integer,
                  responsible_user_id: Integer,
                  score: T.nilable(Integer),
                  source_id: Integer,
                  status_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer,
                  visitor_uid: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  closed_at: Integer,
                  closest_task_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T.nilable(
                    T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::OrHash
                    ]
                  ),
                  group_id: Integer,
                  is_deleted: T::Boolean,
                  is_price_modified_by_robot: T::Boolean,
                  labor_cost: Integer,
                  loss_reason_id: Integer,
                  name: String,
                  pipeline_id: Integer,
                  price: Integer,
                  responsible_user_id: Integer,
                  score: T.nilable(Integer),
                  source_id: Integer,
                  status_id: Integer,
                  updated_at: Integer,
                  updated_by: Integer,
                  visitor_uid: String
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, closed_at: nil, closest_task_at: nil, created_at: nil, created_by: nil, custom_fields_values: nil, group_id: nil, is_deleted: nil, is_price_modified_by_robot: nil, labor_cost: nil, loss_reason_id: nil, name: nil, pipeline_id: nil, price: nil, responsible_user_id: nil, score: nil, source_id: nil, status_id: nil, updated_at: nil, updated_by: nil, visitor_uid: nil); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::CatalogElement
                    ]
                  ))
              end
              attr_reader :catalog_elements

              sig do
                params(
                  catalog_elements: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::CatalogElement::OrHash
                    ]
                ).void
              end
              attr_writer :catalog_elements

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Company
                    ]
                  ))
              end
              attr_reader :companies

              sig do
                params(
                  companies: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Company::OrHash
                    ]
                ).void
              end
              attr_writer :companies

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Contact
                    ]
                  ))
              end
              attr_reader :contacts

              sig do
                params(
                  contacts: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Contact::OrHash
                    ]
                ).void
              end
              attr_writer :contacts

              sig do
                returns(T.nilable(
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::LossReason
                  ))
              end
              attr_reader :loss_reason

              sig do
                params(
                  loss_reason: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::LossReason::OrHash
                ).void
              end
              attr_writer :loss_reason

              sig do
                returns(T.nilable(
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source
                  ))
              end
              attr_reader :source

              sig do
                params(
                  source: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source::OrHash
                ).void
              end
              attr_writer :source

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Tag
                    ]
                  ))
              end
              attr_reader :tags

              sig do
                params(
                  tags: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Tag::OrHash
                    ]
                ).void
              end
              attr_writer :tags

              sig do
                override
                  .returns({
                    catalog_elements:
                      T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::CatalogElement
                      ],
                    companies:
                      T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Company
                      ],
                    contacts:
                      T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Contact
                      ],
                    loss_reason:
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::LossReason,
                    source:
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source,
                    tags:
                      T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Tag
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_elements: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::CatalogElement::OrHash
                    ],
                    companies: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Company::OrHash
                    ],
                    contacts: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Contact::OrHash
                    ],
                    loss_reason: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::LossReason::OrHash,
                    source: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source::OrHash,
                    tags: T::Array[
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Tag::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(catalog_elements: nil, companies: nil, contacts: nil, loss_reason: nil, source: nil, tags: nil); end
              end

              class CatalogElement < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(T.anything)) }
                attr_reader :metadata

                sig { params(metadata: T.anything).void }
                attr_writer :metadata

                sig { override.returns({ id: Integer, metadata: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, metadata: T.anything).returns(T.attached_class) }
                  def new(id: nil, metadata: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::CatalogElement,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Company < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer).returns(T.attached_class) }
                  def new(id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Company,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Contact < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(T::Boolean)) }
                attr_reader :is_main

                sig { params(is_main: T::Boolean).void }
                attr_writer :is_main

                sig { override.returns({ id: Integer, is_main: T::Boolean }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, is_main: T::Boolean).returns(T.attached_class) }
                  def new(id: nil, is_main: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Contact,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class LossReason < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { override.returns({ id: Integer, name: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, name: String).returns(T.attached_class) }
                  def new(id: nil, name: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::LossReason,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Source < Amocrm::Internal::Type::BaseModel
                # External id in your system
                sig do
                  returns(T.nilable(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source::ExternalID::Variants
                    ))
                end
                attr_reader :external_id

                sig do
                  params(
                    external_id: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source::ExternalID::Variants
                  ).void
                end
                attr_writer :external_id

                # Source type
                sig { returns(T.nilable(String)) }
                attr_reader :type

                sig { params(type: String).void }
                attr_writer :type

                sig do
                  override
                    .returns({
                      external_id:
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source::ExternalID::Variants,
                      type: String
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      external_id: Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source::ExternalID::Variants,
                      type: String
                    ).returns(T.attached_class)
                  end
                  def new(
                    external_id: nil, # External id in your system
                    type: nil # Source type
); end
                end

                # External id in your system
                module ExternalID
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source::ExternalID::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Source,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Tag < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :color

                sig { params(color: String).void }
                attr_writer :color

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { override.returns({ id: Integer, color: String, name: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
                  def new(id: nil, color: nil, name: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead::Embedded::Tag,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadListResponse::LeadListResponse::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::LeadListResponse::LeadListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadListResponse::LeadListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::LeadListResponse::LeadListResponse,
            Amocrm::Models::LeadListResponse::Problem
          )
        end
    end

    class LeadUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Amocrm::LeadUpdateByIDParams::Embedded)) }
      attr_reader :_embedded

      sig { params(_embedded: Amocrm::LeadUpdateByIDParams::Embedded::OrHash).void }
      attr_writer :_embedded

      sig { returns(T.nilable(Integer)) }
      attr_reader :closed_at

      sig { params(closed_at: Integer).void }
      attr_writer :closed_at

      # Custom fields payload
      sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateByIDParams::CustomFieldsValue])) }
      attr_reader :custom_fields_values

      sig { params(custom_fields_values: T::Array[Amocrm::LeadUpdateByIDParams::CustomFieldsValue::OrHash]).void }
      attr_writer :custom_fields_values

      sig { returns(T.nilable(Integer)) }
      attr_reader :group_id

      sig { params(group_id: Integer).void }
      attr_writer :group_id

      sig { returns(T.nilable(Integer)) }
      attr_reader :loss_reason_id

      sig { params(loss_reason_id: Integer).void }
      attr_writer :loss_reason_id

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(Integer)) }
      attr_reader :pipeline_id

      sig { params(pipeline_id: Integer).void }
      attr_writer :pipeline_id

      sig { returns(T.nilable(Integer)) }
      attr_reader :price

      sig { params(price: Integer).void }
      attr_writer :price

      sig { returns(T.nilable(Integer)) }
      attr_reader :responsible_user_id

      sig { params(responsible_user_id: Integer).void }
      attr_writer :responsible_user_id

      sig { returns(T.nilable(Integer)) }
      attr_reader :status_id

      sig { params(status_id: Integer).void }
      attr_writer :status_id

      # Tags to attach
      sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateByIDParams::TagsToAdd])) }
      attr_reader :tags_to_add

      sig { params(tags_to_add: T::Array[Amocrm::LeadUpdateByIDParams::TagsToAdd::OrHash]).void }
      attr_writer :tags_to_add

      # Tags to delete
      sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateByIDParams::TagsToDelete])) }
      attr_reader :tags_to_delete

      sig { params(tags_to_delete: T::Array[Amocrm::LeadUpdateByIDParams::TagsToDelete::OrHash]).void }
      attr_writer :tags_to_delete

      sig { returns(T.nilable(Integer)) }
      attr_reader :updated_at

      sig { params(updated_at: Integer).void }
      attr_writer :updated_at

      sig do
        override
          .returns({
            _embedded: Amocrm::LeadUpdateByIDParams::Embedded,
            closed_at: Integer,
            custom_fields_values:
              T::Array[Amocrm::LeadUpdateByIDParams::CustomFieldsValue],
            group_id: Integer,
            loss_reason_id: Integer,
            name: String,
            pipeline_id: Integer,
            price: Integer,
            responsible_user_id: Integer,
            status_id: Integer,
            tags_to_add: T::Array[Amocrm::LeadUpdateByIDParams::TagsToAdd],
            tags_to_delete:
              T::Array[Amocrm::LeadUpdateByIDParams::TagsToDelete],
            updated_at: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            _embedded: Amocrm::LeadUpdateByIDParams::Embedded::OrHash,
            closed_at: Integer,
            custom_fields_values: T::Array[Amocrm::LeadUpdateByIDParams::CustomFieldsValue::OrHash],
            group_id: Integer,
            loss_reason_id: Integer,
            name: String,
            pipeline_id: Integer,
            price: Integer,
            responsible_user_id: Integer,
            status_id: Integer,
            tags_to_add: T::Array[Amocrm::LeadUpdateByIDParams::TagsToAdd::OrHash],
            tags_to_delete: T::Array[Amocrm::LeadUpdateByIDParams::TagsToDelete::OrHash],
            updated_at: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          _embedded: nil,
          closed_at: nil,
          custom_fields_values: nil, # Custom fields payload
          group_id: nil,
          loss_reason_id: nil,
          name: nil,
          pipeline_id: nil,
          price: nil,
          responsible_user_id: nil,
          status_id: nil,
          tags_to_add: nil, # Tags to attach
          tags_to_delete: nil, # Tags to delete
          updated_at: nil,
          request_options: {}
); end
      end

      class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
        # Field code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(String)) }
        attr_reader :field_code

        sig { params(field_code: String).void }
        attr_writer :field_code

        # Use either field_id or field_code (e.g. PHONE/EMAIL)
        sig { returns(T.nilable(Integer)) }
        attr_reader :field_id

        sig { params(field_id: Integer).void }
        attr_writer :field_id

        # Values for the field (multiple values allowed)
        sig { returns(T::Array[Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value]) }
        attr_accessor :values

        sig do
          override
            .returns({
              values:
                T::Array[
                  Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value
                ],
              field_code: String,
              field_id: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              values: T::Array[
                Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value::OrHash
              ],
              field_code: String,
              field_id: Integer
            ).returns(T.attached_class)
          end
          def new(
            values:, # Values for the field (multiple values allowed)
            field_code: nil, # Field code (e.g. PHONE/EMAIL)
            field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::LeadUpdateByIDParams::CustomFieldsValue,
              Amocrm::Internal::AnyHash
            )
          end

        class Value < Amocrm::Internal::Type::BaseModel
          # Option code for list/select custom fields (if you use code instead of id)
          sig { returns(T.nilable(String)) }
          attr_reader :enum_code

          sig { params(enum_code: String).void }
          attr_writer :enum_code

          # Option id for list/select custom fields (one of predefined options)
          sig { returns(T.nilable(Integer)) }
          attr_reader :enum_id

          sig { params(enum_id: Integer).void }
          attr_writer :enum_id

          sig { returns(Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value::Value::Variants) }
          attr_accessor :value

          sig do
            override
              .returns({
                value:
                  Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                value: Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value::Value::Variants,
                enum_code: String,
                enum_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              value:,
              enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
              enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value,
                Amocrm::Internal::AnyHash
              )
            end

          module Value
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::LeadUpdateByIDParams::CustomFieldsValue::Value::Value::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
          end
        end
      end

      class Embedded < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Company])) }
        attr_reader :companies

        sig { params(companies: T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Company::OrHash]).void }
        attr_writer :companies

        sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Contact])) }
        attr_reader :contacts

        sig { params(contacts: T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Contact::OrHash]).void }
        attr_writer :contacts

        sig { returns(T.nilable(Amocrm::LeadUpdateByIDParams::Embedded::Metadata)) }
        attr_reader :metadata

        sig { params(metadata: Amocrm::LeadUpdateByIDParams::Embedded::Metadata::OrHash).void }
        attr_writer :metadata

        sig { returns(T.nilable(Amocrm::LeadUpdateByIDParams::Embedded::Source)) }
        attr_reader :source

        sig { params(source: Amocrm::LeadUpdateByIDParams::Embedded::Source::OrHash).void }
        attr_writer :source

        sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Tag])) }
        attr_reader :tags

        sig { params(tags: T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Tag::OrHash]).void }
        attr_writer :tags

        sig do
          override
            .returns({
              companies:
                T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Company],
              contacts:
                T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Contact],
              metadata: Amocrm::LeadUpdateByIDParams::Embedded::Metadata,
              source: Amocrm::LeadUpdateByIDParams::Embedded::Source,
              tags: T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Tag]
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              companies: T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Company::OrHash],
              contacts: T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Contact::OrHash],
              metadata: Amocrm::LeadUpdateByIDParams::Embedded::Metadata::OrHash,
              source: Amocrm::LeadUpdateByIDParams::Embedded::Source::OrHash,
              tags: T::Array[Amocrm::LeadUpdateByIDParams::Embedded::Tag::OrHash]
            ).returns(T.attached_class)
          end
          def new(companies: nil, contacts: nil, metadata: nil, source: nil, tags: nil); end
        end

        class Company < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, name: String).returns(T.attached_class) }
            def new(id: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateByIDParams::Embedded::Company,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class Contact < Amocrm::Internal::Type::BaseModel
          # Custom fields payload (same as contact create API)
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue
                ]
              ))
          end
          attr_reader :custom_fields_values

          sig do
            params(
              custom_fields_values: T::Array[
                  Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::OrHash
                ]
            ).void
          end
          attr_writer :custom_fields_values

          sig { returns(T.nilable(String)) }
          attr_reader :first_name

          sig { params(first_name: String).void }
          attr_writer :first_name

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :last_name

          sig { params(last_name: String).void }
          attr_writer :last_name

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig do
            override
              .returns({
                id: Integer,
                custom_fields_values:
                  T::Array[
                    Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue
                  ],
                first_name: String,
                last_name: String,
                name: String
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                id: Integer,
                custom_fields_values: T::Array[
                  Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::OrHash
                ],
                first_name: String,
                last_name: String,
                name: String
              ).returns(T.attached_class)
            end
            def new(
              id: nil,
              custom_fields_values: nil, # Custom fields payload (same as contact create API)
              first_name: nil,
              last_name: nil,
              name: nil
); end
          end

          class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
            # Field code (e.g. PHONE/EMAIL)
            sig { returns(T.nilable(String)) }
            attr_reader :field_code

            sig { params(field_code: String).void }
            attr_writer :field_code

            # Use either field_id or field_code (e.g. PHONE/EMAIL)
            sig { returns(T.nilable(Integer)) }
            attr_reader :field_id

            sig { params(field_id: Integer).void }
            attr_writer :field_id

            # Values for the field (multiple values allowed)
            sig do
              returns(T::Array[
                  Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value
                ])
            end
            attr_accessor :values

            sig do
              override
                .returns({
                  values:
                    T::Array[
                      Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value
                    ],
                  field_code: String,
                  field_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  values: T::Array[
                    Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value::OrHash
                  ],
                  field_code: String,
                  field_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                values:, # Values for the field (multiple values allowed)
                field_code: nil, # Field code (e.g. PHONE/EMAIL)
                field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue,
                  Amocrm::Internal::AnyHash
                )
              end

            class Value < Amocrm::Internal::Type::BaseModel
              # Option code for list/select custom fields (if you use code instead of id)
              sig { returns(T.nilable(String)) }
              attr_reader :enum_code

              sig { params(enum_code: String).void }
              attr_writer :enum_code

              # Option id for list/select custom fields (one of predefined options)
              sig { returns(T.nilable(Integer)) }
              attr_reader :enum_id

              sig { params(enum_id: Integer).void }
              attr_writer :enum_id

              sig do
                returns(Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value::Value::Variants)
              end
              attr_accessor :value

              sig do
                override
                  .returns({
                    value:
                      Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                    enum_code: String,
                    enum_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    value: Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                    enum_code: String,
                    enum_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  value:,
                  enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                  enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value,
                    Amocrm::Internal::AnyHash
                  )
                end

              module Value
                extend Amocrm::Internal::Type::Union

                class << self
                  sig do
                    override
                      .returns(T::Array[
                      Amocrm::LeadUpdateByIDParams::Embedded::Contact::CustomFieldsValue::Value::Value::Variants
                    ])
                  end
                  def variants; end
                end

                Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
              end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateByIDParams::Embedded::Contact,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class Metadata < Amocrm::Internal::Type::BaseModel
          # Unsorted category
          sig do
            returns(T.nilable(
                Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::OrSymbol
              ))
          end
          attr_reader :category

          sig { params(category: Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::OrSymbol).void }
          attr_writer :category

          # Form id in your system (string or numeric)
          sig do
            returns(T.nilable(
                Amocrm::LeadUpdateByIDParams::Embedded::Metadata::FormID::Variants
              ))
          end
          attr_reader :form_id

          sig { params(form_id: Amocrm::LeadUpdateByIDParams::Embedded::Metadata::FormID::Variants).void }
          attr_writer :form_id

          # Form name (shown in amoCRM)
          sig { returns(T.nilable(String)) }
          attr_reader :form_name

          sig { params(form_name: String).void }
          attr_writer :form_name

          # Page URL where form lives
          sig { returns(T.nilable(String)) }
          attr_reader :form_page

          sig { params(form_page: String).void }
          attr_writer :form_page

          # Unix timestamp (seconds) when the form was submitted
          sig { returns(T.nilable(Integer)) }
          attr_reader :form_sent_at

          sig { params(form_sent_at: Integer).void }
          attr_writer :form_sent_at

          # Form type code from amoCRM, use only if you know it
          sig { returns(T.nilable(Integer)) }
          attr_reader :form_type

          sig { params(form_type: Integer).void }
          attr_writer :form_type

          # IP address of the submitter
          sig { returns(T.nilable(String)) }
          attr_reader :ip

          sig { params(ip: String).void }
          attr_writer :ip

          # Referrer URL
          sig { returns(T.nilable(String)) }
          attr_reader :referer

          sig { params(referer: String).void }
          attr_writer :referer

          # Visitor uid from tracking, if you have it
          sig { returns(T.nilable(String)) }
          attr_reader :visitor_uid

          sig { params(visitor_uid: String).void }
          attr_writer :visitor_uid

          sig do
            override
              .returns({
                category:
                  Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::OrSymbol,
                form_id:
                  Amocrm::LeadUpdateByIDParams::Embedded::Metadata::FormID::Variants,
                form_name: String,
                form_page: String,
                form_sent_at: Integer,
                form_type: Integer,
                ip: String,
                referer: String,
                visitor_uid: String
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                category: Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::OrSymbol,
                form_id: Amocrm::LeadUpdateByIDParams::Embedded::Metadata::FormID::Variants,
                form_name: String,
                form_page: String,
                form_sent_at: Integer,
                form_type: Integer,
                ip: String,
                referer: String,
                visitor_uid: String
              ).returns(T.attached_class)
            end
            def new(
              category: nil, # Unsorted category
              form_id: nil, # Form id in your system (string or numeric)
              form_name: nil, # Form name (shown in amoCRM)
              form_page: nil, # Page URL where form lives
              form_sent_at: nil, # Unix timestamp (seconds) when the form was submitted
              form_type: nil, # Form type code from amoCRM, use only if you know it
              ip: nil, # IP address of the submitter
              referer: nil, # Referrer URL
              visitor_uid: nil # Visitor uid from tracking, if you have it
); end
          end

          # Unsorted category
          module Category
            extend Amocrm::Internal::Type::Enum

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::TaggedSymbol
                ])
              end
              def values; end
            end

            CHATS = T.let(
                :chats,
                Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::TaggedSymbol
              )

            FORMS = T.let(
                :forms,
                Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::TaggedSymbol
              )

            MAIL = T.let(
                :mail,
                Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::TaggedSymbol
              )

            OrSymbol = T.type_alias { T.any(Symbol, String) }

            SIP = T.let(
                :sip,
                Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category::TaggedSymbol
              )

            TaggedSymbol = T.type_alias do
                T.all(
                  Symbol,
                  Amocrm::LeadUpdateByIDParams::Embedded::Metadata::Category
                )
              end
          end

          # Form id in your system (string or numeric)
          module FormID
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::LeadUpdateByIDParams::Embedded::Metadata::FormID::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer) }
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateByIDParams::Embedded::Metadata,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::LeadUpdateByIDParams::Embedded,
              Amocrm::Internal::AnyHash
            )
          end

        class Source < Amocrm::Internal::Type::BaseModel
          # External id in your system
          sig do
            returns(T.nilable(
                Amocrm::LeadUpdateByIDParams::Embedded::Source::ExternalID::Variants
              ))
          end
          attr_reader :external_id

          sig { params(external_id: Amocrm::LeadUpdateByIDParams::Embedded::Source::ExternalID::Variants).void }
          attr_writer :external_id

          # Source type
          sig { returns(T.nilable(String)) }
          attr_reader :type

          sig { params(type: String).void }
          attr_writer :type

          sig do
            override
              .returns({
                external_id:
                  Amocrm::LeadUpdateByIDParams::Embedded::Source::ExternalID::Variants,
                type: String
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                external_id: Amocrm::LeadUpdateByIDParams::Embedded::Source::ExternalID::Variants,
                type: String
              ).returns(T.attached_class)
            end
            def new(
              external_id: nil, # External id in your system
              type: nil # Source type
); end
          end

          # External id in your system
          module ExternalID
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::LeadUpdateByIDParams::Embedded::Source::ExternalID::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateByIDParams::Embedded::Source,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class Tag < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateByIDParams::Embedded::Tag,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::LeadUpdateByIDParams, Amocrm::Internal::AnyHash)
        end

      class TagsToAdd < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::LeadUpdateByIDParams::TagsToAdd,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TagsToDelete < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { override.returns({ id: Integer, color: String, name: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
          def new(id: nil, color: nil, name: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::LeadUpdateByIDParams::TagsToDelete,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    module LeadUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::LeadUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class LeadUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                leads:
                  T::Array[
                    Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                leads: T::Array[
                  Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(leads: nil); end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::LeadUpdateByIDResponse::LeadUpdateResponse,
            Amocrm::Models::LeadUpdateByIDResponse::Problem
          )
        end
    end

    class LeadUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::LeadUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::LeadUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::LeadUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::LeadUpdateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::LeadUpdateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :closed_at

        sig { params(closed_at: Integer).void }
        attr_writer :closed_at

        # Custom fields payload
        sig do
          returns(T.nilable(
              T::Array[Amocrm::LeadUpdateParams::Body::CustomFieldsValue]
            ))
        end
        attr_reader :custom_fields_values

        sig do
          params(
            custom_fields_values: T::Array[
                Amocrm::LeadUpdateParams::Body::CustomFieldsValue::OrHash
              ]
          ).void
        end
        attr_writer :custom_fields_values

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        # Lead id
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(Integer)) }
        attr_reader :loss_reason_id

        sig { params(loss_reason_id: Integer).void }
        attr_writer :loss_reason_id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :price

        sig { params(price: Integer).void }
        attr_writer :price

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :status_id

        sig { params(status_id: Integer).void }
        attr_writer :status_id

        # Tags to attach
        sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateParams::Body::TagsToAdd])) }
        attr_reader :tags_to_add

        sig { params(tags_to_add: T::Array[Amocrm::LeadUpdateParams::Body::TagsToAdd::OrHash]).void }
        attr_writer :tags_to_add

        # Tags to delete
        sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateParams::Body::TagsToDelete])) }
        attr_reader :tags_to_delete

        sig { params(tags_to_delete: T::Array[Amocrm::LeadUpdateParams::Body::TagsToDelete::OrHash]).void }
        attr_writer :tags_to_delete

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::LeadUpdateParams::Body::Embedded,
              closed_at: Integer,
              custom_fields_values:
                T::Array[Amocrm::LeadUpdateParams::Body::CustomFieldsValue],
              group_id: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add: T::Array[Amocrm::LeadUpdateParams::Body::TagsToAdd],
              tags_to_delete:
                T::Array[Amocrm::LeadUpdateParams::Body::TagsToDelete],
              updated_at: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::LeadUpdateParams::Body::Embedded::OrHash,
              closed_at: Integer,
              custom_fields_values: T::Array[
                Amocrm::LeadUpdateParams::Body::CustomFieldsValue::OrHash
              ],
              group_id: Integer,
              loss_reason_id: Integer,
              name: String,
              pipeline_id: Integer,
              price: Integer,
              responsible_user_id: Integer,
              status_id: Integer,
              tags_to_add: T::Array[Amocrm::LeadUpdateParams::Body::TagsToAdd::OrHash],
              tags_to_delete: T::Array[Amocrm::LeadUpdateParams::Body::TagsToDelete::OrHash],
              updated_at: Integer
            ).returns(T.attached_class)
          end
          def new(
            id:, # Lead id
            _embedded: nil,
            closed_at: nil,
            custom_fields_values: nil, # Custom fields payload
            group_id: nil,
            loss_reason_id: nil,
            name: nil,
            pipeline_id: nil,
            price: nil,
            responsible_user_id: nil,
            status_id: nil,
            tags_to_add: nil, # Tags to attach
            tags_to_delete: nil, # Tags to delete
            updated_at: nil
); end
        end

        class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
          # Field code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(String)) }
          attr_reader :field_code

          sig { params(field_code: String).void }
          attr_writer :field_code

          # Use either field_id or field_code (e.g. PHONE/EMAIL)
          sig { returns(T.nilable(Integer)) }
          attr_reader :field_id

          sig { params(field_id: Integer).void }
          attr_writer :field_id

          # Values for the field (multiple values allowed)
          sig { returns(T::Array[Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value]) }
          attr_accessor :values

          sig do
            override
              .returns({
                values:
                  T::Array[
                    Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value
                  ],
                field_code: String,
                field_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                values: T::Array[
                  Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value::OrHash
                ],
                field_code: String,
                field_id: Integer
              ).returns(T.attached_class)
            end
            def new(
              values:, # Values for the field (multiple values allowed)
              field_code: nil, # Field code (e.g. PHONE/EMAIL)
              field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateParams::Body::CustomFieldsValue,
                Amocrm::Internal::AnyHash
              )
            end

          class Value < Amocrm::Internal::Type::BaseModel
            # Option code for list/select custom fields (if you use code instead of id)
            sig { returns(T.nilable(String)) }
            attr_reader :enum_code

            sig { params(enum_code: String).void }
            attr_writer :enum_code

            # Option id for list/select custom fields (one of predefined options)
            sig { returns(T.nilable(Integer)) }
            attr_reader :enum_id

            sig { params(enum_id: Integer).void }
            attr_writer :enum_id

            sig { returns(Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value::Value::Variants) }
            attr_accessor :value

            sig do
              override
                .returns({
                  value:
                    Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  value: Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value::Value::Variants,
                  enum_code: String,
                  enum_id: Integer
                ).returns(T.attached_class)
              end
              def new(
                value:,
                enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value,
                  Amocrm::Internal::AnyHash
                )
              end

            module Value
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadUpdateParams::Body::CustomFieldsValue::Value::Value::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end
          end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Company]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::LeadUpdateParams::Body::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Contact]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::LeadUpdateParams::Body::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig { returns(T.nilable(Amocrm::LeadUpdateParams::Body::Embedded::Metadata)) }
          attr_reader :metadata

          sig { params(metadata: Amocrm::LeadUpdateParams::Body::Embedded::Metadata::OrHash).void }
          attr_writer :metadata

          sig { returns(T.nilable(Amocrm::LeadUpdateParams::Body::Embedded::Source)) }
          attr_reader :source

          sig { params(source: Amocrm::LeadUpdateParams::Body::Embedded::Source::OrHash).void }
          attr_writer :source

          sig { returns(T.nilable(T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Tag])) }
          attr_reader :tags

          sig { params(tags: T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Tag::OrHash]).void }
          attr_writer :tags

          sig do
            override
              .returns({
                companies:
                  T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Company],
                contacts:
                  T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Contact],
                metadata: Amocrm::LeadUpdateParams::Body::Embedded::Metadata,
                source: Amocrm::LeadUpdateParams::Body::Embedded::Source,
                tags: T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Tag]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                companies: T::Array[
                  Amocrm::LeadUpdateParams::Body::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::LeadUpdateParams::Body::Embedded::Contact::OrHash
                ],
                metadata: Amocrm::LeadUpdateParams::Body::Embedded::Metadata::OrHash,
                source: Amocrm::LeadUpdateParams::Body::Embedded::Source::OrHash,
                tags: T::Array[Amocrm::LeadUpdateParams::Body::Embedded::Tag::OrHash]
              ).returns(T.attached_class)
            end
            def new(companies: nil, contacts: nil, metadata: nil, source: nil, tags: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String).returns(T.attached_class) }
              def new(id: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadUpdateParams::Body::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            # Custom fields payload (same as contact create API)
            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue
                  ]
                ))
            end
            attr_reader :custom_fields_values

            sig do
              params(
                custom_fields_values: T::Array[
                    Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ]
              ).void
            end
            attr_writer :custom_fields_values

            sig { returns(T.nilable(String)) }
            attr_reader :first_name

            sig { params(first_name: String).void }
            attr_writer :first_name

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :last_name

            sig { params(last_name: String).void }
            attr_writer :last_name

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              override
                .returns({
                  id: Integer,
                  custom_fields_values:
                    T::Array[
                      Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue
                    ],
                  first_name: String,
                  last_name: String,
                  name: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  custom_fields_values: T::Array[
                    Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ],
                  first_name: String,
                  last_name: String,
                  name: String
                ).returns(T.attached_class)
              end
              def new(
                id: nil,
                custom_fields_values: nil, # Custom fields payload (same as contact create API)
                first_name: nil,
                last_name: nil,
                name: nil
); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::LeadUpdateParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadUpdateParams::Body::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Metadata < Amocrm::Internal::Type::BaseModel
            # Unsorted category
            sig do
              returns(T.nilable(
                  Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::OrSymbol
                ))
            end
            attr_reader :category

            sig { params(category: Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::OrSymbol).void }
            attr_writer :category

            # Form id in your system (string or numeric)
            sig do
              returns(T.nilable(
                  Amocrm::LeadUpdateParams::Body::Embedded::Metadata::FormID::Variants
                ))
            end
            attr_reader :form_id

            sig { params(form_id: Amocrm::LeadUpdateParams::Body::Embedded::Metadata::FormID::Variants).void }
            attr_writer :form_id

            # Form name (shown in amoCRM)
            sig { returns(T.nilable(String)) }
            attr_reader :form_name

            sig { params(form_name: String).void }
            attr_writer :form_name

            # Page URL where form lives
            sig { returns(T.nilable(String)) }
            attr_reader :form_page

            sig { params(form_page: String).void }
            attr_writer :form_page

            # Unix timestamp (seconds) when the form was submitted
            sig { returns(T.nilable(Integer)) }
            attr_reader :form_sent_at

            sig { params(form_sent_at: Integer).void }
            attr_writer :form_sent_at

            # Form type code from amoCRM, use only if you know it
            sig { returns(T.nilable(Integer)) }
            attr_reader :form_type

            sig { params(form_type: Integer).void }
            attr_writer :form_type

            # IP address of the submitter
            sig { returns(T.nilable(String)) }
            attr_reader :ip

            sig { params(ip: String).void }
            attr_writer :ip

            # Referrer URL
            sig { returns(T.nilable(String)) }
            attr_reader :referer

            sig { params(referer: String).void }
            attr_writer :referer

            # Visitor uid from tracking, if you have it
            sig { returns(T.nilable(String)) }
            attr_reader :visitor_uid

            sig { params(visitor_uid: String).void }
            attr_writer :visitor_uid

            sig do
              override
                .returns({
                  category:
                    Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::OrSymbol,
                  form_id:
                    Amocrm::LeadUpdateParams::Body::Embedded::Metadata::FormID::Variants,
                  form_name: String,
                  form_page: String,
                  form_sent_at: Integer,
                  form_type: Integer,
                  ip: String,
                  referer: String,
                  visitor_uid: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  category: Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::OrSymbol,
                  form_id: Amocrm::LeadUpdateParams::Body::Embedded::Metadata::FormID::Variants,
                  form_name: String,
                  form_page: String,
                  form_sent_at: Integer,
                  form_type: Integer,
                  ip: String,
                  referer: String,
                  visitor_uid: String
                ).returns(T.attached_class)
              end
              def new(
                category: nil, # Unsorted category
                form_id: nil, # Form id in your system (string or numeric)
                form_name: nil, # Form name (shown in amoCRM)
                form_page: nil, # Page URL where form lives
                form_sent_at: nil, # Unix timestamp (seconds) when the form was submitted
                form_type: nil, # Form type code from amoCRM, use only if you know it
                ip: nil, # IP address of the submitter
                referer: nil, # Referrer URL
                visitor_uid: nil # Visitor uid from tracking, if you have it
); end
            end

            # Unsorted category
            module Category
              extend Amocrm::Internal::Type::Enum

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                  ])
                end
                def values; end
              end

              CHATS = T.let(
                  :chats,
                  Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              FORMS = T.let(
                  :forms,
                  Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              MAIL = T.let(
                  :mail,
                  Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              SIP = T.let(
                  :sip,
                  Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Amocrm::LeadUpdateParams::Body::Embedded::Metadata::Category
                  )
                end
            end

            # Form id in your system (string or numeric)
            module FormID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadUpdateParams::Body::Embedded::Metadata::FormID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadUpdateParams::Body::Embedded::Metadata,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            # External id in your system
            sig do
              returns(T.nilable(
                  Amocrm::LeadUpdateParams::Body::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig { params(external_id: Amocrm::LeadUpdateParams::Body::Embedded::Source::ExternalID::Variants).void }
            attr_writer :external_id

            # Source type
            sig { returns(T.nilable(String)) }
            attr_reader :type

            sig { params(type: String).void }
            attr_writer :type

            sig do
              override
                .returns({
                  external_id:
                    Amocrm::LeadUpdateParams::Body::Embedded::Source::ExternalID::Variants,
                  type: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  external_id: Amocrm::LeadUpdateParams::Body::Embedded::Source::ExternalID::Variants,
                  type: String
                ).returns(T.attached_class)
              end
              def new(
                external_id: nil, # External id in your system
                type: nil # Source type
); end
            end

            # External id in your system
            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::LeadUpdateParams::Body::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadUpdateParams::Body::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::LeadUpdateParams::Body::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::LeadUpdateParams::Body, Amocrm::Internal::AnyHash)
          end

        class TagsToAdd < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateParams::Body::TagsToAdd,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class TagsToDelete < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :color

          sig { params(color: String).void }
          attr_writer :color

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { override.returns({ id: Integer, color: String, name: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
            def new(id: nil, color: nil, name: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::LeadUpdateParams::Body::TagsToDelete,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::LeadUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module LeadUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::LeadUpdateResponse::Variants]) }
        def variants; end
      end

      class LeadUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                leads:
                  T::Array[
                    Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                leads: T::Array[
                  Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(leads: nil); end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::LeadUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::LeadUpdateResponse::LeadUpdateResponse,
            Amocrm::Models::LeadUpdateResponse::Problem
          )
        end
    end

    class PipelineCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::PipelineCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::PipelineCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::PipelineCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::PipelineCreateParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::PipelineCreateParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_main

        sig { params(is_main: T::Boolean).void }
        attr_writer :is_main

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_unsorted_on

        sig { params(is_unsorted_on: T::Boolean).void }
        attr_writer :is_unsorted_on

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          override
            .returns({
              name: String,
              _embedded: Amocrm::PipelineCreateParams::Body::Embedded,
              is_main: T::Boolean,
              is_unsorted_on: T::Boolean,
              request_id: String,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              _embedded: Amocrm::PipelineCreateParams::Body::Embedded::OrHash,
              is_main: T::Boolean,
              is_unsorted_on: T::Boolean,
              request_id: String,
              sort: Integer
            ).returns(T.attached_class)
          end
          def new(name:, _embedded: nil, is_main: nil, is_unsorted_on: nil, request_id: nil, sort: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[Amocrm::PipelineCreateParams::Body::Embedded::Status]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::PipelineCreateParams::Body::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[Amocrm::PipelineCreateParams::Body::Embedded::Status]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::PipelineCreateParams::Body::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::PipelineCreateParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::PipelineCreateParams::Body::Embedded::Status::Description
                  ]
                ))
            end
            attr_reader :descriptions

            sig do
              params(
                descriptions: T::Array[
                    Amocrm::PipelineCreateParams::Body::Embedded::Status::Description::OrHash
                  ]
              ).void
            end
            attr_writer :descriptions

            sig { returns(String) }
            attr_accessor :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig do
              override
                .returns({
                  name: String,
                  color: String,
                  descriptions:
                    T::Array[
                      Amocrm::PipelineCreateParams::Body::Embedded::Status::Description
                    ],
                  request_id: String,
                  sort: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  name: String,
                  color: String,
                  descriptions: T::Array[
                    Amocrm::PipelineCreateParams::Body::Embedded::Status::Description::OrHash
                  ],
                  request_id: String,
                  sort: Integer
                ).returns(T.attached_class)
              end
              def new(name:, color: nil, descriptions: nil, request_id: nil, sort: nil); end
            end

            class Description < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(String)) }
              attr_reader :description

              sig { params(description: String).void }
              attr_writer :description

              sig { returns(T.nilable(Integer)) }
              attr_reader :id

              sig { params(id: Integer).void }
              attr_writer :id

              sig { returns(T.nilable(String)) }
              attr_reader :level

              sig { params(level: String).void }
              attr_writer :level

              sig { override.returns({ id: Integer, description: String, level: String }) }
              def to_hash; end

              class << self
                sig { params(id: Integer, description: String, level: String).returns(T.attached_class) }
                def new(id: nil, description: nil, level: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::PipelineCreateParams::Body::Embedded::Status::Description,
                    Amocrm::Internal::AnyHash
                  )
                end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::PipelineCreateParams::Body::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::PipelineCreateParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineCreateResponse::Variants]) }
        def variants; end
      end

      class PipelineCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded::Pipeline
                ]
              ))
          end
          attr_reader :pipelines

          sig do
            params(
              pipelines: T::Array[
                  Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded::Pipeline::OrHash
                ]
            ).void
          end
          attr_writer :pipelines

          sig do
            override
              .returns({
                pipelines:
                  T::Array[
                    Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded::Pipeline
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                pipelines: T::Array[
                  Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded::Pipeline::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(pipelines: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Pipeline < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse::Embedded::Pipeline,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineCreateResponse::PipelineCreateResponse,
            Amocrm::Models::PipelineCreateResponse::Problem
          )
        end
    end

    class PipelineDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineDeleteByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineDeleteByIDResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineDeleteByIDResponse::EmptyResponse,
            Amocrm::Models::PipelineDeleteByIDResponse::Problem
          )
        end
    end

    class PipelineGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineGetByIDResponse::Variants]) }
        def variants; end
      end

      class Pipeline < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_archive

        sig { params(is_archive: T::Boolean).void }
        attr_writer :is_archive

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_main

        sig { params(is_main: T::Boolean).void }
        attr_writer :is_main

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_unsorted_on

        sig { params(is_unsorted_on: T::Boolean).void }
        attr_writer :is_unsorted_on

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          override
            .returns({
              id: Integer,
              _embedded:
                Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded,
              _links: T.anything,
              account_id: Integer,
              is_archive: T::Boolean,
              is_main: T::Boolean,
              is_unsorted_on: T::Boolean,
              name: String,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::OrHash,
              _links: T.anything,
              account_id: Integer,
              is_archive: T::Boolean,
              is_main: T::Boolean,
              is_unsorted_on: T::Boolean,
              name: String,
              sort: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, account_id: nil, is_archive: nil, is_main: nil, is_unsorted_on: nil, name: nil, sort: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status
                ]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[
                    Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status::Description
                  ]
                ))
            end
            attr_accessor :descriptions

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_editable

            sig { params(is_editable: T::Boolean).void }
            attr_writer :is_editable

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig { returns(T.nilable(Integer)) }
            attr_reader :type

            sig { params(type: Integer).void }
            attr_writer :type

            sig do
              override
                .returns({
                  id: Integer,
                  account_id: Integer,
                  color: String,
                  descriptions:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status::Description
                      ]
                    ),
                  is_editable: T::Boolean,
                  name: String,
                  pipeline_id: Integer,
                  sort: Integer,
                  type: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  account_id: Integer,
                  color: String,
                  descriptions: T.nilable(
                    T::Array[
                      Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status::Description::OrHash
                    ]
                  ),
                  is_editable: T::Boolean,
                  name: String,
                  pipeline_id: Integer,
                  sort: Integer,
                  type: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, account_id: nil, color: nil, descriptions: nil, is_editable: nil, name: nil, pipeline_id: nil, sort: nil, type: nil); end
            end

            class Description < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(Integer)) }
              attr_reader :account_id

              sig { params(account_id: Integer).void }
              attr_writer :account_id

              sig { returns(T.nilable(Integer)) }
              attr_reader :created_at

              sig { params(created_at: Integer).void }
              attr_writer :created_at

              sig { returns(T.nilable(Integer)) }
              attr_reader :created_by

              sig { params(created_by: Integer).void }
              attr_writer :created_by

              sig { returns(T.nilable(String)) }
              attr_reader :description

              sig { params(description: String).void }
              attr_writer :description

              sig { returns(T.nilable(Integer)) }
              attr_reader :id

              sig { params(id: Integer).void }
              attr_writer :id

              sig { returns(T.nilable(String)) }
              attr_reader :level

              sig { params(level: String).void }
              attr_writer :level

              sig { returns(T.nilable(Integer)) }
              attr_reader :pipeline_id

              sig { params(pipeline_id: Integer).void }
              attr_writer :pipeline_id

              sig { returns(T.nilable(Integer)) }
              attr_reader :status_id

              sig { params(status_id: Integer).void }
              attr_writer :status_id

              sig { returns(T.nilable(Integer)) }
              attr_reader :updated_at

              sig { params(updated_at: Integer).void }
              attr_writer :updated_at

              sig { returns(T.nilable(Integer)) }
              attr_reader :updated_by

              sig { params(updated_by: Integer).void }
              attr_writer :updated_by

              sig do
                override
                  .returns({
                    id: Integer,
                    account_id: Integer,
                    created_at: Integer,
                    created_by: Integer,
                    description: String,
                    level: String,
                    pipeline_id: Integer,
                    status_id: Integer,
                    updated_at: Integer,
                    updated_by: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    id: Integer,
                    account_id: Integer,
                    created_at: Integer,
                    created_by: Integer,
                    description: String,
                    level: String,
                    pipeline_id: Integer,
                    status_id: Integer,
                    updated_at: Integer,
                    updated_by: Integer
                  ).returns(T.attached_class)
                end
                def new(id: nil, account_id: nil, created_at: nil, created_by: nil, description: nil, level: nil, pipeline_id: nil, status_id: nil, updated_at: nil, updated_by: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status::Description,
                    Amocrm::Internal::AnyHash
                  )
                end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineGetByIDResponse::Pipeline::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineGetByIDResponse::Pipeline,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineGetByIDResponse::Pipeline,
            Amocrm::Models::PipelineGetByIDResponse::Problem
          )
        end
    end

    class PipelineListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineListParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineListResponse::Variants]) }
        def variants; end
      end

      class PipelineListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline
                ]
              ))
          end
          attr_reader :pipelines

          sig do
            params(
              pipelines: T::Array[
                  Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::OrHash
                ]
            ).void
          end
          attr_writer :pipelines

          sig do
            override
              .returns({
                pipelines:
                  T::Array[
                    Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                pipelines: T::Array[
                  Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(pipelines: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Pipeline < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_archive

            sig { params(is_archive: T::Boolean).void }
            attr_writer :is_archive

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_main

            sig { params(is_main: T::Boolean).void }
            attr_writer :is_main

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_unsorted_on

            sig { params(is_unsorted_on: T::Boolean).void }
            attr_writer :is_unsorted_on

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  is_archive: T::Boolean,
                  is_main: T::Boolean,
                  is_unsorted_on: T::Boolean,
                  name: String,
                  sort: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  is_archive: T::Boolean,
                  is_main: T::Boolean,
                  is_unsorted_on: T::Boolean,
                  name: String,
                  sort: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, account_id: nil, is_archive: nil, is_main: nil, is_unsorted_on: nil, name: nil, sort: nil); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status
                    ]
                  ))
              end
              attr_reader :statuses

              sig do
                params(
                  statuses: T::Array[
                      Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status::OrHash
                    ]
                ).void
              end
              attr_writer :statuses

              sig do
                override
                  .returns({
                    statuses:
                      T::Array[
                        Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    statuses: T::Array[
                      Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(statuses: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Status < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :account_id

                sig { params(account_id: Integer).void }
                attr_writer :account_id

                sig { returns(T.nilable(String)) }
                attr_reader :color

                sig { params(color: String).void }
                attr_writer :color

                sig do
                  returns(T.nilable(
                      T::Array[
                        Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status::Description
                      ]
                    ))
                end
                attr_accessor :descriptions

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(T::Boolean)) }
                attr_reader :is_editable

                sig { params(is_editable: T::Boolean).void }
                attr_writer :is_editable

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { returns(T.nilable(Integer)) }
                attr_reader :pipeline_id

                sig { params(pipeline_id: Integer).void }
                attr_writer :pipeline_id

                sig { returns(T.nilable(Integer)) }
                attr_reader :sort

                sig { params(sort: Integer).void }
                attr_writer :sort

                sig { returns(T.nilable(Integer)) }
                attr_reader :type

                sig { params(type: Integer).void }
                attr_writer :type

                sig do
                  override
                    .returns({
                      id: Integer,
                      account_id: Integer,
                      color: String,
                      descriptions:
                        T.nilable(
                          T::Array[
                            Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status::Description
                          ]
                        ),
                      is_editable: T::Boolean,
                      name: String,
                      pipeline_id: Integer,
                      sort: Integer,
                      type: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      id: Integer,
                      account_id: Integer,
                      color: String,
                      descriptions: T.nilable(
                        T::Array[
                          Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status::Description::OrHash
                        ]
                      ),
                      is_editable: T::Boolean,
                      name: String,
                      pipeline_id: Integer,
                      sort: Integer,
                      type: Integer
                    ).returns(T.attached_class)
                  end
                  def new(id: nil, account_id: nil, color: nil, descriptions: nil, is_editable: nil, name: nil, pipeline_id: nil, sort: nil, type: nil); end
                end

                class Description < Amocrm::Internal::Type::BaseModel
                  sig { returns(T.nilable(Integer)) }
                  attr_reader :account_id

                  sig { params(account_id: Integer).void }
                  attr_writer :account_id

                  sig { returns(T.nilable(Integer)) }
                  attr_reader :created_at

                  sig { params(created_at: Integer).void }
                  attr_writer :created_at

                  sig { returns(T.nilable(Integer)) }
                  attr_reader :created_by

                  sig { params(created_by: Integer).void }
                  attr_writer :created_by

                  sig { returns(T.nilable(String)) }
                  attr_reader :description

                  sig { params(description: String).void }
                  attr_writer :description

                  sig { returns(T.nilable(Integer)) }
                  attr_reader :id

                  sig { params(id: Integer).void }
                  attr_writer :id

                  sig { returns(T.nilable(String)) }
                  attr_reader :level

                  sig { params(level: String).void }
                  attr_writer :level

                  sig { returns(T.nilable(Integer)) }
                  attr_reader :pipeline_id

                  sig { params(pipeline_id: Integer).void }
                  attr_writer :pipeline_id

                  sig { returns(T.nilable(Integer)) }
                  attr_reader :status_id

                  sig { params(status_id: Integer).void }
                  attr_writer :status_id

                  sig { returns(T.nilable(Integer)) }
                  attr_reader :updated_at

                  sig { params(updated_at: Integer).void }
                  attr_writer :updated_at

                  sig { returns(T.nilable(Integer)) }
                  attr_reader :updated_by

                  sig { params(updated_by: Integer).void }
                  attr_writer :updated_by

                  sig do
                    override
                      .returns({
                        id: Integer,
                        account_id: Integer,
                        created_at: Integer,
                        created_by: Integer,
                        description: String,
                        level: String,
                        pipeline_id: Integer,
                        status_id: Integer,
                        updated_at: Integer,
                        updated_by: Integer
                      })
                  end
                  def to_hash; end

                  class << self
                    sig do
                      params(
                        id: Integer,
                        account_id: Integer,
                        created_at: Integer,
                        created_by: Integer,
                        description: String,
                        level: String,
                        pipeline_id: Integer,
                        status_id: Integer,
                        updated_at: Integer,
                        updated_by: Integer
                      ).returns(T.attached_class)
                    end
                    def new(id: nil, account_id: nil, created_at: nil, created_by: nil, description: nil, level: nil, pipeline_id: nil, status_id: nil, updated_at: nil, updated_by: nil); end
                  end

                  OrHash = T.type_alias do
                      T.any(
                        Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status::Description,
                        Amocrm::Internal::AnyHash
                      )
                    end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline::Embedded::Status,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineListResponse::PipelineListResponse::Embedded::Pipeline,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineListResponse::PipelineListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineListResponse::PipelineListResponse,
            Amocrm::Models::PipelineListResponse::Problem
          )
        end
    end

    class PipelineStatusCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::PipelineStatusCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::PipelineStatusCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::PipelineStatusCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig do
          returns(T.nilable(
              T::Array[Amocrm::PipelineStatusCreateParams::Body::Description]
            ))
        end
        attr_reader :descriptions

        sig do
          params(
            descriptions: T::Array[
                Amocrm::PipelineStatusCreateParams::Body::Description::OrHash
              ]
          ).void
        end
        attr_writer :descriptions

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          override
            .returns({
              name: String,
              color: String,
              descriptions:
                T::Array[Amocrm::PipelineStatusCreateParams::Body::Description],
              request_id: String,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              color: String,
              descriptions: T::Array[
                Amocrm::PipelineStatusCreateParams::Body::Description::OrHash
              ],
              request_id: String,
              sort: Integer
            ).returns(T.attached_class)
          end
          def new(name:, color: nil, descriptions: nil, request_id: nil, sort: nil); end
        end

        class Description < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :description

          sig { params(description: String).void }
          attr_writer :description

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :level

          sig { params(level: String).void }
          attr_writer :level

          sig { override.returns({ id: Integer, description: String, level: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, description: String, level: String).returns(T.attached_class) }
            def new(id: nil, description: nil, level: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::PipelineStatusCreateParams::Body::Description,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::PipelineStatusCreateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineStatusCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineStatusCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineStatusCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class StatusCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded::Status
                ]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[
                    Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded::Status
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineStatusCreateResponse::StatusCreateResponse,
            Amocrm::Models::PipelineStatusCreateResponse::Problem
          )
        end
    end

    class PipelineStatusDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :pipeline_id

      sig { override.returns({ pipeline_id: Integer, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(pipeline_id: Integer, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(pipeline_id:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::PipelineStatusDeleteByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module PipelineStatusDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineStatusDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusDeleteByIDResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineStatusDeleteByIDResponse::EmptyResponse,
            Amocrm::Models::PipelineStatusDeleteByIDResponse::Problem
          )
        end
    end

    class PipelineStatusGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :pipeline_id

      # Expand related entities; comma-separated values (e.g. descriptions).
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            pipeline_id: Integer,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            pipeline_id: Integer,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          pipeline_id:,
          with: nil, # Expand related entities; comma-separated values (e.g. descriptions).
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineStatusGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineStatusGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineStatusGetByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Status < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::PipelineStatusGetByIDResponse::Status::Description
              ]
            ))
        end
        attr_accessor :descriptions

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_editable

        sig { params(is_editable: T::Boolean).void }
        attr_writer :is_editable

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { returns(T.nilable(Integer)) }
        attr_reader :type

        sig { params(type: Integer).void }
        attr_writer :type

        sig do
          override
            .returns({
              id: Integer,
              account_id: Integer,
              color: String,
              descriptions:
                T.nilable(
                  T::Array[
                    Amocrm::Models::PipelineStatusGetByIDResponse::Status::Description
                  ]
                ),
              is_editable: T::Boolean,
              name: String,
              pipeline_id: Integer,
              sort: Integer,
              type: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              account_id: Integer,
              color: String,
              descriptions: T.nilable(
                T::Array[
                  Amocrm::Models::PipelineStatusGetByIDResponse::Status::Description::OrHash
                ]
              ),
              is_editable: T::Boolean,
              name: String,
              pipeline_id: Integer,
              sort: Integer,
              type: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, account_id: nil, color: nil, descriptions: nil, is_editable: nil, name: nil, pipeline_id: nil, sort: nil, type: nil); end
        end

        class Description < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(Integer)) }
          attr_reader :account_id

          sig { params(account_id: Integer).void }
          attr_writer :account_id

          sig { returns(T.nilable(Integer)) }
          attr_reader :created_at

          sig { params(created_at: Integer).void }
          attr_writer :created_at

          sig { returns(T.nilable(Integer)) }
          attr_reader :created_by

          sig { params(created_by: Integer).void }
          attr_writer :created_by

          sig { returns(T.nilable(String)) }
          attr_reader :description

          sig { params(description: String).void }
          attr_writer :description

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :level

          sig { params(level: String).void }
          attr_writer :level

          sig { returns(T.nilable(Integer)) }
          attr_reader :pipeline_id

          sig { params(pipeline_id: Integer).void }
          attr_writer :pipeline_id

          sig { returns(T.nilable(Integer)) }
          attr_reader :status_id

          sig { params(status_id: Integer).void }
          attr_writer :status_id

          sig { returns(T.nilable(Integer)) }
          attr_reader :updated_at

          sig { params(updated_at: Integer).void }
          attr_writer :updated_at

          sig { returns(T.nilable(Integer)) }
          attr_reader :updated_by

          sig { params(updated_by: Integer).void }
          attr_writer :updated_by

          sig do
            override
              .returns({
                id: Integer,
                account_id: Integer,
                created_at: Integer,
                created_by: Integer,
                description: String,
                level: String,
                pipeline_id: Integer,
                status_id: Integer,
                updated_at: Integer,
                updated_by: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                id: Integer,
                account_id: Integer,
                created_at: Integer,
                created_by: Integer,
                description: String,
                level: String,
                pipeline_id: Integer,
                status_id: Integer,
                updated_at: Integer,
                updated_by: Integer
              ).returns(T.attached_class)
            end
            def new(id: nil, account_id: nil, created_at: nil, created_by: nil, description: nil, level: nil, pipeline_id: nil, status_id: nil, updated_at: nil, updated_by: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineStatusGetByIDResponse::Status::Description,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusGetByIDResponse::Status,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineStatusGetByIDResponse::Status,
            Amocrm::Models::PipelineStatusGetByIDResponse::Problem
          )
        end
    end

    class PipelineStatusListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Expand related entities; comma-separated values (e.g. descriptions).
      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(
          with: nil, # Expand related entities; comma-separated values (e.g. descriptions).
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineStatusListParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineStatusListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineStatusListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class StatusListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status
                ]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[
                    Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status::Description
                  ]
                ))
            end
            attr_accessor :descriptions

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_editable

            sig { params(is_editable: T::Boolean).void }
            attr_writer :is_editable

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig { returns(T.nilable(Integer)) }
            attr_reader :type

            sig { params(type: Integer).void }
            attr_writer :type

            sig do
              override
                .returns({
                  id: Integer,
                  account_id: Integer,
                  color: String,
                  descriptions:
                    T.nilable(
                      T::Array[
                        Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status::Description
                      ]
                    ),
                  is_editable: T::Boolean,
                  name: String,
                  pipeline_id: Integer,
                  sort: Integer,
                  type: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  account_id: Integer,
                  color: String,
                  descriptions: T.nilable(
                    T::Array[
                      Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status::Description::OrHash
                    ]
                  ),
                  is_editable: T::Boolean,
                  name: String,
                  pipeline_id: Integer,
                  sort: Integer,
                  type: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, account_id: nil, color: nil, descriptions: nil, is_editable: nil, name: nil, pipeline_id: nil, sort: nil, type: nil); end
            end

            class Description < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(Integer)) }
              attr_reader :account_id

              sig { params(account_id: Integer).void }
              attr_writer :account_id

              sig { returns(T.nilable(Integer)) }
              attr_reader :created_at

              sig { params(created_at: Integer).void }
              attr_writer :created_at

              sig { returns(T.nilable(Integer)) }
              attr_reader :created_by

              sig { params(created_by: Integer).void }
              attr_writer :created_by

              sig { returns(T.nilable(String)) }
              attr_reader :description

              sig { params(description: String).void }
              attr_writer :description

              sig { returns(T.nilable(Integer)) }
              attr_reader :id

              sig { params(id: Integer).void }
              attr_writer :id

              sig { returns(T.nilable(String)) }
              attr_reader :level

              sig { params(level: String).void }
              attr_writer :level

              sig { returns(T.nilable(Integer)) }
              attr_reader :pipeline_id

              sig { params(pipeline_id: Integer).void }
              attr_writer :pipeline_id

              sig { returns(T.nilable(Integer)) }
              attr_reader :status_id

              sig { params(status_id: Integer).void }
              attr_writer :status_id

              sig { returns(T.nilable(Integer)) }
              attr_reader :updated_at

              sig { params(updated_at: Integer).void }
              attr_writer :updated_at

              sig { returns(T.nilable(Integer)) }
              attr_reader :updated_by

              sig { params(updated_by: Integer).void }
              attr_writer :updated_by

              sig do
                override
                  .returns({
                    id: Integer,
                    account_id: Integer,
                    created_at: Integer,
                    created_by: Integer,
                    description: String,
                    level: String,
                    pipeline_id: Integer,
                    status_id: Integer,
                    updated_at: Integer,
                    updated_by: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    id: Integer,
                    account_id: Integer,
                    created_at: Integer,
                    created_by: Integer,
                    description: String,
                    level: String,
                    pipeline_id: Integer,
                    status_id: Integer,
                    updated_at: Integer,
                    updated_by: Integer
                  ).returns(T.attached_class)
                end
                def new(id: nil, account_id: nil, created_at: nil, created_by: nil, description: nil, level: nil, pipeline_id: nil, status_id: nil, updated_at: nil, updated_by: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status::Description,
                    Amocrm::Internal::AnyHash
                  )
                end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineStatusListResponse::StatusListResponse::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusListResponse::StatusListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineStatusListResponse::StatusListResponse,
            Amocrm::Models::PipelineStatusListResponse::Problem
          )
        end
    end

    class PipelineStatusUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :color

      sig { params(color: String).void }
      attr_writer :color

      sig { returns(T.nilable(
            T::Array[Amocrm::PipelineStatusUpdateByIDParams::Description]
          )) }
      attr_reader :descriptions

      sig do
        params(
          descriptions: T::Array[
              Amocrm::PipelineStatusUpdateByIDParams::Description::OrHash
            ]
        ).void
      end
      attr_writer :descriptions

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(Integer) }
      attr_accessor :pipeline_id

      sig { returns(T.nilable(String)) }
      attr_reader :request_id

      sig { params(request_id: String).void }
      attr_writer :request_id

      sig { returns(T.nilable(Integer)) }
      attr_reader :sort

      sig { params(sort: Integer).void }
      attr_writer :sort

      sig do
        override
          .returns({
            pipeline_id: Integer,
            color: String,
            descriptions:
              T::Array[Amocrm::PipelineStatusUpdateByIDParams::Description],
            name: String,
            request_id: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            pipeline_id: Integer,
            color: String,
            descriptions: T::Array[
              Amocrm::PipelineStatusUpdateByIDParams::Description::OrHash
            ],
            name: String,
            request_id: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(pipeline_id:, color: nil, descriptions: nil, name: nil, request_id: nil, sort: nil, request_options: {}); end
      end

      class Description < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :description

        sig { params(description: String).void }
        attr_writer :description

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :level

        sig { params(level: String).void }
        attr_writer :level

        sig { override.returns({ id: Integer, description: String, level: String }) }
        def to_hash; end

        class << self
          sig { params(id: Integer, description: String, level: String).returns(T.attached_class) }
          def new(id: nil, description: nil, level: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::PipelineStatusUpdateByIDParams::Description,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::PipelineStatusUpdateByIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module PipelineStatusUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineStatusUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class StatusUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded::Status
                ]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[
                    Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded::Status
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineStatusUpdateByIDResponse::StatusUpdateResponse,
            Amocrm::Models::PipelineStatusUpdateByIDResponse::Problem
          )
        end
    end

    class PipelineStatusUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::PipelineStatusUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::PipelineStatusUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::PipelineStatusUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig do
          returns(T.nilable(
              T::Array[Amocrm::PipelineStatusUpdateParams::Body::Description]
            ))
        end
        attr_reader :descriptions

        sig do
          params(
            descriptions: T::Array[
                Amocrm::PipelineStatusUpdateParams::Body::Description::OrHash
              ]
          ).void
        end
        attr_writer :descriptions

        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          override
            .returns({
              id: Integer,
              color: String,
              descriptions:
                T::Array[Amocrm::PipelineStatusUpdateParams::Body::Description],
              name: String,
              request_id: String,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              color: String,
              descriptions: T::Array[
                Amocrm::PipelineStatusUpdateParams::Body::Description::OrHash
              ],
              name: String,
              request_id: String,
              sort: Integer
            ).returns(T.attached_class)
          end
          def new(id:, color: nil, descriptions: nil, name: nil, request_id: nil, sort: nil); end
        end

        class Description < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :description

          sig { params(description: String).void }
          attr_writer :description

          sig { returns(T.nilable(Integer)) }
          attr_reader :id

          sig { params(id: Integer).void }
          attr_writer :id

          sig { returns(T.nilable(String)) }
          attr_reader :level

          sig { params(level: String).void }
          attr_writer :level

          sig { override.returns({ id: Integer, description: String, level: String }) }
          def to_hash; end

          class << self
            sig { params(id: Integer, description: String, level: String).returns(T.attached_class) }
            def new(id: nil, description: nil, level: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::PipelineStatusUpdateParams::Body::Description,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::PipelineStatusUpdateParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineStatusUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineStatusUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineStatusUpdateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class StatusUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded::Status
                ]
              ))
          end
          attr_reader :statuses

          sig do
            params(
              statuses: T::Array[
                  Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded::Status::OrHash
                ]
            ).void
          end
          attr_writer :statuses

          sig do
            override
              .returns({
                statuses:
                  T::Array[
                    Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded::Status
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                statuses: T::Array[
                  Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded::Status::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(statuses: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Status < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse::Embedded::Status,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineStatusUpdateResponse::StatusUpdateResponse,
            Amocrm::Models::PipelineStatusUpdateResponse::Problem
          )
        end
    end

    class PipelineUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_archive

      sig { params(is_archive: T::Boolean).void }
      attr_writer :is_archive

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_main

      sig { params(is_main: T::Boolean).void }
      attr_writer :is_main

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_unsorted_on

      sig { params(is_unsorted_on: T::Boolean).void }
      attr_writer :is_unsorted_on

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(String)) }
      attr_reader :request_id

      sig { params(request_id: String).void }
      attr_writer :request_id

      sig { returns(T.nilable(Integer)) }
      attr_reader :sort

      sig { params(sort: Integer).void }
      attr_writer :sort

      sig do
        override
          .returns({
            is_archive: T::Boolean,
            is_main: T::Boolean,
            is_unsorted_on: T::Boolean,
            name: String,
            request_id: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            is_archive: T::Boolean,
            is_main: T::Boolean,
            is_unsorted_on: T::Boolean,
            name: String,
            request_id: String,
            sort: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(is_archive: nil, is_main: nil, is_unsorted_on: nil, name: nil, request_id: nil, sort: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineUpdateByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class PipelineUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded::Pipeline
                ]
              ))
          end
          attr_reader :pipelines

          sig do
            params(
              pipelines: T::Array[
                  Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded::Pipeline::OrHash
                ]
            ).void
          end
          attr_writer :pipelines

          sig do
            override
              .returns({
                pipelines:
                  T::Array[
                    Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded::Pipeline
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                pipelines: T::Array[
                  Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded::Pipeline::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(pipelines: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Pipeline < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse::Embedded::Pipeline,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineUpdateByIDResponse::PipelineUpdateResponse,
            Amocrm::Models::PipelineUpdateByIDResponse::Problem
          )
        end
    end

    class PipelineUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::PipelineUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::PipelineUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::PipelineUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_archive

        sig { params(is_archive: T::Boolean).void }
        attr_writer :is_archive

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_main

        sig { params(is_main: T::Boolean).void }
        attr_writer :is_main

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_unsorted_on

        sig { params(is_unsorted_on: T::Boolean).void }
        attr_writer :is_unsorted_on

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig do
          override
            .returns({
              id: Integer,
              is_archive: T::Boolean,
              is_main: T::Boolean,
              is_unsorted_on: T::Boolean,
              name: String,
              request_id: String,
              sort: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              is_archive: T::Boolean,
              is_main: T::Boolean,
              is_unsorted_on: T::Boolean,
              name: String,
              request_id: String,
              sort: Integer
            ).returns(T.attached_class)
          end
          def new(id:, is_archive: nil, is_main: nil, is_unsorted_on: nil, name: nil, request_id: nil, sort: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::PipelineUpdateParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::PipelineUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module PipelineUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::PipelineUpdateResponse::Variants]) }
        def variants; end
      end

      class PipelineUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded::Pipeline
                ]
              ))
          end
          attr_reader :pipelines

          sig do
            params(
              pipelines: T::Array[
                  Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded::Pipeline::OrHash
                ]
            ).void
          end
          attr_writer :pipelines

          sig do
            override
              .returns({
                pipelines:
                  T::Array[
                    Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded::Pipeline
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                pipelines: T::Array[
                  Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded::Pipeline::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(pipelines: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Pipeline < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  request_id: String,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, request_id: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse::Embedded::Pipeline,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::PipelineUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::PipelineUpdateResponse::PipelineUpdateResponse,
            Amocrm::Models::PipelineUpdateResponse::Problem
          )
        end
    end

    class RoleCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::RoleCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::RoleCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::RoleCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Amocrm::RoleCreateParams::Body::Rights)) }
        attr_reader :rights

        sig { params(rights: Amocrm::RoleCreateParams::Body::Rights::OrHash).void }
        attr_writer :rights

        sig do
          override
            .returns({
              name: String,
              request_id: String,
              rights: Amocrm::RoleCreateParams::Body::Rights
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              request_id: String,
              rights: Amocrm::RoleCreateParams::Body::Rights::OrHash
            ).returns(T.attached_class)
          end
          def new(name:, request_id: nil, rights: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::RoleCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        class Rights < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :catalog_access

          sig { params(catalog_access: T::Boolean).void }
          attr_writer :catalog_access

          sig { returns(T.nilable(T.anything)) }
          attr_reader :companies

          sig { params(companies: T.anything).void }
          attr_writer :companies

          sig { returns(T.nilable(T.anything)) }
          attr_reader :contacts

          sig { params(contacts: T.anything).void }
          attr_writer :contacts

          sig { returns(T.nilable(Integer)) }
          attr_accessor :group_id

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_active

          sig { params(is_active: T::Boolean).void }
          attr_writer :is_active

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_admin

          sig { params(is_admin: T::Boolean).void }
          attr_writer :is_admin

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_free

          sig { params(is_free: T::Boolean).void }
          attr_writer :is_free

          sig { returns(T.nilable(T.anything)) }
          attr_reader :leads

          sig { params(leads: T.anything).void }
          attr_writer :leads

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :mail_access

          sig { params(mail_access: T::Boolean).void }
          attr_writer :mail_access

          sig { returns(T.nilable(Integer)) }
          attr_accessor :role_id

          sig do
            returns(T.nilable(
                T::Array[Amocrm::RoleCreateParams::Body::Rights::StatusRight]
              ))
          end
          attr_accessor :status_rights

          sig { returns(T.nilable(T.anything)) }
          attr_reader :tasks

          sig { params(tasks: T.anything).void }
          attr_writer :tasks

          sig do
            override
              .returns({
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights:
                  T.nilable(
                    T::Array[
                      Amocrm::RoleCreateParams::Body::Rights::StatusRight
                    ]
                  ),
                tasks: T.anything
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights: T.nilable(
                  T::Array[
                    Amocrm::RoleCreateParams::Body::Rights::StatusRight::OrHash
                  ]
                ),
                tasks: T.anything
              ).returns(T.attached_class)
            end
            def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::RoleCreateParams::Body::Rights,
                Amocrm::Internal::AnyHash
              )
            end

          class StatusRight < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(T.anything)) }
            attr_reader :rights

            sig { params(rights: T.anything).void }
            attr_writer :rights

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            sig do
              override
                .returns({
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                ).returns(T.attached_class)
              end
              def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::RoleCreateParams::Body::Rights::StatusRight,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::RoleCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module RoleCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::RoleCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class RoleCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role
                ]
              ))
          end
          attr_reader :roles

          sig do
            params(
              roles: T::Array[
                  Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::OrHash
                ]
            ).void
          end
          attr_writer :roles

          sig do
            override
              .returns({
                roles:
                  T::Array[
                    Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                roles: T::Array[
                  Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(roles: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Role < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights
                ))
            end
            attr_reader :rights

            sig do
              params(
                rights: Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights::OrHash
              ).void
            end
            attr_writer :rights

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded,
                  _links: T.anything,
                  name: String,
                  request_id: String,
                  rights:
                    Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded::OrHash,
                  _links: T.anything,
                  name: String,
                  request_id: String,
                  rights: Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights::OrHash
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, name: nil, request_id: nil, rights: nil); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded::User
                    ]
                  ))
              end
              attr_reader :users

              sig do
                params(
                  users: T::Array[
                      Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded::User::OrHash
                    ]
                ).void
              end
              attr_writer :users

              sig do
                override
                  .returns({
                    users:
                      T::Array[
                        Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded::User
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    users: T::Array[
                      Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded::User::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(users: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class User < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer).returns(T.attached_class) }
                  def new(id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Embedded::User,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role,
                  Amocrm::Internal::AnyHash
                )
              end

            class Rights < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :catalog_access

              sig { params(catalog_access: T::Boolean).void }
              attr_writer :catalog_access

              sig { returns(T.nilable(T.anything)) }
              attr_reader :companies

              sig { params(companies: T.anything).void }
              attr_writer :companies

              sig { returns(T.nilable(T.anything)) }
              attr_reader :contacts

              sig { params(contacts: T.anything).void }
              attr_writer :contacts

              sig { returns(T.nilable(Integer)) }
              attr_accessor :group_id

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_active

              sig { params(is_active: T::Boolean).void }
              attr_writer :is_active

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_admin

              sig { params(is_admin: T::Boolean).void }
              attr_writer :is_admin

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_free

              sig { params(is_free: T::Boolean).void }
              attr_writer :is_free

              sig { returns(T.nilable(T.anything)) }
              attr_reader :leads

              sig { params(leads: T.anything).void }
              attr_writer :leads

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :mail_access

              sig { params(mail_access: T::Boolean).void }
              attr_writer :mail_access

              sig { returns(T.nilable(Integer)) }
              attr_accessor :role_id

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights::StatusRight
                    ]
                  ))
              end
              attr_accessor :status_rights

              sig { returns(T.nilable(T.anything)) }
              attr_reader :tasks

              sig { params(tasks: T.anything).void }
              attr_writer :tasks

              sig do
                override
                  .returns({
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights:
                      T.nilable(
                        T::Array[
                          Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights::StatusRight
                        ]
                      ),
                    tasks: T.anything
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights: T.nilable(
                      T::Array[
                        Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights::StatusRight::OrHash
                      ]
                    ),
                    tasks: T.anything
                  ).returns(T.attached_class)
                end
                def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights,
                    Amocrm::Internal::AnyHash
                  )
                end

              class StatusRight < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :entity_type

                sig { params(entity_type: String).void }
                attr_writer :entity_type

                sig { returns(T.nilable(Integer)) }
                attr_reader :pipeline_id

                sig { params(pipeline_id: Integer).void }
                attr_writer :pipeline_id

                sig { returns(T.nilable(T.anything)) }
                attr_reader :rights

                sig { params(rights: T.anything).void }
                attr_writer :rights

                sig { returns(T.nilable(Integer)) }
                attr_reader :status_id

                sig { params(status_id: Integer).void }
                attr_writer :status_id

                sig do
                  override
                    .returns({
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::RoleCreateResponse::RoleCreateResponse::Embedded::Role::Rights::StatusRight,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleCreateResponse::RoleCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::RoleCreateResponse::RoleCreateResponse,
            Amocrm::Models::RoleCreateResponse::Problem
          )
        end
    end

    class RoleDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::RoleDeleteByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module RoleDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::RoleDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleDeleteByIDResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::RoleDeleteByIDResponse::EmptyResponse,
            Amocrm::Models::RoleDeleteByIDResponse::Problem
          )
        end
    end

    class RoleGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::RoleGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module RoleGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::RoleGetByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Role < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::RoleGetByIDResponse::Role::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::RoleGetByIDResponse::Role::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Amocrm::Models::RoleGetByIDResponse::Role::Rights)) }
        attr_reader :rights

        sig { params(rights: Amocrm::Models::RoleGetByIDResponse::Role::Rights::OrHash).void }
        attr_writer :rights

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::Models::RoleGetByIDResponse::Role::Embedded,
              _links: T.anything,
              name: String,
              rights: Amocrm::Models::RoleGetByIDResponse::Role::Rights
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::RoleGetByIDResponse::Role::Embedded::OrHash,
              _links: T.anything,
              name: String,
              rights: Amocrm::Models::RoleGetByIDResponse::Role::Rights::OrHash
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, name: nil, rights: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::RoleGetByIDResponse::Role::Embedded::User
                ]
              ))
          end
          attr_reader :users

          sig do
            params(
              users: T::Array[
                  Amocrm::Models::RoleGetByIDResponse::Role::Embedded::User::OrHash
                ]
            ).void
          end
          attr_writer :users

          sig do
            override
              .returns({
                users:
                  T::Array[
                    Amocrm::Models::RoleGetByIDResponse::Role::Embedded::User
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                users: T::Array[
                  Amocrm::Models::RoleGetByIDResponse::Role::Embedded::User::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(users: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::RoleGetByIDResponse::Role::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class User < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer).returns(T.attached_class) }
              def new(id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::RoleGetByIDResponse::Role::Embedded::User,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleGetByIDResponse::Role,
              Amocrm::Internal::AnyHash
            )
          end

        class Rights < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :catalog_access

          sig { params(catalog_access: T::Boolean).void }
          attr_writer :catalog_access

          sig { returns(T.nilable(T.anything)) }
          attr_reader :companies

          sig { params(companies: T.anything).void }
          attr_writer :companies

          sig { returns(T.nilable(T.anything)) }
          attr_reader :contacts

          sig { params(contacts: T.anything).void }
          attr_writer :contacts

          sig { returns(T.nilable(Integer)) }
          attr_accessor :group_id

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_active

          sig { params(is_active: T::Boolean).void }
          attr_writer :is_active

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_admin

          sig { params(is_admin: T::Boolean).void }
          attr_writer :is_admin

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_free

          sig { params(is_free: T::Boolean).void }
          attr_writer :is_free

          sig { returns(T.nilable(T.anything)) }
          attr_reader :leads

          sig { params(leads: T.anything).void }
          attr_writer :leads

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :mail_access

          sig { params(mail_access: T::Boolean).void }
          attr_writer :mail_access

          sig { returns(T.nilable(Integer)) }
          attr_accessor :role_id

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::RoleGetByIDResponse::Role::Rights::StatusRight
                ]
              ))
          end
          attr_accessor :status_rights

          sig { returns(T.nilable(T.anything)) }
          attr_reader :tasks

          sig { params(tasks: T.anything).void }
          attr_writer :tasks

          sig do
            override
              .returns({
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights:
                  T.nilable(
                    T::Array[
                      Amocrm::Models::RoleGetByIDResponse::Role::Rights::StatusRight
                    ]
                  ),
                tasks: T.anything
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights: T.nilable(
                  T::Array[
                    Amocrm::Models::RoleGetByIDResponse::Role::Rights::StatusRight::OrHash
                  ]
                ),
                tasks: T.anything
              ).returns(T.attached_class)
            end
            def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::RoleGetByIDResponse::Role::Rights,
                Amocrm::Internal::AnyHash
              )
            end

          class StatusRight < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(T.anything)) }
            attr_reader :rights

            sig { params(rights: T.anything).void }
            attr_writer :rights

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            sig do
              override
                .returns({
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                ).returns(T.attached_class)
              end
              def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::RoleGetByIDResponse::Role::Rights::StatusRight,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::RoleGetByIDResponse::Role,
            Amocrm::Models::RoleGetByIDResponse::Problem
          )
        end
    end

    class RoleListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(limit: nil, page: nil, with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::RoleListParams, Amocrm::Internal::AnyHash)
        end
    end

    module RoleListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::RoleListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class RoleListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::RoleListResponse::RoleListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page_count

        sig { params(_page_count: Integer).void }
        attr_writer :_page_count

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::RoleListResponse::RoleListResponse::Embedded,
              _links: T.anything,
              _page: Integer,
              _page_count: Integer,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer,
              _page_count: Integer,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil, _page_count: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role
                ]
              ))
          end
          attr_reader :roles

          sig do
            params(
              roles: T::Array[
                  Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::OrHash
                ]
            ).void
          end
          attr_writer :roles

          sig do
            override
              .returns({
                roles:
                  T::Array[
                    Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                roles: T::Array[
                  Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(roles: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::RoleListResponse::RoleListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Role < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              returns(T.nilable(
                  Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights
                ))
            end
            attr_reader :rights

            sig do
              params(
                rights: Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights::OrHash
              ).void
            end
            attr_writer :rights

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded,
                  _links: T.anything,
                  name: String,
                  rights:
                    Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded::OrHash,
                  _links: T.anything,
                  name: String,
                  rights: Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights::OrHash
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, name: nil, rights: nil); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded::User
                    ]
                  ))
              end
              attr_reader :users

              sig do
                params(
                  users: T::Array[
                      Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded::User::OrHash
                    ]
                ).void
              end
              attr_writer :users

              sig do
                override
                  .returns({
                    users:
                      T::Array[
                        Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded::User
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    users: T::Array[
                      Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded::User::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(users: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class User < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer).returns(T.attached_class) }
                  def new(id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Embedded::User,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role,
                  Amocrm::Internal::AnyHash
                )
              end

            class Rights < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :catalog_access

              sig { params(catalog_access: T::Boolean).void }
              attr_writer :catalog_access

              sig { returns(T.nilable(T.anything)) }
              attr_reader :companies

              sig { params(companies: T.anything).void }
              attr_writer :companies

              sig { returns(T.nilable(T.anything)) }
              attr_reader :contacts

              sig { params(contacts: T.anything).void }
              attr_writer :contacts

              sig { returns(T.nilable(Integer)) }
              attr_accessor :group_id

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_active

              sig { params(is_active: T::Boolean).void }
              attr_writer :is_active

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_admin

              sig { params(is_admin: T::Boolean).void }
              attr_writer :is_admin

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_free

              sig { params(is_free: T::Boolean).void }
              attr_writer :is_free

              sig { returns(T.nilable(T.anything)) }
              attr_reader :leads

              sig { params(leads: T.anything).void }
              attr_writer :leads

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :mail_access

              sig { params(mail_access: T::Boolean).void }
              attr_writer :mail_access

              sig { returns(T.nilable(Integer)) }
              attr_accessor :role_id

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights::StatusRight
                    ]
                  ))
              end
              attr_accessor :status_rights

              sig { returns(T.nilable(T.anything)) }
              attr_reader :tasks

              sig { params(tasks: T.anything).void }
              attr_writer :tasks

              sig do
                override
                  .returns({
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights:
                      T.nilable(
                        T::Array[
                          Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights::StatusRight
                        ]
                      ),
                    tasks: T.anything
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights: T.nilable(
                      T::Array[
                        Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights::StatusRight::OrHash
                      ]
                    ),
                    tasks: T.anything
                  ).returns(T.attached_class)
                end
                def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights,
                    Amocrm::Internal::AnyHash
                  )
                end

              class StatusRight < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :entity_type

                sig { params(entity_type: String).void }
                attr_writer :entity_type

                sig { returns(T.nilable(Integer)) }
                attr_reader :pipeline_id

                sig { params(pipeline_id: Integer).void }
                attr_writer :pipeline_id

                sig { returns(T.nilable(T.anything)) }
                attr_reader :rights

                sig { params(rights: T.anything).void }
                attr_writer :rights

                sig { returns(T.nilable(Integer)) }
                attr_reader :status_id

                sig { params(status_id: Integer).void }
                attr_writer :status_id

                sig do
                  override
                    .returns({
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::RoleListResponse::RoleListResponse::Embedded::Role::Rights::StatusRight,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleListResponse::RoleListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::RoleListResponse::RoleListResponse,
            Amocrm::Models::RoleListResponse::Problem
          )
        end
    end

    class RoleUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(String)) }
      attr_reader :request_id

      sig { params(request_id: String).void }
      attr_writer :request_id

      sig { returns(T.nilable(Amocrm::RoleUpdateByIDParams::Rights)) }
      attr_reader :rights

      sig { params(rights: T.nilable(Amocrm::RoleUpdateByIDParams::Rights::OrHash)).void }
      attr_writer :rights

      sig do
        override
          .returns({
            name: String,
            request_id: String,
            rights: T.nilable(Amocrm::RoleUpdateByIDParams::Rights),
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            name: String,
            request_id: String,
            rights: T.nilable(Amocrm::RoleUpdateByIDParams::Rights::OrHash),
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(name: nil, request_id: nil, rights: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::RoleUpdateByIDParams, Amocrm::Internal::AnyHash)
        end

      class Rights < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :catalog_access

        sig { params(catalog_access: T::Boolean).void }
        attr_writer :catalog_access

        sig { returns(T.nilable(T.anything)) }
        attr_reader :companies

        sig { params(companies: T.anything).void }
        attr_writer :companies

        sig { returns(T.nilable(T.anything)) }
        attr_reader :contacts

        sig { params(contacts: T.anything).void }
        attr_writer :contacts

        sig { returns(T.nilable(Integer)) }
        attr_accessor :group_id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_active

        sig { params(is_active: T::Boolean).void }
        attr_writer :is_active

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_admin

        sig { params(is_admin: T::Boolean).void }
        attr_writer :is_admin

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_free

        sig { params(is_free: T::Boolean).void }
        attr_writer :is_free

        sig { returns(T.nilable(T.anything)) }
        attr_reader :leads

        sig { params(leads: T.anything).void }
        attr_writer :leads

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :mail_access

        sig { params(mail_access: T::Boolean).void }
        attr_writer :mail_access

        sig { returns(T.nilable(Integer)) }
        attr_accessor :role_id

        sig do
          returns(T.nilable(
              T::Array[Amocrm::RoleUpdateByIDParams::Rights::StatusRight]
            ))
        end
        attr_accessor :status_rights

        sig { returns(T.nilable(T.anything)) }
        attr_reader :tasks

        sig { params(tasks: T.anything).void }
        attr_writer :tasks

        sig do
          override
            .returns({
              catalog_access: T::Boolean,
              companies: T.anything,
              contacts: T.anything,
              group_id: T.nilable(Integer),
              is_active: T::Boolean,
              is_admin: T::Boolean,
              is_free: T::Boolean,
              leads: T.anything,
              mail_access: T::Boolean,
              role_id: T.nilable(Integer),
              status_rights:
                T.nilable(
                  T::Array[Amocrm::RoleUpdateByIDParams::Rights::StatusRight]
                ),
              tasks: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              catalog_access: T::Boolean,
              companies: T.anything,
              contacts: T.anything,
              group_id: T.nilable(Integer),
              is_active: T::Boolean,
              is_admin: T::Boolean,
              is_free: T::Boolean,
              leads: T.anything,
              mail_access: T::Boolean,
              role_id: T.nilable(Integer),
              status_rights: T.nilable(
                T::Array[
                  Amocrm::RoleUpdateByIDParams::Rights::StatusRight::OrHash
                ]
              ),
              tasks: T.anything
            ).returns(T.attached_class)
          end
          def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::RoleUpdateByIDParams::Rights,
              Amocrm::Internal::AnyHash
            )
          end

        class StatusRight < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :entity_type

          sig { params(entity_type: String).void }
          attr_writer :entity_type

          sig { returns(T.nilable(Integer)) }
          attr_reader :pipeline_id

          sig { params(pipeline_id: Integer).void }
          attr_writer :pipeline_id

          sig { returns(T.nilable(T.anything)) }
          attr_reader :rights

          sig { params(rights: T.anything).void }
          attr_writer :rights

          sig { returns(T.nilable(Integer)) }
          attr_reader :status_id

          sig { params(status_id: Integer).void }
          attr_writer :status_id

          sig do
            override
              .returns({
                entity_type: String,
                pipeline_id: Integer,
                rights: T.anything,
                status_id: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                entity_type: String,
                pipeline_id: Integer,
                rights: T.anything,
                status_id: Integer
              ).returns(T.attached_class)
            end
            def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::RoleUpdateByIDParams::Rights::StatusRight,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end
    end

    module RoleUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::RoleUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Role < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Amocrm::Models::RoleUpdateByIDResponse::Role::Rights)) }
        attr_reader :rights

        sig { params(rights: Amocrm::Models::RoleUpdateByIDResponse::Role::Rights::OrHash).void }
        attr_writer :rights

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded,
              _links: T.anything,
              name: String,
              rights: Amocrm::Models::RoleUpdateByIDResponse::Role::Rights
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded::OrHash,
              _links: T.anything,
              name: String,
              rights: Amocrm::Models::RoleUpdateByIDResponse::Role::Rights::OrHash
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, name: nil, rights: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded::User
                ]
              ))
          end
          attr_reader :users

          sig do
            params(
              users: T::Array[
                  Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded::User::OrHash
                ]
            ).void
          end
          attr_writer :users

          sig do
            override
              .returns({
                users:
                  T::Array[
                    Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded::User
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                users: T::Array[
                  Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded::User::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(users: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class User < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer).returns(T.attached_class) }
              def new(id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::RoleUpdateByIDResponse::Role::Embedded::User,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::RoleUpdateByIDResponse::Role,
              Amocrm::Internal::AnyHash
            )
          end

        class Rights < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :catalog_access

          sig { params(catalog_access: T::Boolean).void }
          attr_writer :catalog_access

          sig { returns(T.nilable(T.anything)) }
          attr_reader :companies

          sig { params(companies: T.anything).void }
          attr_writer :companies

          sig { returns(T.nilable(T.anything)) }
          attr_reader :contacts

          sig { params(contacts: T.anything).void }
          attr_writer :contacts

          sig { returns(T.nilable(Integer)) }
          attr_accessor :group_id

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_active

          sig { params(is_active: T::Boolean).void }
          attr_writer :is_active

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_admin

          sig { params(is_admin: T::Boolean).void }
          attr_writer :is_admin

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_free

          sig { params(is_free: T::Boolean).void }
          attr_writer :is_free

          sig { returns(T.nilable(T.anything)) }
          attr_reader :leads

          sig { params(leads: T.anything).void }
          attr_writer :leads

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :mail_access

          sig { params(mail_access: T::Boolean).void }
          attr_writer :mail_access

          sig { returns(T.nilable(Integer)) }
          attr_accessor :role_id

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::RoleUpdateByIDResponse::Role::Rights::StatusRight
                ]
              ))
          end
          attr_accessor :status_rights

          sig { returns(T.nilable(T.anything)) }
          attr_reader :tasks

          sig { params(tasks: T.anything).void }
          attr_writer :tasks

          sig do
            override
              .returns({
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights:
                  T.nilable(
                    T::Array[
                      Amocrm::Models::RoleUpdateByIDResponse::Role::Rights::StatusRight
                    ]
                  ),
                tasks: T.anything
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights: T.nilable(
                  T::Array[
                    Amocrm::Models::RoleUpdateByIDResponse::Role::Rights::StatusRight::OrHash
                  ]
                ),
                tasks: T.anything
              ).returns(T.attached_class)
            end
            def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::RoleUpdateByIDResponse::Role::Rights,
                Amocrm::Internal::AnyHash
              )
            end

          class StatusRight < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(T.anything)) }
            attr_reader :rights

            sig { params(rights: T.anything).void }
            attr_writer :rights

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            sig do
              override
                .returns({
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                ).returns(T.attached_class)
              end
              def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::RoleUpdateByIDResponse::Role::Rights::StatusRight,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::RoleUpdateByIDResponse::Role,
            Amocrm::Models::RoleUpdateByIDResponse::Problem
          )
        end
    end

    class SalesbotRunParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::SalesbotRunParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::SalesbotRunParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::SalesbotRunParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(Integer) }
        attr_accessor :bot_id

        sig { returns(Integer) }
        attr_accessor :entity_id

        sig { returns(Integer) }
        attr_accessor :entity_type

        sig { override.returns({ bot_id: Integer, entity_id: Integer, entity_type: Integer }) }
        def to_hash; end

        class << self
          sig { params(bot_id: Integer, entity_id: Integer, entity_type: Integer).returns(T.attached_class) }
          def new(bot_id:, entity_id:, entity_type:); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::SalesbotRunParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SalesbotRunParams, Amocrm::Internal::AnyHash)
        end
    end

    module SalesbotRunResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SalesbotRunResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SalesbotRunResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class SalesbotRunResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links
            ))
        end
        attr_reader :_links

        sig { params(_links: Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links::OrHash).void }
        attr_writer :_links

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :success

        sig { params(success: T::Boolean).void }
        attr_writer :success

        sig do
          override
            .returns({
              _links:
                Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links,
              success: T::Boolean
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _links: Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links::OrHash,
              success: T::Boolean
            ).returns(T.attached_class)
          end
          def new(_links: nil, success: nil); end
        end

        class Links < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links::Self
              ))
          end
          attr_reader :self_

          sig { params(self_: Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links::Self::OrHash).void }
          attr_writer :self_

          sig do
            override
              .returns({
                self_:
                  Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links::Self
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                self_: Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links::Self::OrHash
              ).returns(T.attached_class)
            end
            def new(self_: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links,
                Amocrm::Internal::AnyHash
              )
            end

          class Self < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :href

            sig { params(href: String).void }
            attr_writer :href

            sig { returns(T.nilable(String)) }
            attr_reader :method_

            sig { params(method_: String).void }
            attr_writer :method_

            sig { override.returns({ href: String, method_: String }) }
            def to_hash; end

            class << self
              sig { params(href: String, method_: String).returns(T.attached_class) }
              def new(href: nil, method_: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse::Links::Self,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SalesbotRunResponse::SalesbotRunResponse,
            Amocrm::Models::SalesbotRunResponse::Problem
          )
        end
    end

    class ShortLinkCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :url

      sig { override.returns({ url: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(url: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(url:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::ShortLinkCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module ShortLinkCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::ShortLinkCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ShortLinkCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class ShortLinkCreateResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :short_link

        sig { params(short_link: String).void }
        attr_writer :short_link

        sig { override.returns({ short_link: String }) }
        def to_hash; end

        class << self
          sig { params(short_link: String).returns(T.attached_class) }
          def new(short_link: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::ShortLinkCreateResponse::ShortLinkCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::ShortLinkCreateResponse::ShortLinkCreateResponse,
            Amocrm::Models::ShortLinkCreateResponse::Problem
          )
        end
    end

    class SourceCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::SourceCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::SourceCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::SourceCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :default

        sig { params(default: T::Boolean).void }
        attr_writer :default

        sig { returns(String) }
        attr_accessor :external_id

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_accessor :origin_code

        sig { returns(T.nilable(Integer)) }
        attr_accessor :pipeline_id

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Amocrm::SourceCreateParams::Body::Services::Variants)) }
        attr_reader :services

        sig { params(services: Amocrm::SourceCreateParams::Body::Services::Variants).void }
        attr_writer :services

        sig do
          override
            .returns({
              external_id: String,
              name: String,
              default: T::Boolean,
              origin_code: T.nilable(String),
              pipeline_id: T.nilable(Integer),
              request_id: String,
              services: Amocrm::SourceCreateParams::Body::Services::Variants
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              external_id: String,
              name: String,
              default: T::Boolean,
              origin_code: T.nilable(String),
              pipeline_id: T.nilable(Integer),
              request_id: String,
              services: Amocrm::SourceCreateParams::Body::Services::Variants
            ).returns(T.attached_class)
          end
          def new(external_id:, name:, default: nil, origin_code: nil, pipeline_id: nil, request_id: nil, services: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::SourceCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        module Services
          extend Amocrm::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Amocrm::SourceCreateParams::Body::Services::Variants]) }
            def variants; end
          end

          StringArray = T.let(
              Amocrm::Internal::Type::ArrayOf[String],
              Amocrm::Internal::Type::Converter
            )

          UnionMember0Array = T.let(
              Amocrm::Internal::Type::ArrayOf[Amocrm::Internal::Type::Unknown],
              Amocrm::Internal::Type::Converter
            )

          Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SourceCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module SourceCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SourceCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class SourceCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source
                ]
              ))
          end
          attr_reader :sources

          sig do
            params(
              sources: T::Array[
                  Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::OrHash
                ]
            ).void
          end
          attr_writer :sources

          sig do
            override
              .returns({
                sources:
                  T::Array[
                    Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                sources: T::Array[
                  Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(sources: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :default

            sig { params(default: T::Boolean).void }
            attr_writer :default

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig do
              params(
                external_id: Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::ExternalID::Variants
              ).void
            end
            attr_writer :external_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_accessor :origin_code

            sig { returns(T.nilable(Integer)) }
            attr_accessor :pipeline_id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::Services::Variants
                ))
            end
            attr_reader :services

            sig do
              params(
                services: Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::Services::Variants
              ).void
            end
            attr_writer :services

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id:
                    Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  request_id: String,
                  services:
                    Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::Services::Variants
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id: Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  request_id: String,
                  services: Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::Services::Variants
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, request_id: nil, services: nil); end
            end

            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end

            module Services
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceCreateResponse::SourceCreateResponse::Embedded::Source::Services::Variants
                  ])
                end
                def variants; end
              end

              StringArray = T.let(
                  Amocrm::Internal::Type::ArrayOf[String],
                  Amocrm::Internal::Type::Converter
                )

              UnionMember0Array = T.let(
                  Amocrm::Internal::Type::ArrayOf[
                    Amocrm::Internal::Type::Unknown
                  ],
                  Amocrm::Internal::Type::Converter
                )

              Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceCreateResponse::SourceCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SourceCreateResponse::SourceCreateResponse,
            Amocrm::Models::SourceCreateResponse::Problem
          )
        end
    end

    class SourceDeleteByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SourceDeleteByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module SourceDeleteByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SourceDeleteByIDResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceDeleteByIDResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceDeleteByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SourceDeleteByIDResponse::EmptyResponse,
            Amocrm::Models::SourceDeleteByIDResponse::Problem
          )
        end
    end

    class SourceDeleteParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::SourceDeleteParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::SourceDeleteParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::SourceDeleteParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(Integer) }
        attr_accessor :id

        sig { override.returns({ id: Integer }) }
        def to_hash; end

        class << self
          sig { params(id: Integer).returns(T.attached_class) }
          def new(id:); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::SourceDeleteParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SourceDeleteParams, Amocrm::Internal::AnyHash)
        end
    end

    module SourceDeleteResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SourceDeleteResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceDeleteResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceDeleteResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SourceDeleteResponse::EmptyResponse,
            Amocrm::Models::SourceDeleteResponse::Problem
          )
        end
    end

    class SourceGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SourceGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module SourceGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SourceGetByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Source < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :default

        sig { params(default: T::Boolean).void }
        attr_writer :default

        sig do
          returns(T.nilable(
              Amocrm::Models::SourceGetByIDResponse::Source::ExternalID::Variants
            ))
        end
        attr_reader :external_id

        sig { params(external_id: Amocrm::Models::SourceGetByIDResponse::Source::ExternalID::Variants).void }
        attr_writer :external_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_accessor :origin_code

        sig { returns(T.nilable(Integer)) }
        attr_accessor :pipeline_id

        sig do
          returns(T.nilable(
              Amocrm::Models::SourceGetByIDResponse::Source::Services::Variants
            ))
        end
        attr_reader :services

        sig { params(services: Amocrm::Models::SourceGetByIDResponse::Source::Services::Variants).void }
        attr_writer :services

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              default: T::Boolean,
              external_id:
                Amocrm::Models::SourceGetByIDResponse::Source::ExternalID::Variants,
              name: String,
              origin_code: T.nilable(String),
              pipeline_id: T.nilable(Integer),
              services:
                Amocrm::Models::SourceGetByIDResponse::Source::Services::Variants
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              default: T::Boolean,
              external_id: Amocrm::Models::SourceGetByIDResponse::Source::ExternalID::Variants,
              name: String,
              origin_code: T.nilable(String),
              pipeline_id: T.nilable(Integer),
              services: Amocrm::Models::SourceGetByIDResponse::Source::Services::Variants
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, services: nil); end
        end

        module ExternalID
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::SourceGetByIDResponse::Source::ExternalID::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceGetByIDResponse::Source,
              Amocrm::Internal::AnyHash
            )
          end

        module Services
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::SourceGetByIDResponse::Source::Services::Variants
              ])
            end
            def variants; end
          end

          StringArray = T.let(
              Amocrm::Internal::Type::ArrayOf[String],
              Amocrm::Internal::Type::Converter
            )

          UnionMember0Array = T.let(
              Amocrm::Internal::Type::ArrayOf[Amocrm::Internal::Type::Unknown],
              Amocrm::Internal::Type::Converter
            )

          Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
        end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SourceGetByIDResponse::Source,
            Amocrm::Models::SourceGetByIDResponse::Problem
          )
        end
    end

    class SourceListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Amocrm::SourceListParams::Filter)) }
      attr_reader :filter

      sig { params(filter: Amocrm::SourceListParams::Filter::OrHash).void }
      attr_writer :filter

      sig do
        override
          .returns({
            filter: Amocrm::SourceListParams::Filter,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: Amocrm::SourceListParams::Filter::OrHash,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, request_options: {}); end
      end

      class Filter < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::SourceListParams::Filter::ExternalID::Variants)) }
        attr_reader :external_id

        sig { params(external_id: Amocrm::SourceListParams::Filter::ExternalID::Variants).void }
        attr_writer :external_id

        sig do
          override
            .returns({
              external_id:
                Amocrm::SourceListParams::Filter::ExternalID::Variants
            })
        end
        def to_hash; end

        class << self
          sig { params(external_id: Amocrm::SourceListParams::Filter::ExternalID::Variants).returns(T.attached_class) }
          def new(external_id: nil); end
        end

        module ExternalID
          extend Amocrm::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Amocrm::SourceListParams::Filter::ExternalID::Variants]) }
            def variants; end
          end

          module UnionMember3
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::SourceListParams::Filter::ExternalID::UnionMember3::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
          end

          UnionMember3Array = T.let(
              Amocrm::Internal::Type::ArrayOf[
                union:
                  Amocrm::SourceListParams::Filter::ExternalID::UnionMember3
              ],
              Amocrm::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(
                String,
                Integer,
                T::Boolean,
                T::Array[
                  Amocrm::SourceListParams::Filter::ExternalID::UnionMember3::Variants
                ]
              )
            end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::SourceListParams::Filter, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SourceListParams, Amocrm::Internal::AnyHash)
        end
    end

    module SourceListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SourceListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class SourceListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::SourceListResponse::SourceListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::SourceListResponse::SourceListResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source
                ]
              ))
          end
          attr_reader :sources

          sig do
            params(
              sources: T::Array[
                  Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::OrHash
                ]
            ).void
          end
          attr_writer :sources

          sig do
            override
              .returns({
                sources:
                  T::Array[
                    Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                sources: T::Array[
                  Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(sources: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::SourceListResponse::SourceListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :default

            sig { params(default: T::Boolean).void }
            attr_writer :default

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig do
              params(
                external_id: Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::ExternalID::Variants
              ).void
            end
            attr_writer :external_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_accessor :origin_code

            sig { returns(T.nilable(Integer)) }
            attr_accessor :pipeline_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::Services::Variants
                ))
            end
            attr_reader :services

            sig do
              params(
                services: Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::Services::Variants
              ).void
            end
            attr_writer :services

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id:
                    Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  services:
                    Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::Services::Variants
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id: Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  services: Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::Services::Variants
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, services: nil); end
            end

            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end

            module Services
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceListResponse::SourceListResponse::Embedded::Source::Services::Variants
                  ])
                end
                def variants; end
              end

              StringArray = T.let(
                  Amocrm::Internal::Type::ArrayOf[String],
                  Amocrm::Internal::Type::Converter
                )

              UnionMember0Array = T.let(
                  Amocrm::Internal::Type::ArrayOf[
                    Amocrm::Internal::Type::Unknown
                  ],
                  Amocrm::Internal::Type::Converter
                )

              Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceListResponse::SourceListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SourceListResponse::SourceListResponse,
            Amocrm::Models::SourceListResponse::Problem
          )
        end
    end

    class SourceUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :default

      sig { params(default: T::Boolean).void }
      attr_writer :default

      sig { returns(T.nilable(String)) }
      attr_reader :external_id

      sig { params(external_id: String).void }
      attr_writer :external_id

      sig { returns(T.nilable(String)) }
      attr_reader :name

      sig { params(name: String).void }
      attr_writer :name

      sig { returns(T.nilable(String)) }
      attr_accessor :origin_code

      sig { returns(T.nilable(Integer)) }
      attr_accessor :pipeline_id

      sig { returns(T.nilable(String)) }
      attr_reader :request_id

      sig { params(request_id: String).void }
      attr_writer :request_id

      sig { returns(T.nilable(Amocrm::SourceUpdateByIDParams::Services::Variants)) }
      attr_reader :services

      sig { params(services: Amocrm::SourceUpdateByIDParams::Services::Variants).void }
      attr_writer :services

      sig do
        override
          .returns({
            default: T::Boolean,
            external_id: String,
            name: String,
            origin_code: T.nilable(String),
            pipeline_id: T.nilable(Integer),
            request_id: String,
            services: Amocrm::SourceUpdateByIDParams::Services::Variants,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            default: T::Boolean,
            external_id: String,
            name: String,
            origin_code: T.nilable(String),
            pipeline_id: T.nilable(Integer),
            request_id: String,
            services: Amocrm::SourceUpdateByIDParams::Services::Variants,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, request_id: nil, services: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SourceUpdateByIDParams, Amocrm::Internal::AnyHash)
        end

      module Services
        extend Amocrm::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Amocrm::SourceUpdateByIDParams::Services::Variants]) }
          def variants; end
        end

        StringArray = T.let(
            Amocrm::Internal::Type::ArrayOf[String],
            Amocrm::Internal::Type::Converter
          )

        UnionMember0Array = T.let(
            Amocrm::Internal::Type::ArrayOf[Amocrm::Internal::Type::Unknown],
            Amocrm::Internal::Type::Converter
          )

        Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
      end
    end

    module SourceUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SourceUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class SourceUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source
                ]
              ))
          end
          attr_reader :sources

          sig do
            params(
              sources: T::Array[
                  Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::OrHash
                ]
            ).void
          end
          attr_writer :sources

          sig do
            override
              .returns({
                sources:
                  T::Array[
                    Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                sources: T::Array[
                  Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(sources: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :default

            sig { params(default: T::Boolean).void }
            attr_writer :default

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig do
              params(
                external_id: Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants
              ).void
            end
            attr_writer :external_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_accessor :origin_code

            sig { returns(T.nilable(Integer)) }
            attr_accessor :pipeline_id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                ))
            end
            attr_reader :services

            sig do
              params(
                services: Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
              ).void
            end
            attr_writer :services

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id:
                    Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  request_id: String,
                  services:
                    Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id: Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  request_id: String,
                  services: Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, request_id: nil, services: nil); end
            end

            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end

            module Services
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                  ])
                end
                def variants; end
              end

              StringArray = T.let(
                  Amocrm::Internal::Type::ArrayOf[String],
                  Amocrm::Internal::Type::Converter
                )

              UnionMember0Array = T.let(
                  Amocrm::Internal::Type::ArrayOf[
                    Amocrm::Internal::Type::Unknown
                  ],
                  Amocrm::Internal::Type::Converter
                )

              Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SourceUpdateByIDResponse::SourceUpdateResponse,
            Amocrm::Models::SourceUpdateByIDResponse::Problem
          )
        end
    end

    class SourceUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::SourceUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::SourceUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::SourceUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :default

        sig { params(default: T::Boolean).void }
        attr_writer :default

        sig { returns(T.nilable(String)) }
        attr_reader :external_id

        sig { params(external_id: String).void }
        attr_writer :external_id

        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_accessor :origin_code

        sig { returns(T.nilable(Integer)) }
        attr_accessor :pipeline_id

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Amocrm::SourceUpdateParams::Body::Services::Variants)) }
        attr_reader :services

        sig { params(services: Amocrm::SourceUpdateParams::Body::Services::Variants).void }
        attr_writer :services

        sig do
          override
            .returns({
              id: Integer,
              default: T::Boolean,
              external_id: String,
              name: String,
              origin_code: T.nilable(String),
              pipeline_id: T.nilable(Integer),
              request_id: String,
              services: Amocrm::SourceUpdateParams::Body::Services::Variants
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              default: T::Boolean,
              external_id: String,
              name: String,
              origin_code: T.nilable(String),
              pipeline_id: T.nilable(Integer),
              request_id: String,
              services: Amocrm::SourceUpdateParams::Body::Services::Variants
            ).returns(T.attached_class)
          end
          def new(id:, default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, request_id: nil, services: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::SourceUpdateParams::Body, Amocrm::Internal::AnyHash)
          end

        module Services
          extend Amocrm::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Amocrm::SourceUpdateParams::Body::Services::Variants]) }
            def variants; end
          end

          StringArray = T.let(
              Amocrm::Internal::Type::ArrayOf[String],
              Amocrm::Internal::Type::Converter
            )

          UnionMember0Array = T.let(
              Amocrm::Internal::Type::ArrayOf[Amocrm::Internal::Type::Unknown],
              Amocrm::Internal::Type::Converter
            )

          Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::SourceUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module SourceUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::SourceUpdateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class SourceUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source
                ]
              ))
          end
          attr_reader :sources

          sig do
            params(
              sources: T::Array[
                  Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::OrHash
                ]
            ).void
          end
          attr_writer :sources

          sig do
            override
              .returns({
                sources:
                  T::Array[
                    Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                sources: T::Array[
                  Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(sources: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Source < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :default

            sig { params(default: T::Boolean).void }
            attr_writer :default

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants
                ))
            end
            attr_reader :external_id

            sig do
              params(
                external_id: Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants
              ).void
            end
            attr_writer :external_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_accessor :origin_code

            sig { returns(T.nilable(Integer)) }
            attr_accessor :pipeline_id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                ))
            end
            attr_reader :services

            sig do
              params(
                services: Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
              ).void
            end
            attr_writer :services

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id:
                    Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  request_id: String,
                  services:
                    Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  default: T::Boolean,
                  external_id: Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants,
                  name: String,
                  origin_code: T.nilable(String),
                  pipeline_id: T.nilable(Integer),
                  request_id: String,
                  services: Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, request_id: nil, services: nil); end
            end

            module ExternalID
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::ExternalID::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source,
                  Amocrm::Internal::AnyHash
                )
              end

            module Services
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse::Embedded::Source::Services::Variants
                  ])
                end
                def variants; end
              end

              StringArray = T.let(
                  Amocrm::Internal::Type::ArrayOf[String],
                  Amocrm::Internal::Type::Converter
                )

              UnionMember0Array = T.let(
                  Amocrm::Internal::Type::ArrayOf[
                    Amocrm::Internal::Type::Unknown
                  ],
                  Amocrm::Internal::Type::Converter
                )

              Variants = T.type_alias { T.any(T::Array[T.anything], T::Array[String]) }
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::SourceUpdateResponse::SourceUpdateResponse,
            Amocrm::Models::SourceUpdateResponse::Problem
          )
        end
    end

    class TagCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::TagCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::TagCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::TagCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :color

        sig { params(color: String).void }
        attr_writer :color

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { override.returns({ name: String, color: String, request_id: String }) }
        def to_hash; end

        class << self
          sig { params(name: String, color: String, request_id: String).returns(T.attached_class) }
          def new(name:, color: nil, request_id: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::TagCreateParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::TagCreateParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(:companies, Amocrm::TagCreateParams::EntityType::TaggedSymbol)

        CONTACTS = T.let(:contacts, Amocrm::TagCreateParams::EntityType::TaggedSymbol)

        CUSTOMERS = T.let(:customers, Amocrm::TagCreateParams::EntityType::TaggedSymbol)

        LEADS = T.let(:leads, Amocrm::TagCreateParams::EntityType::TaggedSymbol)
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias { T.all(Symbol, Amocrm::TagCreateParams::EntityType) }
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TagCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module TagCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TagCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TagCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TagCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded::Tag
                ]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                tags:
                  T::Array[
                    Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded::Tag
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tags: T::Array[
                  Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, color: String, name: String, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String, request_id: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TagCreateResponse::TagCreateResponse::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TagCreateResponse::TagCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TagCreateResponse::TagCreateResponse,
            Amocrm::Models::TagCreateResponse::Problem
          )
        end
    end

    class TagListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig { returns(T.nilable(String)) }
      attr_reader :query

      sig { params(query: String).void }
      attr_writer :query

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            page: Integer,
            query: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            page: Integer,
            query: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, limit: nil, page: nil, query: nil, request_options: {}); end
      end

      module EntityType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Amocrm::TagListParams::EntityType::TaggedSymbol]) }
          def values; end
        end

        COMPANIES = T.let(:companies, Amocrm::TagListParams::EntityType::TaggedSymbol)

        CONTACTS = T.let(:contacts, Amocrm::TagListParams::EntityType::TaggedSymbol)

        CUSTOMERS = T.let(:customers, Amocrm::TagListParams::EntityType::TaggedSymbol)

        LEADS = T.let(:leads, Amocrm::TagListParams::EntityType::TaggedSymbol)
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias { T.all(Symbol, Amocrm::TagListParams::EntityType) }
      end

      OrHash = T.type_alias { T.any(Amocrm::TagListParams, Amocrm::Internal::AnyHash) }
    end

    module TagListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TagListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TagListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TagListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::TagListResponse::TagListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::TagListResponse::TagListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::TagListResponse::TagListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::TagListResponse::TagListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TagListResponse::TagListResponse::Embedded::Tag
                ]
              ))
          end
          attr_reader :tags

          sig do
            params(
              tags: T::Array[
                  Amocrm::Models::TagListResponse::TagListResponse::Embedded::Tag::OrHash
                ]
            ).void
          end
          attr_writer :tags

          sig do
            override
              .returns({
                tags:
                  T::Array[
                    Amocrm::Models::TagListResponse::TagListResponse::Embedded::Tag
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tags: T::Array[
                  Amocrm::Models::TagListResponse::TagListResponse::Embedded::Tag::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tags: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::TagListResponse::TagListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Tag < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :color

            sig { params(color: String).void }
            attr_writer :color

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, color: String, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
              def new(id: nil, color: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TagListResponse::TagListResponse::Embedded::Tag,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TagListResponse::TagListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TagListResponse::TagListResponse,
            Amocrm::Models::TagListResponse::Problem
          )
        end
    end

    class TalkCloseParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Force close talk without NPS bot.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :force_close

      sig { params(force_close: T::Boolean).void }
      attr_writer :force_close

      sig { override.returns({ force_close: T::Boolean, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig do
          params(
            force_close: T::Boolean,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          force_close: nil, # Force close talk without NPS bot.
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TalkCloseParams, Amocrm::Internal::AnyHash)
        end
    end

    module TalkCloseResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TalkCloseResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TalkCloseResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TalkCloseResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TalkCloseResponse::EmptyResponse,
            Amocrm::Models::TalkCloseResponse::Problem
          )
        end
    end

    class TalkGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TalkGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module TalkGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TalkGetByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TalkGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Talk < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::TalkGetByIDResponse::Talk::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(String)) }
        attr_reader :chat_id

        sig { params(chat_id: String).void }
        attr_writer :chat_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :contact_id

        sig { params(contact_id: Integer).void }
        attr_writer :contact_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_accessor :entity_id

        sig { returns(T.nilable(String)) }
        attr_accessor :entity_type

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_in_work

        sig { params(is_in_work: T::Boolean).void }
        attr_writer :is_in_work

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_read

        sig { params(is_read: T::Boolean).void }
        attr_writer :is_read

        sig { returns(T.nilable(Integer)) }
        attr_accessor :missed_at

        sig { returns(T.nilable(String)) }
        attr_reader :origin

        sig { params(origin: String).void }
        attr_writer :origin

        sig { returns(T.nilable(Integer)) }
        attr_reader :rate

        sig { params(rate: Integer).void }
        attr_writer :rate

        sig { returns(T.nilable(Integer)) }
        attr_reader :talk_id

        sig { params(talk_id: Integer).void }
        attr_writer :talk_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig do
          override
            .returns({
              _embedded: Amocrm::Models::TalkGetByIDResponse::Talk::Embedded,
              _links: T.anything,
              account_id: Integer,
              chat_id: String,
              contact_id: Integer,
              created_at: Integer,
              entity_id: T.nilable(Integer),
              entity_type: T.nilable(String),
              is_in_work: T::Boolean,
              is_read: T::Boolean,
              missed_at: T.nilable(Integer),
              origin: String,
              rate: Integer,
              talk_id: Integer,
              updated_at: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::OrHash,
              _links: T.anything,
              account_id: Integer,
              chat_id: String,
              contact_id: Integer,
              created_at: Integer,
              entity_id: T.nilable(Integer),
              entity_type: T.nilable(String),
              is_in_work: T::Boolean,
              is_read: T::Boolean,
              missed_at: T.nilable(Integer),
              origin: String,
              rate: Integer,
              talk_id: Integer,
              updated_at: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, account_id: nil, chat_id: nil, contact_id: nil, created_at: nil, entity_id: nil, entity_type: nil, is_in_work: nil, is_read: nil, missed_at: nil, origin: nil, rate: nil, talk_id: nil, updated_at: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Customer
                ]
              ))
          end
          attr_reader :customers

          sig do
            params(
              customers: T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Customer::OrHash
                ]
            ).void
          end
          attr_writer :customers

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                contacts:
                  T::Array[
                    Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Contact
                  ],
                customers:
                  T::Array[
                    Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Customer
                  ],
                leads:
                  T::Array[
                    Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                contacts: T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Contact::OrHash
                ],
                customers: T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Customer::OrHash
                ],
                leads: T::Array[
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(contacts: nil, customers: nil, leads: nil); end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Customer < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Customer,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TalkGetByIDResponse::Talk::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::TalkGetByIDResponse::Talk::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TalkGetByIDResponse::Talk,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TalkGetByIDResponse::Talk,
            Amocrm::Models::TalkGetByIDResponse::Problem
          )
        end
    end

    class TaskCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::TaskCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::TaskCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::TaskCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :complete_till

        sig { params(complete_till: Integer).void }
        attr_writer :complete_till

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(String)) }
        attr_reader :entity_type

        sig { params(entity_type: String).void }
        attr_writer :entity_type

        # Client-side request id
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :task_type_id

        sig { params(task_type_id: Integer).void }
        attr_writer :task_type_id

        sig { returns(String) }
        attr_accessor :text

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              text: String,
              complete_till: Integer,
              created_by: Integer,
              entity_id: Integer,
              entity_type: String,
              request_id: String,
              responsible_user_id: Integer,
              task_type_id: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              text: String,
              complete_till: Integer,
              created_by: Integer,
              entity_id: Integer,
              entity_type: String,
              request_id: String,
              responsible_user_id: Integer,
              task_type_id: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(
            text:,
            complete_till: nil,
            created_by: nil,
            entity_id: nil,
            entity_type: nil,
            request_id: nil, # Client-side request id
            responsible_user_id: nil,
            task_type_id: nil,
            updated_by: nil
); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::TaskCreateParams::Body, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TaskCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module TaskCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TaskCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TaskCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded::Task
                ]
              ))
          end
          attr_reader :tasks

          sig do
            params(
              tasks: T::Array[
                  Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded::Task::OrHash
                ]
            ).void
          end
          attr_writer :tasks

          sig do
            override
              .returns({
                tasks:
                  T::Array[
                    Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded::Task
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tasks: T::Array[
                  Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded::Task::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Task < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { override.returns({ id: Integer, _links: T.anything, request_id: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, request_id: String).returns(T.attached_class) }
              def new(id: nil, _links: nil, request_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TaskCreateResponse::TaskCreateResponse::Embedded::Task,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskCreateResponse::TaskCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TaskCreateResponse::TaskCreateResponse,
            Amocrm::Models::TaskCreateResponse::Problem
          )
        end
    end

    class TaskGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TaskGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module TaskGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TaskGetByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Task < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :complete_till

        sig { params(complete_till: Integer).void }
        attr_writer :complete_till

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(Integer)) }
        attr_reader :duration

        sig { params(duration: Integer).void }
        attr_writer :duration

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(String)) }
        attr_reader :entity_type

        sig { params(entity_type: String).void }
        attr_writer :entity_type

        sig { returns(T.nilable(Integer)) }
        attr_reader :group_id

        sig { params(group_id: Integer).void }
        attr_writer :group_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_completed

        sig { params(is_completed: T::Boolean).void }
        attr_writer :is_completed

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig do
          returns(T.nilable(
              Amocrm::Models::TaskGetByIDResponse::Task::Result::Variants
            ))
        end
        attr_reader :result

        sig do
          params(
            result: T.any(
                Amocrm::Models::TaskGetByIDResponse::Task::Result::Text::OrHash,
                T.anything
              )
          ).void
        end
        attr_writer :result

        sig { returns(T.nilable(Integer)) }
        attr_reader :task_type_id

        sig { params(task_type_id: Integer).void }
        attr_writer :task_type_id

        sig { returns(T.nilable(String)) }
        attr_reader :text

        sig { params(text: String).void }
        attr_writer :text

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_by

        sig { params(updated_by: Integer).void }
        attr_writer :updated_by

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              complete_till: Integer,
              created_at: Integer,
              created_by: Integer,
              duration: Integer,
              entity_id: Integer,
              entity_type: String,
              group_id: Integer,
              is_completed: T::Boolean,
              responsible_user_id: Integer,
              result:
                Amocrm::Models::TaskGetByIDResponse::Task::Result::Variants,
              task_type_id: Integer,
              text: String,
              updated_at: Integer,
              updated_by: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              account_id: Integer,
              complete_till: Integer,
              created_at: Integer,
              created_by: Integer,
              duration: Integer,
              entity_id: Integer,
              entity_type: String,
              group_id: Integer,
              is_completed: T::Boolean,
              responsible_user_id: Integer,
              result: T.any(
                Amocrm::Models::TaskGetByIDResponse::Task::Result::Text::OrHash,
                T.anything
              ),
              task_type_id: Integer,
              text: String,
              updated_at: Integer,
              updated_by: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, account_id: nil, complete_till: nil, created_at: nil, created_by: nil, duration: nil, entity_id: nil, entity_type: nil, group_id: nil, is_completed: nil, responsible_user_id: nil, result: nil, task_type_id: nil, text: nil, updated_at: nil, updated_by: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskGetByIDResponse::Task,
              Amocrm::Internal::AnyHash
            )
          end

        module Result
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::TaskGetByIDResponse::Task::Result::Variants
              ])
            end
            def variants; end
          end

          class Text < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :text

            sig { params(text: String).void }
            attr_writer :text

            sig { override.returns({ text: String }) }
            def to_hash; end

            class << self
              sig { params(text: String).returns(T.attached_class) }
              def new(text: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TaskGetByIDResponse::Task::Result::Text,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          Variants = T.type_alias do
              T.any(
                Amocrm::Models::TaskGetByIDResponse::Task::Result::Text,
                T.anything
              )
            end
        end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TaskGetByIDResponse::Task,
            Amocrm::Models::TaskGetByIDResponse::Problem
          )
        end
    end

    class TaskListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Filtering parameters
      sig { returns(T.nilable(T.anything)) }
      attr_reader :filter

      sig { params(filter: T.anything).void }
      attr_writer :filter

      # Pagination limit
      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      # Sorting, e.g. order[updated_at]=asc
      sig { returns(T.nilable(T.anything)) }
      attr_reader :order

      sig { params(order: T.anything).void }
      attr_writer :order

      # Pagination page
      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      # Search by query string or id
      sig { returns(T.nilable(Amocrm::TaskListParams::Query::Variants)) }
      attr_reader :query

      sig { params(query: Amocrm::TaskListParams::Query::Variants).void }
      attr_writer :query

      sig do
        override
          .returns({
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::TaskListParams::Query::Variants,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: T.anything,
            limit: Integer,
            order: T.anything,
            page: Integer,
            query: Amocrm::TaskListParams::Query::Variants,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          filter: nil, # Filtering parameters
          limit: nil, # Pagination limit
          order: nil, # Sorting, e.g. order[updated_at]=asc
          page: nil, # Pagination page
          query: nil, # Search by query string or id
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TaskListParams, Amocrm::Internal::AnyHash)
        end

      # Search by query string or id
      module Query
        extend Amocrm::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Amocrm::TaskListParams::Query::Variants]) }
          def variants; end
        end

        Variants = T.type_alias { T.any(String, Integer) }
      end
    end

    module TaskListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TaskListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TaskListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::TaskListResponse::TaskListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::TaskListResponse::TaskListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task
                ]
              ))
          end
          attr_reader :tasks

          sig do
            params(
              tasks: T::Array[
                  Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::OrHash
                ]
            ).void
          end
          attr_writer :tasks

          sig do
            override
              .returns({
                tasks:
                  T::Array[
                    Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tasks: T::Array[
                  Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::TaskListResponse::TaskListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Task < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :complete_till

            sig { params(complete_till: Integer).void }
            attr_writer :complete_till

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(Integer)) }
            attr_reader :duration

            sig { params(duration: Integer).void }
            attr_writer :duration

            sig { returns(T.nilable(Integer)) }
            attr_reader :entity_id

            sig { params(entity_id: Integer).void }
            attr_writer :entity_id

            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_completed

            sig { params(is_completed: T::Boolean).void }
            attr_writer :is_completed

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::Result::Variants
                ))
            end
            attr_reader :result

            sig do
              params(
                result: T.any(
                    Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::Result::Text::OrHash,
                    T.anything
                  )
              ).void
            end
            attr_writer :result

            sig { returns(T.nilable(Integer)) }
            attr_reader :task_type_id

            sig { params(task_type_id: Integer).void }
            attr_writer :task_type_id

            sig { returns(T.nilable(String)) }
            attr_reader :text

            sig { params(text: String).void }
            attr_writer :text

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  complete_till: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  duration: Integer,
                  entity_id: Integer,
                  entity_type: String,
                  group_id: Integer,
                  is_completed: T::Boolean,
                  responsible_user_id: Integer,
                  result:
                    Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::Result::Variants,
                  task_type_id: Integer,
                  text: String,
                  updated_at: Integer,
                  updated_by: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  account_id: Integer,
                  complete_till: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  duration: Integer,
                  entity_id: Integer,
                  entity_type: String,
                  group_id: Integer,
                  is_completed: T::Boolean,
                  responsible_user_id: Integer,
                  result: T.any(
                    Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::Result::Text::OrHash,
                    T.anything
                  ),
                  task_type_id: Integer,
                  text: String,
                  updated_at: Integer,
                  updated_by: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, account_id: nil, complete_till: nil, created_at: nil, created_by: nil, duration: nil, entity_id: nil, entity_type: nil, group_id: nil, is_completed: nil, responsible_user_id: nil, result: nil, task_type_id: nil, text: nil, updated_at: nil, updated_by: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task,
                  Amocrm::Internal::AnyHash
                )
              end

            module Result
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::Result::Variants
                  ])
                end
                def variants; end
              end

              class Text < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :text

                sig { params(text: String).void }
                attr_writer :text

                sig { override.returns({ text: String }) }
                def to_hash; end

                class << self
                  sig { params(text: String).returns(T.attached_class) }
                  def new(text: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::Result::Text,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              Variants = T.type_alias do
                  T.any(
                    Amocrm::Models::TaskListResponse::TaskListResponse::Embedded::Task::Result::Text,
                    T.anything
                  )
                end
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskListResponse::TaskListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TaskListResponse::TaskListResponse,
            Amocrm::Models::TaskListResponse::Problem
          )
        end
    end

    class TaskUpdateByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :complete_till

      sig { params(complete_till: Integer).void }
      attr_writer :complete_till

      sig { returns(T.nilable(Integer)) }
      attr_reader :entity_id

      sig { params(entity_id: Integer).void }
      attr_writer :entity_id

      sig { returns(T.nilable(String)) }
      attr_reader :entity_type

      sig { params(entity_type: String).void }
      attr_writer :entity_type

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_completed

      sig { params(is_completed: T::Boolean).void }
      attr_writer :is_completed

      sig { returns(T.nilable(Integer)) }
      attr_reader :responsible_user_id

      sig { params(responsible_user_id: Integer).void }
      attr_writer :responsible_user_id

      sig { returns(T.nilable(Amocrm::TaskUpdateByIDParams::Result)) }
      attr_reader :result

      sig { params(result: Amocrm::TaskUpdateByIDParams::Result::OrHash).void }
      attr_writer :result

      sig { returns(T.nilable(Integer)) }
      attr_reader :task_type_id

      sig { params(task_type_id: Integer).void }
      attr_writer :task_type_id

      sig { returns(T.nilable(String)) }
      attr_reader :text

      sig { params(text: String).void }
      attr_writer :text

      sig do
        override
          .returns({
            complete_till: Integer,
            entity_id: Integer,
            entity_type: String,
            is_completed: T::Boolean,
            responsible_user_id: Integer,
            result: Amocrm::TaskUpdateByIDParams::Result,
            task_type_id: Integer,
            text: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            complete_till: Integer,
            entity_id: Integer,
            entity_type: String,
            is_completed: T::Boolean,
            responsible_user_id: Integer,
            result: Amocrm::TaskUpdateByIDParams::Result::OrHash,
            task_type_id: Integer,
            text: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(complete_till: nil, entity_id: nil, entity_type: nil, is_completed: nil, responsible_user_id: nil, result: nil, task_type_id: nil, text: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TaskUpdateByIDParams, Amocrm::Internal::AnyHash)
        end

      class Result < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :text

        sig { params(text: String).void }
        attr_writer :text

        sig { override.returns({ text: String }) }
        def to_hash; end

        class << self
          sig { params(text: String).returns(T.attached_class) }
          def new(text: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::TaskUpdateByIDParams::Result,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    module TaskUpdateByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TaskUpdateByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskUpdateByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TaskUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded::Task
                ]
              ))
          end
          attr_reader :tasks

          sig do
            params(
              tasks: T::Array[
                  Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded::Task::OrHash
                ]
            ).void
          end
          attr_writer :tasks

          sig do
            override
              .returns({
                tasks:
                  T::Array[
                    Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded::Task
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tasks: T::Array[
                  Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded::Task::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Task < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse::Embedded::Task,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TaskUpdateByIDResponse::TaskUpdateResponse,
            Amocrm::Models::TaskUpdateByIDResponse::Problem
          )
        end
    end

    class TaskUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::TaskUpdateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::TaskUpdateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::TaskUpdateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :complete_till

        sig { params(complete_till: Integer).void }
        attr_writer :complete_till

        sig { returns(T.nilable(Integer)) }
        attr_reader :entity_id

        sig { params(entity_id: Integer).void }
        attr_writer :entity_id

        sig { returns(T.nilable(String)) }
        attr_reader :entity_type

        sig { params(entity_type: String).void }
        attr_writer :entity_type

        # Task id
        sig { returns(Integer) }
        attr_accessor :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_completed

        sig { params(is_completed: T::Boolean).void }
        attr_writer :is_completed

        sig { returns(T.nilable(Integer)) }
        attr_reader :responsible_user_id

        sig { params(responsible_user_id: Integer).void }
        attr_writer :responsible_user_id

        sig { returns(T.nilable(Amocrm::TaskUpdateParams::Body::Result)) }
        attr_reader :result

        sig { params(result: Amocrm::TaskUpdateParams::Body::Result::OrHash).void }
        attr_writer :result

        sig { returns(T.nilable(Integer)) }
        attr_reader :task_type_id

        sig { params(task_type_id: Integer).void }
        attr_writer :task_type_id

        sig { returns(T.nilable(String)) }
        attr_reader :text

        sig { params(text: String).void }
        attr_writer :text

        sig do
          override
            .returns({
              id: Integer,
              complete_till: Integer,
              entity_id: Integer,
              entity_type: String,
              is_completed: T::Boolean,
              responsible_user_id: Integer,
              result: Amocrm::TaskUpdateParams::Body::Result,
              task_type_id: Integer,
              text: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              complete_till: Integer,
              entity_id: Integer,
              entity_type: String,
              is_completed: T::Boolean,
              responsible_user_id: Integer,
              result: Amocrm::TaskUpdateParams::Body::Result::OrHash,
              task_type_id: Integer,
              text: String
            ).returns(T.attached_class)
          end
          def new(
            id:, # Task id
            complete_till: nil,
            entity_id: nil,
            entity_type: nil,
            is_completed: nil,
            responsible_user_id: nil,
            result: nil,
            task_type_id: nil,
            text: nil
); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::TaskUpdateParams::Body, Amocrm::Internal::AnyHash)
          end

        class Result < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(String)) }
          attr_reader :text

          sig { params(text: String).void }
          attr_writer :text

          sig { override.returns({ text: String }) }
          def to_hash; end

          class << self
            sig { params(text: String).returns(T.attached_class) }
            def new(text: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::TaskUpdateParams::Body::Result,
                Amocrm::Internal::AnyHash
              )
            end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::TaskUpdateParams, Amocrm::Internal::AnyHash)
        end
    end

    module TaskUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::TaskUpdateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class TaskUpdateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded,
              _links: T.anything
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded::OrHash,
              _links: T.anything
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded::Task
                ]
              ))
          end
          attr_reader :tasks

          sig do
            params(
              tasks: T::Array[
                  Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded::Task::OrHash
                ]
            ).void
          end
          attr_writer :tasks

          sig do
            override
              .returns({
                tasks:
                  T::Array[
                    Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded::Task
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                tasks: T::Array[
                  Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded::Task::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Task < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { override.returns({ id: Integer, _links: T.anything, updated_at: Integer }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything, updated_at: Integer).returns(T.attached_class) }
              def new(id: nil, _links: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse::Embedded::Task,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::TaskUpdateResponse::TaskUpdateResponse,
            Amocrm::Models::TaskUpdateResponse::Problem
          )
        end
    end

    class UnsortedLeadAcceptParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # Status id for the created lead
      sig { returns(T.nilable(Integer)) }
      attr_reader :status_id

      sig { params(status_id: Integer).void }
      attr_writer :status_id

      # User id on whose behalf the item is accepted
      sig { returns(T.nilable(Integer)) }
      attr_reader :user_id

      sig { params(user_id: Integer).void }
      attr_writer :user_id

      sig do
        override
          .returns({
            status_id: Integer,
            user_id: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            status_id: Integer,
            user_id: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          status_id: nil, # Status id for the created lead
          user_id: nil, # User id on whose behalf the item is accepted
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::UnsortedLeadAcceptParams, Amocrm::Internal::AnyHash)
        end
    end

    module UnsortedLeadAcceptResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::UnsortedLeadAcceptResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UnsortedLeadAcceptResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class UnsortedAcceptResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig do
          returns(T.nilable(
              Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            ))
        end
        attr_reader :category

        sig do
          params(
            category: Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::OrSymbol
          ).void
        end
        attr_writer :category

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        sig { returns(T.nilable(String)) }
        attr_reader :uid

        sig { params(uid: String).void }
        attr_writer :uid

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded,
              category:
                Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::TaggedSymbol,
              created_at: Integer,
              pipeline_id: Integer,
              uid: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::OrHash,
              category: Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::OrSymbol,
              created_at: Integer,
              pipeline_id: Integer,
              uid: String
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, category: nil, created_at: nil, pipeline_id: nil, uid: nil); end
        end

        module Category
          extend Amocrm::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::TaggedSymbol
              ])
            end
            def values; end
          end

          CHATS = T.let(
              :chats,
              Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          FORMS = T.let(
              :forms,
              Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          MAIL = T.let(
              :mail,
              Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          SIP = T.let(
              :sip,
              Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Category
              )
            end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Company
                  ],
                contacts:
                  T::Array[
                    Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Contact
                  ],
                leads:
                  T::Array[
                    Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                companies: T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Contact::OrHash
                ],
                leads: T::Array[
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(companies: nil, contacts: nil, leads: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::UnsortedLeadAcceptResponse::UnsortedAcceptResponse,
            Amocrm::Models::UnsortedLeadAcceptResponse::Problem
          )
        end
    end

    class UnsortedLeadCreateFormsParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::UnsortedLeadCreateFormsParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::UnsortedLeadCreateFormsParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::UnsortedLeadCreateFormsParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        # Embedded entities (lead/contact/company)
        sig { returns(T.nilable(Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::OrHash).void }
        attr_writer :_embedded

        # Unix timestamp (seconds) when the form entry was created
        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        # Form metadata
        sig { returns(Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata) }
        attr_reader :metadata

        sig { params(metadata: Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata::OrHash).void }
        attr_writer :metadata

        # Pipeline id to place the created lead into
        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        # Your request id to match request items with response items
        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        # Human-readable source name shown in amoCRM (e.g. "Website form", "Landing page")
        sig { returns(String) }
        attr_accessor :source_name

        # Your stable id of the source: site/form/widget/integration that sent the lead
        sig { returns(String) }
        attr_accessor :source_uid

        sig do
          override
            .returns({
              metadata: Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata,
              source_name: String,
              source_uid: String,
              _embedded: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded,
              created_at: Integer,
              pipeline_id: Integer,
              request_id: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              metadata: Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata::OrHash,
              source_name: String,
              source_uid: String,
              _embedded: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::OrHash,
              created_at: Integer,
              pipeline_id: Integer,
              request_id: String
            ).returns(T.attached_class)
          end
          def new(
            metadata:, # Form metadata
            source_name:, # Human-readable source name shown in amoCRM (e.g. "Website form", "Landing page")
            source_uid:, # Your stable id of the source: site/form/widget/integration that sent the lead
            _embedded: nil, # Embedded entities (lead/contact/company)
            created_at: nil, # Unix timestamp (seconds) when the form entry was created
            pipeline_id: nil, # Pipeline id to place the created lead into
            request_id: nil # Your request id to match request items with response items
); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          # Create related entities together with unsorted (lead/contact/company)
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Company
                  ],
                contacts:
                  T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact
                  ],
                leads:
                  T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            # Embedded entities (lead/contact/company)
            sig do
              params(
                companies: T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::OrHash
                ],
                leads: T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(
              companies: nil,
              contacts: nil,
              leads: nil # Create related entities together with unsorted (lead/contact/company)
); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { override.returns({ id: Integer, name: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String).returns(T.attached_class) }
              def new(id: nil, name: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            # Custom fields payload (same as contact create API)
            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue
                  ]
                ))
            end
            attr_reader :custom_fields_values

            sig do
              params(
                custom_fields_values: T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ]
              ).void
            end
            attr_writer :custom_fields_values

            sig { returns(T.nilable(String)) }
            attr_reader :first_name

            sig { params(first_name: String).void }
            attr_writer :first_name

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :last_name

            sig { params(last_name: String).void }
            attr_writer :last_name

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              override
                .returns({
                  id: Integer,
                  custom_fields_values:
                    T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue
                    ],
                  first_name: String,
                  last_name: String,
                  name: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  custom_fields_values: T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::OrHash
                  ],
                  first_name: String,
                  last_name: String,
                  name: String
                ).returns(T.attached_class)
              end
              def new(
                id: nil,
                custom_fields_values: nil, # Custom fields payload (same as contact create API)
                first_name: nil,
                last_name: nil,
                name: nil
); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            # Embedded entities (lead/contact/company/source)
            sig do
              returns(T.nilable(
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(Integer)) }
            attr_reader :closed_at

            sig { params(closed_at: Integer).void }
            attr_writer :closed_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            # Custom fields payload
            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue
                  ]
                ))
            end
            attr_reader :custom_fields_values

            sig do
              params(
                custom_fields_values: T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::OrHash
                  ]
              ).void
            end
            attr_writer :custom_fields_values

            sig { returns(T.nilable(Integer)) }
            attr_reader :group_id

            sig { params(group_id: Integer).void }
            attr_writer :group_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :loss_reason_id

            sig { params(loss_reason_id: Integer).void }
            attr_writer :loss_reason_id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :price

            sig { params(price: Integer).void }
            attr_writer :price

            # Client-side request id
            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :responsible_user_id

            sig { params(responsible_user_id: Integer).void }
            attr_writer :responsible_user_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            # Tags to attach
            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::TagsToAdd
                  ]
                ))
            end
            attr_reader :tags_to_add

            sig do
              params(
                tags_to_add: T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::TagsToAdd::OrHash
                  ]
              ).void
            end
            attr_writer :tags_to_add

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_by

            sig { params(updated_by: Integer).void }
            attr_writer :updated_by

            # Website visitor uid from tracking; links this lead to a site visit
            sig { returns(T.nilable(String)) }
            attr_reader :visitor_uid

            sig { params(visitor_uid: String).void }
            attr_writer :visitor_uid

            sig do
              override
                .returns({
                  _embedded:
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded,
                  closed_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values:
                    T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue
                    ],
                  group_id: Integer,
                  loss_reason_id: Integer,
                  name: String,
                  pipeline_id: Integer,
                  price: Integer,
                  request_id: String,
                  responsible_user_id: Integer,
                  status_id: Integer,
                  tags_to_add:
                    T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::TagsToAdd
                    ],
                  updated_at: Integer,
                  updated_by: Integer,
                  visitor_uid: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  _embedded: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::OrHash,
                  closed_at: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  custom_fields_values: T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::OrHash
                  ],
                  group_id: Integer,
                  loss_reason_id: Integer,
                  name: String,
                  pipeline_id: Integer,
                  price: Integer,
                  request_id: String,
                  responsible_user_id: Integer,
                  status_id: Integer,
                  tags_to_add: T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::TagsToAdd::OrHash
                  ],
                  updated_at: Integer,
                  updated_by: Integer,
                  visitor_uid: String
                ).returns(T.attached_class)
              end
              def new(
                _embedded: nil, # Embedded entities (lead/contact/company/source)
                closed_at: nil,
                created_at: nil,
                created_by: nil,
                custom_fields_values: nil, # Custom fields payload
                group_id: nil,
                loss_reason_id: nil,
                name: nil,
                pipeline_id: nil,
                price: nil,
                request_id: nil, # Client-side request id
                responsible_user_id: nil,
                status_id: nil,
                tags_to_add: nil, # Tags to attach
                updated_at: nil,
                updated_by: nil,
                visitor_uid: nil # Website visitor uid from tracking; links this lead to a site visit
); end
            end

            class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
              # Field code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(String)) }
              attr_reader :field_code

              sig { params(field_code: String).void }
              attr_writer :field_code

              # Use either field_id or field_code (e.g. PHONE/EMAIL)
              sig { returns(T.nilable(Integer)) }
              attr_reader :field_id

              sig { params(field_id: Integer).void }
              attr_writer :field_id

              # Values for the field (multiple values allowed)
              sig do
                returns(T::Array[
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value
                  ])
              end
              attr_accessor :values

              sig do
                override
                  .returns({
                    values:
                      T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value
                      ],
                    field_code: String,
                    field_id: Integer
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    values: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value::OrHash
                    ],
                    field_code: String,
                    field_id: Integer
                  ).returns(T.attached_class)
                end
                def new(
                  values:, # Values for the field (multiple values allowed)
                  field_code: nil, # Field code (e.g. PHONE/EMAIL)
                  field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Value < Amocrm::Internal::Type::BaseModel
                # Option code for list/select custom fields (if you use code instead of id)
                sig { returns(T.nilable(String)) }
                attr_reader :enum_code

                sig { params(enum_code: String).void }
                attr_writer :enum_code

                # Option id for list/select custom fields (one of predefined options)
                sig { returns(T.nilable(Integer)) }
                attr_reader :enum_id

                sig { params(enum_id: Integer).void }
                attr_writer :enum_id

                sig do
                  returns(Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value::Value::Variants)
                end
                attr_accessor :value

                sig do
                  override
                    .returns({
                      value:
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      value: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value::Value::Variants,
                      enum_code: String,
                      enum_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(
                    value:,
                    enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                    enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value,
                      Amocrm::Internal::AnyHash
                    )
                  end

                module Value
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::CustomFieldsValue::Value::Value::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end
              end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Company
                    ]
                  ))
              end
              attr_reader :companies

              sig do
                params(
                  companies: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Company::OrHash
                    ]
                ).void
              end
              attr_writer :companies

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact
                    ]
                  ))
              end
              attr_reader :contacts

              sig do
                params(
                  contacts: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::OrHash
                    ]
                ).void
              end
              attr_writer :contacts

              sig do
                returns(T.nilable(
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata
                  ))
              end
              attr_reader :metadata

              sig do
                params(
                  metadata: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::OrHash
                ).void
              end
              attr_writer :metadata

              sig do
                returns(T.nilable(
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source
                  ))
              end
              attr_reader :source

              sig do
                params(
                  source: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source::OrHash
                ).void
              end
              attr_writer :source

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Tag
                    ]
                  ))
              end
              attr_reader :tags

              sig do
                params(
                  tags: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Tag::OrHash
                    ]
                ).void
              end
              attr_writer :tags

              sig do
                override
                  .returns({
                    companies:
                      T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Company
                      ],
                    contacts:
                      T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact
                      ],
                    metadata:
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata,
                    source:
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source,
                    tags:
                      T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Tag
                      ]
                  })
              end
              def to_hash; end

              class << self
                # Embedded entities (lead/contact/company/source)
                sig do
                  params(
                    companies: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Company::OrHash
                    ],
                    contacts: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::OrHash
                    ],
                    metadata: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::OrHash,
                    source: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source::OrHash,
                    tags: T::Array[
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Tag::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(companies: nil, contacts: nil, metadata: nil, source: nil, tags: nil); end
              end

              class Company < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { override.returns({ id: Integer, name: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, name: String).returns(T.attached_class) }
                  def new(id: nil, name: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Company,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Contact < Amocrm::Internal::Type::BaseModel
                # Custom fields payload (same as contact create API)
                sig do
                  returns(T.nilable(
                      T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue
                      ]
                    ))
                end
                attr_reader :custom_fields_values

                sig do
                  params(
                    custom_fields_values: T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::OrHash
                      ]
                  ).void
                end
                attr_writer :custom_fields_values

                sig { returns(T.nilable(String)) }
                attr_reader :first_name

                sig { params(first_name: String).void }
                attr_writer :first_name

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :last_name

                sig { params(last_name: String).void }
                attr_writer :last_name

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig do
                  override
                    .returns({
                      id: Integer,
                      custom_fields_values:
                        T::Array[
                          Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue
                        ],
                      first_name: String,
                      last_name: String,
                      name: String
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      id: Integer,
                      custom_fields_values: T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::OrHash
                      ],
                      first_name: String,
                      last_name: String,
                      name: String
                    ).returns(T.attached_class)
                  end
                  def new(
                    id: nil,
                    custom_fields_values: nil, # Custom fields payload (same as contact create API)
                    first_name: nil,
                    last_name: nil,
                    name: nil
); end
                end

                class CustomFieldsValue < Amocrm::Internal::Type::BaseModel
                  # Field code (e.g. PHONE/EMAIL)
                  sig { returns(T.nilable(String)) }
                  attr_reader :field_code

                  sig { params(field_code: String).void }
                  attr_writer :field_code

                  # Use either field_id or field_code (e.g. PHONE/EMAIL)
                  sig { returns(T.nilable(Integer)) }
                  attr_reader :field_id

                  sig { params(field_id: Integer).void }
                  attr_writer :field_id

                  # Values for the field (multiple values allowed)
                  sig do
                    returns(T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value
                      ])
                  end
                  attr_accessor :values

                  sig do
                    override
                      .returns({
                        values:
                          T::Array[
                            Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value
                          ],
                        field_code: String,
                        field_id: Integer
                      })
                  end
                  def to_hash; end

                  class << self
                    sig do
                      params(
                        values: T::Array[
                          Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value::OrHash
                        ],
                        field_code: String,
                        field_id: Integer
                      ).returns(T.attached_class)
                    end
                    def new(
                      values:, # Values for the field (multiple values allowed)
                      field_code: nil, # Field code (e.g. PHONE/EMAIL)
                      field_id: nil # Use either field_id or field_code (e.g. PHONE/EMAIL)
); end
                  end

                  OrHash = T.type_alias do
                      T.any(
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue,
                        Amocrm::Internal::AnyHash
                      )
                    end

                  class Value < Amocrm::Internal::Type::BaseModel
                    # Option code for list/select custom fields (if you use code instead of id)
                    sig { returns(T.nilable(String)) }
                    attr_reader :enum_code

                    sig { params(enum_code: String).void }
                    attr_writer :enum_code

                    # Option id for list/select custom fields (one of predefined options)
                    sig { returns(T.nilable(Integer)) }
                    attr_reader :enum_id

                    sig { params(enum_id: Integer).void }
                    attr_writer :enum_id

                    sig do
                      returns(Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value::Value::Variants)
                    end
                    attr_accessor :value

                    sig do
                      override
                        .returns({
                          value:
                            Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                          enum_code: String,
                          enum_id: Integer
                        })
                    end
                    def to_hash; end

                    class << self
                      sig do
                        params(
                          value: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value::Value::Variants,
                          enum_code: String,
                          enum_id: Integer
                        ).returns(T.attached_class)
                      end
                      def new(
                        value:,
                        enum_code: nil, # Option code for list/select custom fields (if you use code instead of id)
                        enum_id: nil # Option id for list/select custom fields (one of predefined options)
); end
                    end

                    OrHash = T.type_alias do
                        T.any(
                          Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value,
                          Amocrm::Internal::AnyHash
                        )
                      end

                    module Value
                      extend Amocrm::Internal::Type::Union

                      class << self
                        sig do
                          override
                            .returns(T::Array[
                            Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact::CustomFieldsValue::Value::Value::Variants
                          ])
                        end
                        def variants; end
                      end

                      Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                    end
                  end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Contact,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Metadata < Amocrm::Internal::Type::BaseModel
                # Unsorted category
                sig do
                  returns(T.nilable(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::OrSymbol
                    ))
                end
                attr_reader :category

                sig do
                  params(
                    category: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::OrSymbol
                  ).void
                end
                attr_writer :category

                # Form id in your system (string or numeric)
                sig do
                  returns(T.nilable(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::FormID::Variants
                    ))
                end
                attr_reader :form_id

                sig do
                  params(
                    form_id: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::FormID::Variants
                  ).void
                end
                attr_writer :form_id

                # Form name (shown in amoCRM)
                sig { returns(T.nilable(String)) }
                attr_reader :form_name

                sig { params(form_name: String).void }
                attr_writer :form_name

                # Page URL where form lives
                sig { returns(T.nilable(String)) }
                attr_reader :form_page

                sig { params(form_page: String).void }
                attr_writer :form_page

                # Unix timestamp (seconds) when the form was submitted
                sig { returns(T.nilable(Integer)) }
                attr_reader :form_sent_at

                sig { params(form_sent_at: Integer).void }
                attr_writer :form_sent_at

                # Form type code from amoCRM, use only if you know it
                sig { returns(T.nilable(Integer)) }
                attr_reader :form_type

                sig { params(form_type: Integer).void }
                attr_writer :form_type

                # IP address of the submitter
                sig { returns(T.nilable(String)) }
                attr_reader :ip

                sig { params(ip: String).void }
                attr_writer :ip

                # Referrer URL
                sig { returns(T.nilable(String)) }
                attr_reader :referer

                sig { params(referer: String).void }
                attr_writer :referer

                # Visitor uid from tracking, if you have it
                sig { returns(T.nilable(String)) }
                attr_reader :visitor_uid

                sig { params(visitor_uid: String).void }
                attr_writer :visitor_uid

                sig do
                  override
                    .returns({
                      category:
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::OrSymbol,
                      form_id:
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::FormID::Variants,
                      form_name: String,
                      form_page: String,
                      form_sent_at: Integer,
                      form_type: Integer,
                      ip: String,
                      referer: String,
                      visitor_uid: String
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      category: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::OrSymbol,
                      form_id: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::FormID::Variants,
                      form_name: String,
                      form_page: String,
                      form_sent_at: Integer,
                      form_type: Integer,
                      ip: String,
                      referer: String,
                      visitor_uid: String
                    ).returns(T.attached_class)
                  end
                  def new(
                    category: nil, # Unsorted category
                    form_id: nil, # Form id in your system (string or numeric)
                    form_name: nil, # Form name (shown in amoCRM)
                    form_page: nil, # Page URL where form lives
                    form_sent_at: nil, # Unix timestamp (seconds) when the form was submitted
                    form_type: nil, # Form type code from amoCRM, use only if you know it
                    ip: nil, # IP address of the submitter
                    referer: nil, # Referrer URL
                    visitor_uid: nil # Visitor uid from tracking, if you have it
); end
                end

                # Unsorted category
                module Category
                  extend Amocrm::Internal::Type::Enum

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::TaggedSymbol
                      ])
                    end
                    def values; end
                  end

                  CHATS = T.let(
                      :chats,
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::TaggedSymbol
                    )

                  FORMS = T.let(
                      :forms,
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::TaggedSymbol
                    )

                  MAIL = T.let(
                      :mail,
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::TaggedSymbol
                    )

                  OrSymbol = T.type_alias { T.any(Symbol, String) }

                  SIP = T.let(
                      :sip,
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category::TaggedSymbol
                    )

                  TaggedSymbol = T.type_alias do
                      T.all(
                        Symbol,
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::Category
                      )
                    end
                end

                # Form id in your system (string or numeric)
                module FormID
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata::FormID::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer) }
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Metadata,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Source < Amocrm::Internal::Type::BaseModel
                # External id in your system
                sig do
                  returns(T.nilable(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source::ExternalID::Variants
                    ))
                end
                attr_reader :external_id

                sig do
                  params(
                    external_id: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source::ExternalID::Variants
                  ).void
                end
                attr_writer :external_id

                # Source type
                sig { returns(T.nilable(String)) }
                attr_reader :type

                sig { params(type: String).void }
                attr_writer :type

                sig do
                  override
                    .returns({
                      external_id:
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source::ExternalID::Variants,
                      type: String
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      external_id: Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source::ExternalID::Variants,
                      type: String
                    ).returns(T.attached_class)
                  end
                  def new(
                    external_id: nil, # External id in your system
                    type: nil # Source type
); end
                end

                # External id in your system
                module ExternalID
                  extend Amocrm::Internal::Type::Union

                  class << self
                    sig do
                      override
                        .returns(T::Array[
                        Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source::ExternalID::Variants
                      ])
                    end
                    def variants; end
                  end

                  Variants = T.type_alias { T.any(String, Integer, T::Boolean) }
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Source,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Tag < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :color

                sig { params(color: String).void }
                attr_writer :color

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { override.returns({ id: Integer, color: String, name: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
                  def new(id: nil, color: nil, name: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::Embedded::Tag,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end

            class TagsToAdd < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(String)) }
              attr_reader :color

              sig { params(color: String).void }
              attr_writer :color

              sig { returns(T.nilable(Integer)) }
              attr_reader :id

              sig { params(id: Integer).void }
              attr_writer :id

              sig { returns(T.nilable(String)) }
              attr_reader :name

              sig { params(name: String).void }
              attr_writer :name

              sig { override.returns({ id: Integer, color: String, name: String }) }
              def to_hash; end

              class << self
                sig { params(id: Integer, color: String, name: String).returns(T.attached_class) }
                def new(id: nil, color: nil, name: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded::Lead::TagsToAdd,
                    Amocrm::Internal::AnyHash
                  )
                end
            end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::UnsortedLeadCreateFormsParams::Body::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        class Metadata < Amocrm::Internal::Type::BaseModel
          # Form id in your system (string or numeric)
          sig do
            returns(T.nilable(
                Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata::FormID::Variants
              ))
          end
          attr_reader :form_id

          sig { params(form_id: Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata::FormID::Variants).void }
          attr_writer :form_id

          # Form name (shown in amoCRM)
          sig { returns(T.nilable(String)) }
          attr_reader :form_name

          sig { params(form_name: String).void }
          attr_writer :form_name

          # Page URL where form lives
          sig { returns(T.nilable(String)) }
          attr_reader :form_page

          sig { params(form_page: String).void }
          attr_writer :form_page

          # Unix timestamp (seconds) when the form was submitted
          sig { returns(T.nilable(Integer)) }
          attr_reader :form_sent_at

          sig { params(form_sent_at: Integer).void }
          attr_writer :form_sent_at

          # Form type code from amoCRM, use only if you know it
          sig { returns(T.nilable(Integer)) }
          attr_reader :form_type

          sig { params(form_type: Integer).void }
          attr_writer :form_type

          # IP address of the submitter
          sig { returns(T.nilable(String)) }
          attr_reader :ip

          sig { params(ip: String).void }
          attr_writer :ip

          # Referrer URL
          sig { returns(T.nilable(String)) }
          attr_reader :referer

          sig { params(referer: String).void }
          attr_writer :referer

          # Visitor uid from tracking, if you have it
          sig { returns(T.nilable(String)) }
          attr_reader :visitor_uid

          sig { params(visitor_uid: String).void }
          attr_writer :visitor_uid

          sig do
            override
              .returns({
                form_id:
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata::FormID::Variants,
                form_name: String,
                form_page: String,
                form_sent_at: Integer,
                form_type: Integer,
                ip: String,
                referer: String,
                visitor_uid: String
              })
          end
          def to_hash; end

          class << self
            # Form metadata
            sig do
              params(
                form_id: Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata::FormID::Variants,
                form_name: String,
                form_page: String,
                form_sent_at: Integer,
                form_type: Integer,
                ip: String,
                referer: String,
                visitor_uid: String
              ).returns(T.attached_class)
            end
            def new(
              form_id: nil, # Form id in your system (string or numeric)
              form_name: nil, # Form name (shown in amoCRM)
              form_page: nil, # Page URL where form lives
              form_sent_at: nil, # Unix timestamp (seconds) when the form was submitted
              form_type: nil, # Form type code from amoCRM, use only if you know it
              ip: nil, # IP address of the submitter
              referer: nil, # Referrer URL
              visitor_uid: nil # Visitor uid from tracking, if you have it
); end
          end

          # Form id in your system (string or numeric)
          module FormID
            extend Amocrm::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata::FormID::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias { T.any(String, Integer) }
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::UnsortedLeadCreateFormsParams::Body::Metadata,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::UnsortedLeadCreateFormsParams::Body,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::UnsortedLeadCreateFormsParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module UnsortedLeadCreateFormsResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::UnsortedLeadCreateFormsResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UnsortedLeadCreateFormsResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class UnsortedCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::OrHash,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted
                ]
              ))
          end
          attr_reader :unsorted

          sig do
            params(
              unsorted: T::Array[
                  Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::OrHash
                ]
            ).void
          end
          attr_writer :unsorted

          sig do
            override
              .returns({
                unsorted:
                  T::Array[
                    Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                unsorted: T::Array[
                  Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(unsorted: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Unsorted < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            # Echoed request id
            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig { returns(T.nilable(String)) }
            attr_reader :uid

            sig { params(uid: String).void }
            attr_writer :uid

            sig do
              override
                .returns({
                  _embedded:
                    Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded,
                  _links: T.anything,
                  account_id: Integer,
                  request_id: String,
                  uid: String
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  _embedded: Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::OrHash,
                  _links: T.anything,
                  account_id: Integer,
                  request_id: String,
                  uid: String
                ).returns(T.attached_class)
              end
              def new(
                _embedded: nil,
                _links: nil,
                account_id: nil,
                request_id: nil, # Echoed request id
                uid: nil
); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Company
                    ]
                  ))
              end
              attr_reader :companies

              sig do
                params(
                  companies: T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Company::OrHash
                    ]
                ).void
              end
              attr_writer :companies

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Contact
                    ]
                  ))
              end
              attr_reader :contacts

              sig do
                params(
                  contacts: T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Contact::OrHash
                    ]
                ).void
              end
              attr_writer :contacts

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Lead
                    ]
                  ))
              end
              attr_reader :leads

              sig do
                params(
                  leads: T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Lead::OrHash
                    ]
                ).void
              end
              attr_writer :leads

              sig do
                override
                  .returns({
                    companies:
                      T::Array[
                        Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Company
                      ],
                    contacts:
                      T::Array[
                        Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Contact
                      ],
                    leads:
                      T::Array[
                        Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Lead
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    companies: T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Company::OrHash
                    ],
                    contacts: T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Contact::OrHash
                    ],
                    leads: T::Array[
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Lead::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(companies: nil, contacts: nil, leads: nil); end
              end

              class Company < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Company,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Contact < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Contact,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              class Lead < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer, _links: T.anything }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
                  def new(id: nil, _links: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded::Lead,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse::Embedded::Unsorted,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::UnsortedLeadCreateFormsResponse::UnsortedCreateResponse,
            Amocrm::Models::UnsortedLeadCreateFormsResponse::Problem
          )
        end
    end

    class UnsortedLeadDeclineParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      # User id on whose behalf the item is declined
      sig { returns(T.nilable(Integer)) }
      attr_reader :user_id

      sig { params(user_id: Integer).void }
      attr_writer :user_id

      sig { override.returns({ user_id: Integer, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(user_id: Integer, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(
          user_id: nil, # User id on whose behalf the item is declined
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::UnsortedLeadDeclineParams, Amocrm::Internal::AnyHash)
        end
    end

    module UnsortedLeadDeclineResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::UnsortedLeadDeclineResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UnsortedLeadDeclineResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class UnsortedAcceptResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig do
          returns(T.nilable(
              Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            ))
        end
        attr_reader :category

        sig do
          params(
            category: Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::OrSymbol
          ).void
        end
        attr_writer :category

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :pipeline_id

        sig { params(pipeline_id: Integer).void }
        attr_writer :pipeline_id

        sig { returns(T.nilable(String)) }
        attr_reader :uid

        sig { params(uid: String).void }
        attr_writer :uid

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded,
              category:
                Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::TaggedSymbol,
              created_at: Integer,
              pipeline_id: Integer,
              uid: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::OrHash,
              category: Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::OrSymbol,
              created_at: Integer,
              pipeline_id: Integer,
              uid: String
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, category: nil, created_at: nil, pipeline_id: nil, uid: nil); end
        end

        module Category
          extend Amocrm::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::TaggedSymbol
              ])
            end
            def values; end
          end

          CHATS = T.let(
              :chats,
              Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          FORMS = T.let(
              :forms,
              Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          MAIL = T.let(
              :mail,
              Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          SIP = T.let(
              :sip,
              Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(
                Symbol,
                Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Category
              )
            end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Company
                ]
              ))
          end
          attr_reader :companies

          sig do
            params(
              companies: T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Company::OrHash
                ]
            ).void
          end
          attr_writer :companies

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Contact
                ]
              ))
          end
          attr_reader :contacts

          sig do
            params(
              contacts: T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Contact::OrHash
                ]
            ).void
          end
          attr_writer :contacts

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Lead
                ]
              ))
          end
          attr_reader :leads

          sig do
            params(
              leads: T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Lead::OrHash
                ]
            ).void
          end
          attr_writer :leads

          sig do
            override
              .returns({
                companies:
                  T::Array[
                    Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Company
                  ],
                contacts:
                  T::Array[
                    Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Contact
                  ],
                leads:
                  T::Array[
                    Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Lead
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                companies: T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Company::OrHash
                ],
                contacts: T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Contact::OrHash
                ],
                leads: T::Array[
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Lead::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(companies: nil, contacts: nil, leads: nil); end
          end

          class Company < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Company,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Contact < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Contact,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          class Lead < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { override.returns({ id: Integer, _links: T.anything }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, _links: T.anything).returns(T.attached_class) }
              def new(id: nil, _links: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded::Lead,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::UnsortedLeadDeclineResponse::UnsortedAcceptResponse,
            Amocrm::Models::UnsortedLeadDeclineResponse::Problem
          )
        end
    end

    class UserCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T::Array[Amocrm::UserCreateParams::Body]) }
      attr_accessor :body

      sig do
        override
          .returns({
            body: T::Array[Amocrm::UserCreateParams::Body],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            body: T::Array[Amocrm::UserCreateParams::Body::OrHash],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(body:, request_options: {}); end
      end

      class Body < Amocrm::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :email

        sig { returns(T.nilable(String)) }
        attr_reader :lang

        sig { params(lang: String).void }
        attr_writer :lang

        sig { returns(String) }
        attr_accessor :name

        sig { returns(String) }
        attr_accessor :password

        sig { returns(T.nilable(String)) }
        attr_reader :request_id

        sig { params(request_id: String).void }
        attr_writer :request_id

        sig { returns(T.nilable(Amocrm::UserCreateParams::Body::Rights)) }
        attr_reader :rights

        sig { params(rights: Amocrm::UserCreateParams::Body::Rights::OrHash).void }
        attr_writer :rights

        sig do
          override
            .returns({
              email: String,
              name: String,
              password: String,
              lang: String,
              request_id: String,
              rights: Amocrm::UserCreateParams::Body::Rights
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              email: String,
              name: String,
              password: String,
              lang: String,
              request_id: String,
              rights: Amocrm::UserCreateParams::Body::Rights::OrHash
            ).returns(T.attached_class)
          end
          def new(email:, name:, password:, lang: nil, request_id: nil, rights: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::UserCreateParams::Body, Amocrm::Internal::AnyHash)
          end

        class Rights < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :catalog_access

          sig { params(catalog_access: T::Boolean).void }
          attr_writer :catalog_access

          sig { returns(T.nilable(T.anything)) }
          attr_reader :companies

          sig { params(companies: T.anything).void }
          attr_writer :companies

          sig { returns(T.nilable(T.anything)) }
          attr_reader :contacts

          sig { params(contacts: T.anything).void }
          attr_writer :contacts

          sig { returns(T.nilable(Integer)) }
          attr_accessor :group_id

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_active

          sig { params(is_active: T::Boolean).void }
          attr_writer :is_active

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_admin

          sig { params(is_admin: T::Boolean).void }
          attr_writer :is_admin

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_free

          sig { params(is_free: T::Boolean).void }
          attr_writer :is_free

          sig { returns(T.nilable(T.anything)) }
          attr_reader :leads

          sig { params(leads: T.anything).void }
          attr_writer :leads

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :mail_access

          sig { params(mail_access: T::Boolean).void }
          attr_writer :mail_access

          sig { returns(T.nilable(Integer)) }
          attr_accessor :role_id

          sig do
            returns(T.nilable(
                T::Array[Amocrm::UserCreateParams::Body::Rights::StatusRight]
              ))
          end
          attr_accessor :status_rights

          sig { returns(T.nilable(T.anything)) }
          attr_reader :tasks

          sig { params(tasks: T.anything).void }
          attr_writer :tasks

          sig do
            override
              .returns({
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights:
                  T.nilable(
                    T::Array[
                      Amocrm::UserCreateParams::Body::Rights::StatusRight
                    ]
                  ),
                tasks: T.anything
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights: T.nilable(
                  T::Array[
                    Amocrm::UserCreateParams::Body::Rights::StatusRight::OrHash
                  ]
                ),
                tasks: T.anything
              ).returns(T.attached_class)
            end
            def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::UserCreateParams::Body::Rights,
                Amocrm::Internal::AnyHash
              )
            end

          class StatusRight < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(T.anything)) }
            attr_reader :rights

            sig { params(rights: T.anything).void }
            attr_writer :rights

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            sig do
              override
                .returns({
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                ).returns(T.attached_class)
              end
              def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::UserCreateParams::Body::Rights::StatusRight,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::UserCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module UserCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::UserCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UserCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class UserCreateResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User
                ]
              ))
          end
          attr_reader :users

          sig do
            params(
              users: T::Array[
                  Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::OrHash
                ]
            ).void
          end
          attr_writer :users

          sig do
            override
              .returns({
                users:
                  T::Array[
                    Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                users: T::Array[
                  Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(users: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class User < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(String)) }
            attr_accessor :amojo_id

            sig { returns(T.nilable(String)) }
            attr_reader :email

            sig { params(email: String).void }
            attr_writer :email

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :lang

            sig { params(lang: String).void }
            attr_writer :lang

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_accessor :phone_number

            sig { returns(T.nilable(String)) }
            attr_reader :request_id

            sig { params(request_id: String).void }
            attr_writer :request_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights
                ))
            end
            attr_reader :rights

            sig do
              params(
                rights: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights::OrHash
              ).void
            end
            attr_writer :rights

            sig { returns(T.nilable(String)) }
            attr_accessor :user_rank

            sig { returns(T.nilable(String)) }
            attr_accessor :uuid

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded,
                  _links: T.anything,
                  amojo_id: T.nilable(String),
                  email: String,
                  lang: String,
                  name: String,
                  phone_number: T.nilable(String),
                  request_id: String,
                  rights:
                    Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights,
                  user_rank: T.nilable(String),
                  uuid: T.nilable(String)
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::OrHash,
                  _links: T.anything,
                  amojo_id: T.nilable(String),
                  email: String,
                  lang: String,
                  name: String,
                  phone_number: T.nilable(String),
                  request_id: String,
                  rights: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights::OrHash,
                  user_rank: T.nilable(String),
                  uuid: T.nilable(String)
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, amojo_id: nil, email: nil, lang: nil, name: nil, phone_number: nil, request_id: nil, rights: nil, user_rank: nil, uuid: nil); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Group
                    ]
                  ))
              end
              attr_reader :groups

              sig do
                params(
                  groups: T::Array[
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Group::OrHash
                    ]
                ).void
              end
              attr_writer :groups

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role
                    ]
                  ))
              end
              attr_reader :roles

              sig do
                params(
                  roles: T::Array[
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::OrHash
                    ]
                ).void
              end
              attr_writer :roles

              sig do
                override
                  .returns({
                    groups:
                      T::Array[
                        Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Group
                      ],
                    roles:
                      T::Array[
                        Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    groups: T::Array[
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Group::OrHash
                    ],
                    roles: T::Array[
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(groups: nil, roles: nil); end
              end

              class Group < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { returns(T.nilable(String)) }
                attr_reader :uuid

                sig { params(uuid: String).void }
                attr_writer :uuid

                sig { override.returns({ id: Integer, name: String, uuid: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, name: String, uuid: String).returns(T.attached_class) }
                  def new(id: nil, name: nil, uuid: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Group,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Role < Amocrm::Internal::Type::BaseModel
                sig do
                  returns(T.nilable(
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded
                    ))
                end
                attr_reader :_embedded

                sig do
                  params(
                    _embedded: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded::OrHash
                  ).void
                end
                attr_writer :_embedded

                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig do
                  returns(T.nilable(
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights
                    ))
                end
                attr_reader :rights

                sig do
                  params(
                    rights: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights::OrHash
                  ).void
                end
                attr_writer :rights

                sig do
                  override
                    .returns({
                      id: Integer,
                      _embedded:
                        Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded,
                      _links: T.anything,
                      name: String,
                      rights:
                        Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      id: Integer,
                      _embedded: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded::OrHash,
                      _links: T.anything,
                      name: String,
                      rights: Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights::OrHash
                    ).returns(T.attached_class)
                  end
                  def new(id: nil, _embedded: nil, _links: nil, name: nil, rights: nil); end
                end

                class Embedded < Amocrm::Internal::Type::BaseModel
                  sig do
                    returns(T.nilable(
                        T::Array[
                          Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded::User
                        ]
                      ))
                  end
                  attr_reader :users

                  sig do
                    params(
                      users: T::Array[
                          Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded::User::OrHash
                        ]
                    ).void
                  end
                  attr_writer :users

                  sig do
                    override
                      .returns({
                        users:
                          T::Array[
                            Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded::User
                          ]
                      })
                  end
                  def to_hash; end

                  class << self
                    sig do
                      params(
                        users: T::Array[
                          Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded::User::OrHash
                        ]
                      ).returns(T.attached_class)
                    end
                    def new(users: nil); end
                  end

                  OrHash = T.type_alias do
                      T.any(
                        Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded,
                        Amocrm::Internal::AnyHash
                      )
                    end

                  class User < Amocrm::Internal::Type::BaseModel
                    sig { returns(T.nilable(Integer)) }
                    attr_reader :id

                    sig { params(id: Integer).void }
                    attr_writer :id

                    sig { override.returns({ id: Integer }) }
                    def to_hash; end

                    class << self
                      sig { params(id: Integer).returns(T.attached_class) }
                      def new(id: nil); end
                    end

                    OrHash = T.type_alias do
                        T.any(
                          Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Embedded::User,
                          Amocrm::Internal::AnyHash
                        )
                      end
                  end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role,
                      Amocrm::Internal::AnyHash
                    )
                  end

                class Rights < Amocrm::Internal::Type::BaseModel
                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :catalog_access

                  sig { params(catalog_access: T::Boolean).void }
                  attr_writer :catalog_access

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :companies

                  sig { params(companies: T.anything).void }
                  attr_writer :companies

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :contacts

                  sig { params(contacts: T.anything).void }
                  attr_writer :contacts

                  sig { returns(T.nilable(Integer)) }
                  attr_accessor :group_id

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :is_active

                  sig { params(is_active: T::Boolean).void }
                  attr_writer :is_active

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :is_admin

                  sig { params(is_admin: T::Boolean).void }
                  attr_writer :is_admin

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :is_free

                  sig { params(is_free: T::Boolean).void }
                  attr_writer :is_free

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :leads

                  sig { params(leads: T.anything).void }
                  attr_writer :leads

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :mail_access

                  sig { params(mail_access: T::Boolean).void }
                  attr_writer :mail_access

                  sig { returns(T.nilable(Integer)) }
                  attr_accessor :role_id

                  sig do
                    returns(T.nilable(
                        T::Array[
                          Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights::StatusRight
                        ]
                      ))
                  end
                  attr_accessor :status_rights

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :tasks

                  sig { params(tasks: T.anything).void }
                  attr_writer :tasks

                  sig do
                    override
                      .returns({
                        catalog_access: T::Boolean,
                        companies: T.anything,
                        contacts: T.anything,
                        group_id: T.nilable(Integer),
                        is_active: T::Boolean,
                        is_admin: T::Boolean,
                        is_free: T::Boolean,
                        leads: T.anything,
                        mail_access: T::Boolean,
                        role_id: T.nilable(Integer),
                        status_rights:
                          T.nilable(
                            T::Array[
                              Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights::StatusRight
                            ]
                          ),
                        tasks: T.anything
                      })
                  end
                  def to_hash; end

                  class << self
                    sig do
                      params(
                        catalog_access: T::Boolean,
                        companies: T.anything,
                        contacts: T.anything,
                        group_id: T.nilable(Integer),
                        is_active: T::Boolean,
                        is_admin: T::Boolean,
                        is_free: T::Boolean,
                        leads: T.anything,
                        mail_access: T::Boolean,
                        role_id: T.nilable(Integer),
                        status_rights: T.nilable(
                          T::Array[
                            Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights::StatusRight::OrHash
                          ]
                        ),
                        tasks: T.anything
                      ).returns(T.attached_class)
                    end
                    def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
                  end

                  OrHash = T.type_alias do
                      T.any(
                        Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights,
                        Amocrm::Internal::AnyHash
                      )
                    end

                  class StatusRight < Amocrm::Internal::Type::BaseModel
                    sig { returns(T.nilable(String)) }
                    attr_reader :entity_type

                    sig { params(entity_type: String).void }
                    attr_writer :entity_type

                    sig { returns(T.nilable(Integer)) }
                    attr_reader :pipeline_id

                    sig { params(pipeline_id: Integer).void }
                    attr_writer :pipeline_id

                    sig { returns(T.nilable(T.anything)) }
                    attr_reader :rights

                    sig { params(rights: T.anything).void }
                    attr_writer :rights

                    sig { returns(T.nilable(Integer)) }
                    attr_reader :status_id

                    sig { params(status_id: Integer).void }
                    attr_writer :status_id

                    sig do
                      override
                        .returns({
                          entity_type: String,
                          pipeline_id: Integer,
                          rights: T.anything,
                          status_id: Integer
                        })
                    end
                    def to_hash; end

                    class << self
                      sig do
                        params(
                          entity_type: String,
                          pipeline_id: Integer,
                          rights: T.anything,
                          status_id: Integer
                        ).returns(T.attached_class)
                      end
                      def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
                    end

                    OrHash = T.type_alias do
                        T.any(
                          Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Embedded::Role::Rights::StatusRight,
                          Amocrm::Internal::AnyHash
                        )
                      end
                  end
                end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User,
                  Amocrm::Internal::AnyHash
                )
              end

            class Rights < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :catalog_access

              sig { params(catalog_access: T::Boolean).void }
              attr_writer :catalog_access

              sig { returns(T.nilable(T.anything)) }
              attr_reader :companies

              sig { params(companies: T.anything).void }
              attr_writer :companies

              sig { returns(T.nilable(T.anything)) }
              attr_reader :contacts

              sig { params(contacts: T.anything).void }
              attr_writer :contacts

              sig { returns(T.nilable(Integer)) }
              attr_accessor :group_id

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_active

              sig { params(is_active: T::Boolean).void }
              attr_writer :is_active

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_admin

              sig { params(is_admin: T::Boolean).void }
              attr_writer :is_admin

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_free

              sig { params(is_free: T::Boolean).void }
              attr_writer :is_free

              sig { returns(T.nilable(T.anything)) }
              attr_reader :leads

              sig { params(leads: T.anything).void }
              attr_writer :leads

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :mail_access

              sig { params(mail_access: T::Boolean).void }
              attr_writer :mail_access

              sig { returns(T.nilable(Integer)) }
              attr_accessor :role_id

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights::StatusRight
                    ]
                  ))
              end
              attr_accessor :status_rights

              sig { returns(T.nilable(T.anything)) }
              attr_reader :tasks

              sig { params(tasks: T.anything).void }
              attr_writer :tasks

              sig do
                override
                  .returns({
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights:
                      T.nilable(
                        T::Array[
                          Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights::StatusRight
                        ]
                      ),
                    tasks: T.anything
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights: T.nilable(
                      T::Array[
                        Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights::StatusRight::OrHash
                      ]
                    ),
                    tasks: T.anything
                  ).returns(T.attached_class)
                end
                def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights,
                    Amocrm::Internal::AnyHash
                  )
                end

              class StatusRight < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :entity_type

                sig { params(entity_type: String).void }
                attr_writer :entity_type

                sig { returns(T.nilable(Integer)) }
                attr_reader :pipeline_id

                sig { params(pipeline_id: Integer).void }
                attr_writer :pipeline_id

                sig { returns(T.nilable(T.anything)) }
                attr_reader :rights

                sig { params(rights: T.anything).void }
                attr_writer :rights

                sig { returns(T.nilable(Integer)) }
                attr_reader :status_id

                sig { params(status_id: Integer).void }
                attr_writer :status_id

                sig do
                  override
                    .returns({
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserCreateResponse::UserCreateResponse::Embedded::User::Rights::StatusRight,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UserCreateResponse::UserCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::UserCreateResponse::UserCreateResponse,
            Amocrm::Models::UserCreateResponse::Problem
          )
        end
    end

    class UserGetByIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::UserGetByIDParams, Amocrm::Internal::AnyHash)
        end
    end

    module UserGetByIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::UserGetByIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UserGetByIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class User < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Amocrm::Models::UserGetByIDResponse::User::Embedded)) }
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::UserGetByIDResponse::User::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(String)) }
        attr_accessor :amojo_id

        sig { returns(T.nilable(String)) }
        attr_reader :email

        sig { params(email: String).void }
        attr_writer :email

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(String)) }
        attr_reader :lang

        sig { params(lang: String).void }
        attr_writer :lang

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(String)) }
        attr_accessor :phone_number

        sig { returns(T.nilable(Amocrm::Models::UserGetByIDResponse::User::Rights)) }
        attr_reader :rights

        sig { params(rights: Amocrm::Models::UserGetByIDResponse::User::Rights::OrHash).void }
        attr_writer :rights

        sig { returns(T.nilable(String)) }
        attr_accessor :user_rank

        sig { returns(T.nilable(String)) }
        attr_accessor :uuid

        sig do
          override
            .returns({
              id: Integer,
              _embedded: Amocrm::Models::UserGetByIDResponse::User::Embedded,
              _links: T.anything,
              amojo_id: T.nilable(String),
              email: String,
              lang: String,
              name: String,
              phone_number: T.nilable(String),
              rights: Amocrm::Models::UserGetByIDResponse::User::Rights,
              user_rank: T.nilable(String),
              uuid: T.nilable(String)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _embedded: Amocrm::Models::UserGetByIDResponse::User::Embedded::OrHash,
              _links: T.anything,
              amojo_id: T.nilable(String),
              email: String,
              lang: String,
              name: String,
              phone_number: T.nilable(String),
              rights: Amocrm::Models::UserGetByIDResponse::User::Rights::OrHash,
              user_rank: T.nilable(String),
              uuid: T.nilable(String)
            ).returns(T.attached_class)
          end
          def new(id: nil, _embedded: nil, _links: nil, amojo_id: nil, email: nil, lang: nil, name: nil, phone_number: nil, rights: nil, user_rank: nil, uuid: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Group
                ]
              ))
          end
          attr_reader :groups

          sig do
            params(
              groups: T::Array[
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Group::OrHash
                ]
            ).void
          end
          attr_writer :groups

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Role
                ]
              ))
          end
          attr_reader :roles

          sig do
            params(
              roles: T::Array[
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::OrHash
                ]
            ).void
          end
          attr_writer :roles

          sig do
            override
              .returns({
                groups:
                  T::Array[
                    Amocrm::Models::UserGetByIDResponse::User::Embedded::Group
                  ],
                roles:
                  T::Array[
                    Amocrm::Models::UserGetByIDResponse::User::Embedded::Role
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                groups: T::Array[
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Group::OrHash
                ],
                roles: T::Array[
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(groups: nil, roles: nil); end
          end

          class Group < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_reader :uuid

            sig { params(uuid: String).void }
            attr_writer :uuid

            sig { override.returns({ id: Integer, name: String, uuid: String }) }
            def to_hash; end

            class << self
              sig { params(id: Integer, name: String, uuid: String).returns(T.attached_class) }
              def new(id: nil, name: nil, uuid: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Group,
                  Amocrm::Internal::AnyHash
                )
              end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::UserGetByIDResponse::User::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Role < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded
                ))
            end
            attr_reader :_embedded

            sig { params(_embedded: Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded::OrHash).void }
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig do
              returns(T.nilable(
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights
                ))
            end
            attr_reader :rights

            sig { params(rights: Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights::OrHash).void }
            attr_writer :rights

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded,
                  _links: T.anything,
                  name: String,
                  rights:
                    Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded::OrHash,
                  _links: T.anything,
                  name: String,
                  rights: Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights::OrHash
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, name: nil, rights: nil); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded::User
                    ]
                  ))
              end
              attr_reader :users

              sig do
                params(
                  users: T::Array[
                      Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded::User::OrHash
                    ]
                ).void
              end
              attr_writer :users

              sig do
                override
                  .returns({
                    users:
                      T::Array[
                        Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded::User
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    users: T::Array[
                      Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded::User::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(users: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class User < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { override.returns({ id: Integer }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer).returns(T.attached_class) }
                  def new(id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Embedded::User,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UserGetByIDResponse::User::Embedded::Role,
                  Amocrm::Internal::AnyHash
                )
              end

            class Rights < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :catalog_access

              sig { params(catalog_access: T::Boolean).void }
              attr_writer :catalog_access

              sig { returns(T.nilable(T.anything)) }
              attr_reader :companies

              sig { params(companies: T.anything).void }
              attr_writer :companies

              sig { returns(T.nilable(T.anything)) }
              attr_reader :contacts

              sig { params(contacts: T.anything).void }
              attr_writer :contacts

              sig { returns(T.nilable(Integer)) }
              attr_accessor :group_id

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_active

              sig { params(is_active: T::Boolean).void }
              attr_writer :is_active

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_admin

              sig { params(is_admin: T::Boolean).void }
              attr_writer :is_admin

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_free

              sig { params(is_free: T::Boolean).void }
              attr_writer :is_free

              sig { returns(T.nilable(T.anything)) }
              attr_reader :leads

              sig { params(leads: T.anything).void }
              attr_writer :leads

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :mail_access

              sig { params(mail_access: T::Boolean).void }
              attr_writer :mail_access

              sig { returns(T.nilable(Integer)) }
              attr_accessor :role_id

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights::StatusRight
                    ]
                  ))
              end
              attr_accessor :status_rights

              sig { returns(T.nilable(T.anything)) }
              attr_reader :tasks

              sig { params(tasks: T.anything).void }
              attr_writer :tasks

              sig do
                override
                  .returns({
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights:
                      T.nilable(
                        T::Array[
                          Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights::StatusRight
                        ]
                      ),
                    tasks: T.anything
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights: T.nilable(
                      T::Array[
                        Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights::StatusRight::OrHash
                      ]
                    ),
                    tasks: T.anything
                  ).returns(T.attached_class)
                end
                def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights,
                    Amocrm::Internal::AnyHash
                  )
                end

              class StatusRight < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :entity_type

                sig { params(entity_type: String).void }
                attr_writer :entity_type

                sig { returns(T.nilable(Integer)) }
                attr_reader :pipeline_id

                sig { params(pipeline_id: Integer).void }
                attr_writer :pipeline_id

                sig { returns(T.nilable(T.anything)) }
                attr_reader :rights

                sig { params(rights: T.anything).void }
                attr_writer :rights

                sig { returns(T.nilable(Integer)) }
                attr_reader :status_id

                sig { params(status_id: Integer).void }
                attr_writer :status_id

                sig do
                  override
                    .returns({
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserGetByIDResponse::User::Embedded::Role::Rights::StatusRight,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UserGetByIDResponse::User,
              Amocrm::Internal::AnyHash
            )
          end

        class Rights < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :catalog_access

          sig { params(catalog_access: T::Boolean).void }
          attr_writer :catalog_access

          sig { returns(T.nilable(T.anything)) }
          attr_reader :companies

          sig { params(companies: T.anything).void }
          attr_writer :companies

          sig { returns(T.nilable(T.anything)) }
          attr_reader :contacts

          sig { params(contacts: T.anything).void }
          attr_writer :contacts

          sig { returns(T.nilable(Integer)) }
          attr_accessor :group_id

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_active

          sig { params(is_active: T::Boolean).void }
          attr_writer :is_active

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_admin

          sig { params(is_admin: T::Boolean).void }
          attr_writer :is_admin

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_free

          sig { params(is_free: T::Boolean).void }
          attr_writer :is_free

          sig { returns(T.nilable(T.anything)) }
          attr_reader :leads

          sig { params(leads: T.anything).void }
          attr_writer :leads

          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :mail_access

          sig { params(mail_access: T::Boolean).void }
          attr_writer :mail_access

          sig { returns(T.nilable(Integer)) }
          attr_accessor :role_id

          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UserGetByIDResponse::User::Rights::StatusRight
                ]
              ))
          end
          attr_accessor :status_rights

          sig { returns(T.nilable(T.anything)) }
          attr_reader :tasks

          sig { params(tasks: T.anything).void }
          attr_writer :tasks

          sig do
            override
              .returns({
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights:
                  T.nilable(
                    T::Array[
                      Amocrm::Models::UserGetByIDResponse::User::Rights::StatusRight
                    ]
                  ),
                tasks: T.anything
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                catalog_access: T::Boolean,
                companies: T.anything,
                contacts: T.anything,
                group_id: T.nilable(Integer),
                is_active: T::Boolean,
                is_admin: T::Boolean,
                is_free: T::Boolean,
                leads: T.anything,
                mail_access: T::Boolean,
                role_id: T.nilable(Integer),
                status_rights: T.nilable(
                  T::Array[
                    Amocrm::Models::UserGetByIDResponse::User::Rights::StatusRight::OrHash
                  ]
                ),
                tasks: T.anything
              ).returns(T.attached_class)
            end
            def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::UserGetByIDResponse::User::Rights,
                Amocrm::Internal::AnyHash
              )
            end

          class StatusRight < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(String)) }
            attr_reader :entity_type

            sig { params(entity_type: String).void }
            attr_writer :entity_type

            sig { returns(T.nilable(Integer)) }
            attr_reader :pipeline_id

            sig { params(pipeline_id: Integer).void }
            attr_writer :pipeline_id

            sig { returns(T.nilable(T.anything)) }
            attr_reader :rights

            sig { params(rights: T.anything).void }
            attr_writer :rights

            sig { returns(T.nilable(Integer)) }
            attr_reader :status_id

            sig { params(status_id: Integer).void }
            attr_writer :status_id

            sig do
              override
                .returns({
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  entity_type: String,
                  pipeline_id: Integer,
                  rights: T.anything,
                  status_id: Integer
                ).returns(T.attached_class)
              end
              def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UserGetByIDResponse::User::Rights::StatusRight,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::UserGetByIDResponse::User,
            Amocrm::Models::UserGetByIDResponse::Problem
          )
        end
    end

    class UserListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(limit: nil, page: nil, with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::UserListParams, Amocrm::Internal::AnyHash)
        end
    end

    module UserListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::UserListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UserListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class UserListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::UserListResponse::UserListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::UserListResponse::UserListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page_count

        sig { params(_page_count: Integer).void }
        attr_writer :_page_count

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::UserListResponse::UserListResponse::Embedded,
              _links: T.anything,
              _page: Integer,
              _page_count: Integer,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::UserListResponse::UserListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer,
              _page_count: Integer,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil, _page_count: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::UserListResponse::UserListResponse::Embedded::User
                ]
              ))
          end
          attr_reader :users

          sig do
            params(
              users: T::Array[
                  Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::OrHash
                ]
            ).void
          end
          attr_writer :users

          sig do
            override
              .returns({
                users:
                  T::Array[
                    Amocrm::Models::UserListResponse::UserListResponse::Embedded::User
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                users: T::Array[
                  Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(users: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::UserListResponse::UserListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class User < Amocrm::Internal::Type::BaseModel
            sig do
              returns(T.nilable(
                  Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded
                ))
            end
            attr_reader :_embedded

            sig do
              params(
                _embedded: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::OrHash
              ).void
            end
            attr_writer :_embedded

            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(String)) }
            attr_accessor :amojo_id

            sig { returns(T.nilable(String)) }
            attr_reader :email

            sig { params(email: String).void }
            attr_writer :email

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(String)) }
            attr_reader :lang

            sig { params(lang: String).void }
            attr_writer :lang

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(String)) }
            attr_accessor :phone_number

            sig do
              returns(T.nilable(
                  Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights
                ))
            end
            attr_reader :rights

            sig do
              params(
                rights: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights::OrHash
              ).void
            end
            attr_writer :rights

            sig { returns(T.nilable(String)) }
            attr_accessor :user_rank

            sig { returns(T.nilable(String)) }
            attr_accessor :uuid

            sig do
              override
                .returns({
                  id: Integer,
                  _embedded:
                    Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded,
                  _links: T.anything,
                  amojo_id: T.nilable(String),
                  email: String,
                  lang: String,
                  name: String,
                  phone_number: T.nilable(String),
                  rights:
                    Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights,
                  user_rank: T.nilable(String),
                  uuid: T.nilable(String)
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _embedded: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::OrHash,
                  _links: T.anything,
                  amojo_id: T.nilable(String),
                  email: String,
                  lang: String,
                  name: String,
                  phone_number: T.nilable(String),
                  rights: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights::OrHash,
                  user_rank: T.nilable(String),
                  uuid: T.nilable(String)
                ).returns(T.attached_class)
              end
              def new(id: nil, _embedded: nil, _links: nil, amojo_id: nil, email: nil, lang: nil, name: nil, phone_number: nil, rights: nil, user_rank: nil, uuid: nil); end
            end

            class Embedded < Amocrm::Internal::Type::BaseModel
              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Group
                    ]
                  ))
              end
              attr_reader :groups

              sig do
                params(
                  groups: T::Array[
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Group::OrHash
                    ]
                ).void
              end
              attr_writer :groups

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role
                    ]
                  ))
              end
              attr_reader :roles

              sig do
                params(
                  roles: T::Array[
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::OrHash
                    ]
                ).void
              end
              attr_writer :roles

              sig do
                override
                  .returns({
                    groups:
                      T::Array[
                        Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Group
                      ],
                    roles:
                      T::Array[
                        Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role
                      ]
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    groups: T::Array[
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Group::OrHash
                    ],
                    roles: T::Array[
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::OrHash
                    ]
                  ).returns(T.attached_class)
                end
                def new(groups: nil, roles: nil); end
              end

              class Group < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig { returns(T.nilable(String)) }
                attr_reader :uuid

                sig { params(uuid: String).void }
                attr_writer :uuid

                sig { override.returns({ id: Integer, name: String, uuid: String }) }
                def to_hash; end

                class << self
                  sig { params(id: Integer, name: String, uuid: String).returns(T.attached_class) }
                  def new(id: nil, name: nil, uuid: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Group,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded,
                    Amocrm::Internal::AnyHash
                  )
                end

              class Role < Amocrm::Internal::Type::BaseModel
                sig do
                  returns(T.nilable(
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded
                    ))
                end
                attr_reader :_embedded

                sig do
                  params(
                    _embedded: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded::OrHash
                  ).void
                end
                attr_writer :_embedded

                sig { returns(T.nilable(T.anything)) }
                attr_reader :_links

                sig { params(_links: T.anything).void }
                attr_writer :_links

                sig { returns(T.nilable(Integer)) }
                attr_reader :id

                sig { params(id: Integer).void }
                attr_writer :id

                sig { returns(T.nilable(String)) }
                attr_reader :name

                sig { params(name: String).void }
                attr_writer :name

                sig do
                  returns(T.nilable(
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights
                    ))
                end
                attr_reader :rights

                sig do
                  params(
                    rights: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights::OrHash
                  ).void
                end
                attr_writer :rights

                sig do
                  override
                    .returns({
                      id: Integer,
                      _embedded:
                        Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded,
                      _links: T.anything,
                      name: String,
                      rights:
                        Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      id: Integer,
                      _embedded: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded::OrHash,
                      _links: T.anything,
                      name: String,
                      rights: Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights::OrHash
                    ).returns(T.attached_class)
                  end
                  def new(id: nil, _embedded: nil, _links: nil, name: nil, rights: nil); end
                end

                class Embedded < Amocrm::Internal::Type::BaseModel
                  sig do
                    returns(T.nilable(
                        T::Array[
                          Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded::User
                        ]
                      ))
                  end
                  attr_reader :users

                  sig do
                    params(
                      users: T::Array[
                          Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded::User::OrHash
                        ]
                    ).void
                  end
                  attr_writer :users

                  sig do
                    override
                      .returns({
                        users:
                          T::Array[
                            Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded::User
                          ]
                      })
                  end
                  def to_hash; end

                  class << self
                    sig do
                      params(
                        users: T::Array[
                          Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded::User::OrHash
                        ]
                      ).returns(T.attached_class)
                    end
                    def new(users: nil); end
                  end

                  OrHash = T.type_alias do
                      T.any(
                        Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded,
                        Amocrm::Internal::AnyHash
                      )
                    end

                  class User < Amocrm::Internal::Type::BaseModel
                    sig { returns(T.nilable(Integer)) }
                    attr_reader :id

                    sig { params(id: Integer).void }
                    attr_writer :id

                    sig { override.returns({ id: Integer }) }
                    def to_hash; end

                    class << self
                      sig { params(id: Integer).returns(T.attached_class) }
                      def new(id: nil); end
                    end

                    OrHash = T.type_alias do
                        T.any(
                          Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Embedded::User,
                          Amocrm::Internal::AnyHash
                        )
                      end
                  end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role,
                      Amocrm::Internal::AnyHash
                    )
                  end

                class Rights < Amocrm::Internal::Type::BaseModel
                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :catalog_access

                  sig { params(catalog_access: T::Boolean).void }
                  attr_writer :catalog_access

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :companies

                  sig { params(companies: T.anything).void }
                  attr_writer :companies

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :contacts

                  sig { params(contacts: T.anything).void }
                  attr_writer :contacts

                  sig { returns(T.nilable(Integer)) }
                  attr_accessor :group_id

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :is_active

                  sig { params(is_active: T::Boolean).void }
                  attr_writer :is_active

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :is_admin

                  sig { params(is_admin: T::Boolean).void }
                  attr_writer :is_admin

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :is_free

                  sig { params(is_free: T::Boolean).void }
                  attr_writer :is_free

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :leads

                  sig { params(leads: T.anything).void }
                  attr_writer :leads

                  sig { returns(T.nilable(T::Boolean)) }
                  attr_reader :mail_access

                  sig { params(mail_access: T::Boolean).void }
                  attr_writer :mail_access

                  sig { returns(T.nilable(Integer)) }
                  attr_accessor :role_id

                  sig do
                    returns(T.nilable(
                        T::Array[
                          Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights::StatusRight
                        ]
                      ))
                  end
                  attr_accessor :status_rights

                  sig { returns(T.nilable(T.anything)) }
                  attr_reader :tasks

                  sig { params(tasks: T.anything).void }
                  attr_writer :tasks

                  sig do
                    override
                      .returns({
                        catalog_access: T::Boolean,
                        companies: T.anything,
                        contacts: T.anything,
                        group_id: T.nilable(Integer),
                        is_active: T::Boolean,
                        is_admin: T::Boolean,
                        is_free: T::Boolean,
                        leads: T.anything,
                        mail_access: T::Boolean,
                        role_id: T.nilable(Integer),
                        status_rights:
                          T.nilable(
                            T::Array[
                              Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights::StatusRight
                            ]
                          ),
                        tasks: T.anything
                      })
                  end
                  def to_hash; end

                  class << self
                    sig do
                      params(
                        catalog_access: T::Boolean,
                        companies: T.anything,
                        contacts: T.anything,
                        group_id: T.nilable(Integer),
                        is_active: T::Boolean,
                        is_admin: T::Boolean,
                        is_free: T::Boolean,
                        leads: T.anything,
                        mail_access: T::Boolean,
                        role_id: T.nilable(Integer),
                        status_rights: T.nilable(
                          T::Array[
                            Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights::StatusRight::OrHash
                          ]
                        ),
                        tasks: T.anything
                      ).returns(T.attached_class)
                    end
                    def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
                  end

                  OrHash = T.type_alias do
                      T.any(
                        Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights,
                        Amocrm::Internal::AnyHash
                      )
                    end

                  class StatusRight < Amocrm::Internal::Type::BaseModel
                    sig { returns(T.nilable(String)) }
                    attr_reader :entity_type

                    sig { params(entity_type: String).void }
                    attr_writer :entity_type

                    sig { returns(T.nilable(Integer)) }
                    attr_reader :pipeline_id

                    sig { params(pipeline_id: Integer).void }
                    attr_writer :pipeline_id

                    sig { returns(T.nilable(T.anything)) }
                    attr_reader :rights

                    sig { params(rights: T.anything).void }
                    attr_writer :rights

                    sig { returns(T.nilable(Integer)) }
                    attr_reader :status_id

                    sig { params(status_id: Integer).void }
                    attr_writer :status_id

                    sig do
                      override
                        .returns({
                          entity_type: String,
                          pipeline_id: Integer,
                          rights: T.anything,
                          status_id: Integer
                        })
                    end
                    def to_hash; end

                    class << self
                      sig do
                        params(
                          entity_type: String,
                          pipeline_id: Integer,
                          rights: T.anything,
                          status_id: Integer
                        ).returns(T.attached_class)
                      end
                      def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
                    end

                    OrHash = T.type_alias do
                        T.any(
                          Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Embedded::Role::Rights::StatusRight,
                          Amocrm::Internal::AnyHash
                        )
                      end
                  end
                end
              end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::UserListResponse::UserListResponse::Embedded::User,
                  Amocrm::Internal::AnyHash
                )
              end

            class Rights < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :catalog_access

              sig { params(catalog_access: T::Boolean).void }
              attr_writer :catalog_access

              sig { returns(T.nilable(T.anything)) }
              attr_reader :companies

              sig { params(companies: T.anything).void }
              attr_writer :companies

              sig { returns(T.nilable(T.anything)) }
              attr_reader :contacts

              sig { params(contacts: T.anything).void }
              attr_writer :contacts

              sig { returns(T.nilable(Integer)) }
              attr_accessor :group_id

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_active

              sig { params(is_active: T::Boolean).void }
              attr_writer :is_active

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_admin

              sig { params(is_admin: T::Boolean).void }
              attr_writer :is_admin

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_free

              sig { params(is_free: T::Boolean).void }
              attr_writer :is_free

              sig { returns(T.nilable(T.anything)) }
              attr_reader :leads

              sig { params(leads: T.anything).void }
              attr_writer :leads

              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :mail_access

              sig { params(mail_access: T::Boolean).void }
              attr_writer :mail_access

              sig { returns(T.nilable(Integer)) }
              attr_accessor :role_id

              sig do
                returns(T.nilable(
                    T::Array[
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights::StatusRight
                    ]
                  ))
              end
              attr_accessor :status_rights

              sig { returns(T.nilable(T.anything)) }
              attr_reader :tasks

              sig { params(tasks: T.anything).void }
              attr_writer :tasks

              sig do
                override
                  .returns({
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights:
                      T.nilable(
                        T::Array[
                          Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights::StatusRight
                        ]
                      ),
                    tasks: T.anything
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    catalog_access: T::Boolean,
                    companies: T.anything,
                    contacts: T.anything,
                    group_id: T.nilable(Integer),
                    is_active: T::Boolean,
                    is_admin: T::Boolean,
                    is_free: T::Boolean,
                    leads: T.anything,
                    mail_access: T::Boolean,
                    role_id: T.nilable(Integer),
                    status_rights: T.nilable(
                      T::Array[
                        Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights::StatusRight::OrHash
                      ]
                    ),
                    tasks: T.anything
                  ).returns(T.attached_class)
                end
                def new(catalog_access: nil, companies: nil, contacts: nil, group_id: nil, is_active: nil, is_admin: nil, is_free: nil, leads: nil, mail_access: nil, role_id: nil, status_rights: nil, tasks: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights,
                    Amocrm::Internal::AnyHash
                  )
                end

              class StatusRight < Amocrm::Internal::Type::BaseModel
                sig { returns(T.nilable(String)) }
                attr_reader :entity_type

                sig { params(entity_type: String).void }
                attr_writer :entity_type

                sig { returns(T.nilable(Integer)) }
                attr_reader :pipeline_id

                sig { params(pipeline_id: Integer).void }
                attr_writer :pipeline_id

                sig { returns(T.nilable(T.anything)) }
                attr_reader :rights

                sig { params(rights: T.anything).void }
                attr_writer :rights

                sig { returns(T.nilable(Integer)) }
                attr_reader :status_id

                sig { params(status_id: Integer).void }
                attr_writer :status_id

                sig do
                  override
                    .returns({
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    })
                end
                def to_hash; end

                class << self
                  sig do
                    params(
                      entity_type: String,
                      pipeline_id: Integer,
                      rights: T.anything,
                      status_id: Integer
                    ).returns(T.attached_class)
                  end
                  def new(entity_type: nil, pipeline_id: nil, rights: nil, status_id: nil); end
                end

                OrHash = T.type_alias do
                    T.any(
                      Amocrm::Models::UserListResponse::UserListResponse::Embedded::User::Rights::StatusRight,
                      Amocrm::Internal::AnyHash
                    )
                  end
              end
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::UserListResponse::UserListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::UserListResponse::UserListResponse,
            Amocrm::Models::UserListResponse::Problem
          )
        end
    end

    class WebhookListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Amocrm::WebhookListParams::Filter)) }
      attr_reader :filter

      sig { params(filter: Amocrm::WebhookListParams::Filter::OrHash).void }
      attr_writer :filter

      sig do
        override
          .returns({
            filter: Amocrm::WebhookListParams::Filter,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            filter: Amocrm::WebhookListParams::Filter::OrHash,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(filter: nil, request_options: {}); end
      end

      class Filter < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :destination

        sig { params(destination: String).void }
        attr_writer :destination

        sig { override.returns({ destination: String }) }
        def to_hash; end

        class << self
          sig { params(destination: String).returns(T.attached_class) }
          def new(destination: nil); end
        end

        OrHash = T.type_alias do
            T.any(Amocrm::WebhookListParams::Filter, Amocrm::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WebhookListParams, Amocrm::Internal::AnyHash)
        end
    end

    module WebhookListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WebhookListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebhookListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebhookListResponse::WebhookListResponse,
            Amocrm::Models::WebhookListResponse::Problem
          )
        end

      class WebhookListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_total_items

        sig { params(_total_items: Integer).void }
        attr_writer :_total_items

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded,
              _links: T.anything,
              _total_items: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded::OrHash,
              _links: T.anything,
              _total_items: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _total_items: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded::Webhook
                ]
              ))
          end
          attr_reader :webhooks

          sig do
            params(
              webhooks: T::Array[
                  Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded::Webhook::OrHash
                ]
            ).void
          end
          attr_writer :webhooks

          sig do
            override
              .returns({
                webhooks:
                  T::Array[
                    Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded::Webhook
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                webhooks: T::Array[
                  Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded::Webhook::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(webhooks: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Webhook < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_at

            sig { params(created_at: Integer).void }
            attr_writer :created_at

            sig { returns(T.nilable(Integer)) }
            attr_reader :created_by

            sig { params(created_by: Integer).void }
            attr_writer :created_by

            sig { returns(T.nilable(String)) }
            attr_reader :destination

            sig { params(destination: String).void }
            attr_writer :destination

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :disabled

            sig { params(disabled: T::Boolean).void }
            attr_writer :disabled

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Array[String])) }
            attr_reader :settings

            sig { params(settings: T::Array[String]).void }
            attr_writer :settings

            sig { returns(T.nilable(Integer)) }
            attr_reader :sort

            sig { params(sort: Integer).void }
            attr_writer :sort

            sig { returns(T.nilable(Integer)) }
            attr_reader :updated_at

            sig { params(updated_at: Integer).void }
            attr_writer :updated_at

            sig do
              override
                .returns({
                  id: Integer,
                  account_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  destination: String,
                  disabled: T::Boolean,
                  settings: T::Array[String],
                  sort: Integer,
                  updated_at: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  account_id: Integer,
                  created_at: Integer,
                  created_by: Integer,
                  destination: String,
                  disabled: T::Boolean,
                  settings: T::Array[String],
                  sort: Integer,
                  updated_at: Integer
                ).returns(T.attached_class)
              end
              def new(id: nil, account_id: nil, created_at: nil, created_by: nil, destination: nil, disabled: nil, settings: nil, sort: nil, updated_at: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::WebhookListResponse::WebhookListResponse::Embedded::Webhook,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebhookListResponse::WebhookListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    class WebhookSubscribeParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :destination

      sig { returns(T::Array[String]) }
      attr_accessor :settings

      sig { returns(T.nilable(Integer)) }
      attr_reader :sort

      sig { params(sort: Integer).void }
      attr_writer :sort

      sig do
        override
          .returns({
            destination: String,
            settings: T::Array[String],
            sort: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            destination: String,
            settings: T::Array[String],
            sort: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(destination:, settings:, sort: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WebhookSubscribeParams, Amocrm::Internal::AnyHash)
        end
    end

    module WebhookSubscribeResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WebhookSubscribeResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebhookSubscribeResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebhookSubscribeResponse::Webhook,
            Amocrm::Models::WebhookSubscribeResponse::Problem
          )
        end

      class Webhook < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_at

        sig { params(created_at: Integer).void }
        attr_writer :created_at

        sig { returns(T.nilable(Integer)) }
        attr_reader :created_by

        sig { params(created_by: Integer).void }
        attr_writer :created_by

        sig { returns(T.nilable(String)) }
        attr_reader :destination

        sig { params(destination: String).void }
        attr_writer :destination

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :disabled

        sig { params(disabled: T::Boolean).void }
        attr_writer :disabled

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Array[String])) }
        attr_reader :settings

        sig { params(settings: T::Array[String]).void }
        attr_writer :settings

        sig { returns(T.nilable(Integer)) }
        attr_reader :sort

        sig { params(sort: Integer).void }
        attr_writer :sort

        sig { returns(T.nilable(Integer)) }
        attr_reader :updated_at

        sig { params(updated_at: Integer).void }
        attr_writer :updated_at

        sig do
          override
            .returns({
              id: Integer,
              account_id: Integer,
              created_at: Integer,
              created_by: Integer,
              destination: String,
              disabled: T::Boolean,
              settings: T::Array[String],
              sort: Integer,
              updated_at: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              account_id: Integer,
              created_at: Integer,
              created_by: Integer,
              destination: String,
              disabled: T::Boolean,
              settings: T::Array[String],
              sort: Integer,
              updated_at: Integer
            ).returns(T.attached_class)
          end
          def new(id: nil, account_id: nil, created_at: nil, created_by: nil, destination: nil, disabled: nil, settings: nil, sort: nil, updated_at: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebhookSubscribeResponse::Webhook,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    class WebhookUnsubscribeParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(String) }
      attr_accessor :destination

      sig { override.returns({ destination: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(destination: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(destination:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WebhookUnsubscribeParams, Amocrm::Internal::AnyHash)
        end
    end

    module WebhookUnsubscribeResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WebhookUnsubscribeResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebhookUnsubscribeResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebhookUnsubscribeResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebhookUnsubscribeResponse::EmptyResponse,
            Amocrm::Models::WebhookUnsubscribeResponse::Problem
          )
        end
    end

    class WebsiteButtonConnectOnlineChatParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::WebsiteButtonConnectOnlineChatParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module WebsiteButtonConnectOnlineChatResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig do
          override
            .returns(T::Array[
            Amocrm::Models::WebsiteButtonConnectOnlineChatResponse::Variants
          ])
        end
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonConnectOnlineChatResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonConnectOnlineChatResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebsiteButtonConnectOnlineChatResponse::EmptyResponse,
            Amocrm::Models::WebsiteButtonConnectOnlineChatResponse::Problem
          )
        end
    end

    class WebsiteButtonCreateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_used_in_app

      sig { params(is_used_in_app: T::Boolean).void }
      attr_writer :is_used_in_app

      sig { returns(Integer) }
      attr_accessor :pipeline_id

      sig { returns(T.nilable(T::Array[String])) }
      attr_reader :trusted_websites

      sig { params(trusted_websites: T::Array[String]).void }
      attr_writer :trusted_websites

      sig do
        override
          .returns({
            pipeline_id: Integer,
            is_used_in_app: T::Boolean,
            trusted_websites: T::Array[String],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            pipeline_id: Integer,
            is_used_in_app: T::Boolean,
            trusted_websites: T::Array[String],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(pipeline_id:, is_used_in_app: nil, trusted_websites: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WebsiteButtonCreateParams, Amocrm::Internal::AnyHash)
        end
    end

    module WebsiteButtonCreateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WebsiteButtonCreateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonCreateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebsiteButtonCreateResponse::WebsiteButtonCreateResponse,
            Amocrm::Models::WebsiteButtonCreateResponse::Problem
          )
        end

      class WebsiteButtonCreateResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :source_id

        sig { params(source_id: Integer).void }
        attr_writer :source_id

        sig { returns(T.nilable(T::Array[String])) }
        attr_reader :trusted_websites

        sig { params(trusted_websites: T::Array[String]).void }
        attr_writer :trusted_websites

        sig { override.returns({ source_id: Integer, trusted_websites: T::Array[String] }) }
        def to_hash; end

        class << self
          sig { params(source_id: Integer, trusted_websites: T::Array[String]).returns(T.attached_class) }
          def new(source_id: nil, trusted_websites: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonCreateResponse::WebsiteButtonCreateResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    class WebsiteButtonGetBySourceIDParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig { override.returns({ with: String, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(with: String, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::WebsiteButtonGetBySourceIDParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module WebsiteButtonGetBySourceIDResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WebsiteButtonGetBySourceIDResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonGetBySourceIDResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebsiteButtonGetBySourceIDResponse::WebsiteButton,
            Amocrm::Models::WebsiteButtonGetBySourceIDResponse::Problem
          )
        end

      class WebsiteButton < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :button_id

        sig { params(button_id: Integer).void }
        attr_writer :button_id

        sig { returns(T.nilable(String)) }
        attr_reader :creation_status

        sig { params(creation_status: String).void }
        attr_writer :creation_status

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_duplication_control_enabled

        sig { params(is_duplication_control_enabled: T::Boolean).void }
        attr_writer :is_duplication_control_enabled

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_accessor :pipeline_id

        sig { returns(T.nilable(String)) }
        attr_accessor :script

        sig { returns(T.nilable(Integer)) }
        attr_reader :source_id

        sig { params(source_id: Integer).void }
        attr_writer :source_id

        sig do
          override
            .returns({
              account_id: Integer,
              button_id: Integer,
              creation_status: String,
              is_duplication_control_enabled: T::Boolean,
              name: String,
              pipeline_id: T.nilable(Integer),
              script: T.nilable(String),
              source_id: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              account_id: Integer,
              button_id: Integer,
              creation_status: String,
              is_duplication_control_enabled: T::Boolean,
              name: String,
              pipeline_id: T.nilable(Integer),
              script: T.nilable(String),
              source_id: Integer
            ).returns(T.attached_class)
          end
          def new(account_id: nil, button_id: nil, creation_status: nil, is_duplication_control_enabled: nil, name: nil, pipeline_id: nil, script: nil, source_id: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonGetBySourceIDResponse::WebsiteButton,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    class WebsiteButtonListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig { returns(T.nilable(String)) }
      attr_reader :with

      sig { params(with: String).void }
      attr_writer :with

      sig do
        override
          .returns({
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            limit: Integer,
            page: Integer,
            with: String,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(limit: nil, page: nil, with: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WebsiteButtonListParams, Amocrm::Internal::AnyHash)
        end
    end

    module WebsiteButtonListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WebsiteButtonListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse,
            Amocrm::Models::WebsiteButtonListResponse::Problem
          )
        end

      class WebsiteButtonListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig do
          params(
            _embedded: Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded::OrHash
          ).void
        end
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded::WebsiteButton
                ]
              ))
          end
          attr_reader :website_buttons

          sig do
            params(
              website_buttons: T::Array[
                  Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded::WebsiteButton::OrHash
                ]
            ).void
          end
          attr_writer :website_buttons

          sig do
            override
              .returns({
                website_buttons:
                  T::Array[
                    Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded::WebsiteButton
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                website_buttons: T::Array[
                  Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded::WebsiteButton::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(website_buttons: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class WebsiteButton < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(Integer)) }
            attr_reader :account_id

            sig { params(account_id: Integer).void }
            attr_writer :account_id

            sig { returns(T.nilable(Integer)) }
            attr_reader :button_id

            sig { params(button_id: Integer).void }
            attr_writer :button_id

            sig { returns(T.nilable(String)) }
            attr_reader :creation_status

            sig { params(creation_status: String).void }
            attr_writer :creation_status

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_duplication_control_enabled

            sig { params(is_duplication_control_enabled: T::Boolean).void }
            attr_writer :is_duplication_control_enabled

            sig { returns(T.nilable(String)) }
            attr_reader :name

            sig { params(name: String).void }
            attr_writer :name

            sig { returns(T.nilable(Integer)) }
            attr_accessor :pipeline_id

            sig { returns(T.nilable(String)) }
            attr_accessor :script

            sig { returns(T.nilable(Integer)) }
            attr_reader :source_id

            sig { params(source_id: Integer).void }
            attr_writer :source_id

            sig do
              override
                .returns({
                  account_id: Integer,
                  button_id: Integer,
                  creation_status: String,
                  is_duplication_control_enabled: T::Boolean,
                  name: String,
                  pipeline_id: T.nilable(Integer),
                  script: T.nilable(String),
                  source_id: Integer
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  account_id: Integer,
                  button_id: Integer,
                  creation_status: String,
                  is_duplication_control_enabled: T::Boolean,
                  name: String,
                  pipeline_id: T.nilable(Integer),
                  script: T.nilable(String),
                  source_id: Integer
                ).returns(T.attached_class)
              end
              def new(account_id: nil, button_id: nil, creation_status: nil, is_duplication_control_enabled: nil, name: nil, pipeline_id: nil, script: nil, source_id: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse::Embedded::WebsiteButton,
                  Amocrm::Internal::AnyHash
                )
              end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonListResponse::WebsiteButtonListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    class WebsiteButtonUpdateParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Amocrm::WebsiteButtonUpdateParams::TrustedWebsites) }
      attr_reader :trusted_websites

      sig { params(trusted_websites: Amocrm::WebsiteButtonUpdateParams::TrustedWebsites::OrHash).void }
      attr_writer :trusted_websites

      sig do
        override
          .returns({
            trusted_websites:
              Amocrm::WebsiteButtonUpdateParams::TrustedWebsites,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            trusted_websites: Amocrm::WebsiteButtonUpdateParams::TrustedWebsites::OrHash,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(trusted_websites:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WebsiteButtonUpdateParams, Amocrm::Internal::AnyHash)
        end

      class TrustedWebsites < Amocrm::Internal::Type::BaseModel
        sig { returns(T::Array[String]) }
        attr_accessor :add

        sig { override.returns({ add: T::Array[String] }) }
        def to_hash; end

        class << self
          sig { params(add: T::Array[String]).returns(T.attached_class) }
          def new(add:); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::WebsiteButtonUpdateParams::TrustedWebsites,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    module WebsiteButtonUpdateResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WebsiteButtonUpdateResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonUpdateResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WebsiteButtonUpdateResponse::WebsiteButton,
            Amocrm::Models::WebsiteButtonUpdateResponse::Problem
          )
        end

      class WebsiteButton < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(Integer)) }
        attr_reader :account_id

        sig { params(account_id: Integer).void }
        attr_writer :account_id

        sig { returns(T.nilable(Integer)) }
        attr_reader :button_id

        sig { params(button_id: Integer).void }
        attr_writer :button_id

        sig { returns(T.nilable(String)) }
        attr_reader :creation_status

        sig { params(creation_status: String).void }
        attr_writer :creation_status

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_duplication_control_enabled

        sig { params(is_duplication_control_enabled: T::Boolean).void }
        attr_writer :is_duplication_control_enabled

        sig { returns(T.nilable(String)) }
        attr_reader :name

        sig { params(name: String).void }
        attr_writer :name

        sig { returns(T.nilable(Integer)) }
        attr_accessor :pipeline_id

        sig { returns(T.nilable(String)) }
        attr_accessor :script

        sig { returns(T.nilable(Integer)) }
        attr_reader :source_id

        sig { params(source_id: Integer).void }
        attr_writer :source_id

        sig do
          override
            .returns({
              account_id: Integer,
              button_id: Integer,
              creation_status: String,
              is_duplication_control_enabled: T::Boolean,
              name: String,
              pipeline_id: T.nilable(Integer),
              script: T.nilable(String),
              source_id: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              account_id: Integer,
              button_id: Integer,
              creation_status: String,
              is_duplication_control_enabled: T::Boolean,
              name: String,
              pipeline_id: T.nilable(Integer),
              script: T.nilable(String),
              source_id: Integer
            ).returns(T.attached_class)
          end
          def new(account_id: nil, button_id: nil, creation_status: nil, is_duplication_control_enabled: nil, name: nil, pipeline_id: nil, script: nil, source_id: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WebsiteButtonUpdateResponse::WebsiteButton,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    class WidgetBotContinueContinueParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(Integer) }
      attr_accessor :bot_id

      sig { returns(Amocrm::WidgetBotContinueContinueParams::BotType::OrSymbol) }
      attr_accessor :bot_type

      sig { returns(T.nilable(T.anything)) }
      attr_reader :data

      sig { params(data: T.anything).void }
      attr_writer :data

      sig do
        returns(T.nilable(
            T::Array[Amocrm::WidgetBotContinueContinueParams::ExecuteHandler]
          ))
      end
      attr_reader :execute_handlers

      sig do
        params(
          execute_handlers: T::Array[
              Amocrm::WidgetBotContinueContinueParams::ExecuteHandler::OrHash
            ]
        ).void
      end
      attr_writer :execute_handlers

      sig do
        override
          .returns({
            bot_type:
              Amocrm::WidgetBotContinueContinueParams::BotType::OrSymbol,
            bot_id: Integer,
            data: T.anything,
            execute_handlers:
              T::Array[Amocrm::WidgetBotContinueContinueParams::ExecuteHandler],
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            bot_type: Amocrm::WidgetBotContinueContinueParams::BotType::OrSymbol,
            bot_id: Integer,
            data: T.anything,
            execute_handlers: T::Array[
              Amocrm::WidgetBotContinueContinueParams::ExecuteHandler::OrHash
            ],
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(bot_type:, bot_id:, data: nil, execute_handlers: nil, request_options: {}); end
      end

      module BotType
        extend Amocrm::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Amocrm::WidgetBotContinueContinueParams::BotType::TaggedSymbol
            ])
          end
          def values; end
        end

        MARKETINGBOT = T.let(
            :marketingbot,
            Amocrm::WidgetBotContinueContinueParams::BotType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        SALESBOT = T.let(
            :salesbot,
            Amocrm::WidgetBotContinueContinueParams::BotType::TaggedSymbol
          )

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Amocrm::WidgetBotContinueContinueParams::BotType)
          end
      end

      class ExecuteHandler < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :handler

        sig { params(handler: String).void }
        attr_writer :handler

        sig { returns(T.nilable(T.anything)) }
        attr_reader :params

        sig { params(params: T.anything).void }
        attr_writer :params

        sig { override.returns({ handler: String, params: T.anything }) }
        def to_hash; end

        class << self
          sig { params(handler: String, params: T.anything).returns(T.attached_class) }
          def new(handler: nil, params: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::WidgetBotContinueContinueParams::ExecuteHandler,
              Amocrm::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Amocrm::WidgetBotContinueContinueParams,
            Amocrm::Internal::AnyHash
          )
        end
    end

    module WidgetBotContinueContinueResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WidgetBotContinueContinueResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetBotContinueContinueResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetBotContinueContinueResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WidgetBotContinueContinueResponse::EmptyResponse,
            Amocrm::Models::WidgetBotContinueContinueResponse::Problem
          )
        end
    end

    class WidgetGetByCodeParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WidgetGetByCodeParams, Amocrm::Internal::AnyHash)
        end
    end

    module WidgetGetByCodeResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WidgetGetByCodeResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetGetByCodeResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WidgetGetByCodeResponse::Widget,
            Amocrm::Models::WidgetGetByCodeResponse::Problem
          )
        end

      class Widget < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(String)) }
        attr_accessor :client_uuid

        sig { returns(T.nilable(String)) }
        attr_reader :code

        sig { params(code: String).void }
        attr_writer :code

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_active_in_account

        sig { params(is_active_in_account: T::Boolean).void }
        attr_writer :is_active_in_account

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_crm_template

        sig { params(is_crm_template: T::Boolean).void }
        attr_writer :is_crm_template

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_lead_source

        sig { params(is_lead_source: T::Boolean).void }
        attr_writer :is_lead_source

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_work_with_dp

        sig { params(is_work_with_dp: T::Boolean).void }
        attr_writer :is_work_with_dp

        sig { returns(T.nilable(Integer)) }
        attr_accessor :pipeline_id

        sig do
          returns(T.nilable(
              Amocrm::Models::WidgetGetByCodeResponse::Widget::Rating::Variants
            ))
        end
        attr_accessor :rating

        sig { returns(T.nilable(T.anything)) }
        attr_accessor :settings

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::WidgetGetByCodeResponse::Widget::SettingsTemplate
              ]
            ))
        end
        attr_reader :settings_template

        sig do
          params(
            settings_template: T::Array[
                Amocrm::Models::WidgetGetByCodeResponse::Widget::SettingsTemplate::OrHash
              ]
          ).void
        end
        attr_writer :settings_template

        sig do
          returns(T.nilable(
              Amocrm::Models::WidgetGetByCodeResponse::Widget::Version::Variants
            ))
        end
        attr_accessor :version

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              client_uuid: T.nilable(String),
              code: String,
              is_active_in_account: T::Boolean,
              is_crm_template: T::Boolean,
              is_lead_source: T::Boolean,
              is_work_with_dp: T::Boolean,
              pipeline_id: T.nilable(Integer),
              rating:
                T.nilable(
                  Amocrm::Models::WidgetGetByCodeResponse::Widget::Rating::Variants
                ),
              settings: T.nilable(T.anything),
              settings_template:
                T::Array[
                  Amocrm::Models::WidgetGetByCodeResponse::Widget::SettingsTemplate
                ],
              version:
                T.nilable(
                  Amocrm::Models::WidgetGetByCodeResponse::Widget::Version::Variants
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              client_uuid: T.nilable(String),
              code: String,
              is_active_in_account: T::Boolean,
              is_crm_template: T::Boolean,
              is_lead_source: T::Boolean,
              is_work_with_dp: T::Boolean,
              pipeline_id: T.nilable(Integer),
              rating: T.nilable(
                Amocrm::Models::WidgetGetByCodeResponse::Widget::Rating::Variants
              ),
              settings: T.nilable(T.anything),
              settings_template: T::Array[
                Amocrm::Models::WidgetGetByCodeResponse::Widget::SettingsTemplate::OrHash
              ],
              version: T.nilable(
                Amocrm::Models::WidgetGetByCodeResponse::Widget::Version::Variants
              )
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, client_uuid: nil, code: nil, is_active_in_account: nil, is_crm_template: nil, is_lead_source: nil, is_work_with_dp: nil, pipeline_id: nil, rating: nil, settings: nil, settings_template: nil, version: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetGetByCodeResponse::Widget,
              Amocrm::Internal::AnyHash
            )
          end

        module Rating
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::WidgetGetByCodeResponse::Widget::Rating::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias { T.any(String, Float) }
        end

        class SettingsTemplate < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_required

          sig { params(is_required: T::Boolean).void }
          attr_writer :is_required

          sig { returns(T.nilable(String)) }
          attr_reader :key

          sig { params(key: String).void }
          attr_writer :key

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { returns(T.nilable(String)) }
          attr_reader :type

          sig { params(type: String).void }
          attr_writer :type

          sig do
            override
              .returns({
                is_required: T::Boolean,
                key: String,
                name: String,
                type: String
              })
          end
          def to_hash; end

          class << self
            sig { params(is_required: T::Boolean, key: String, name: String, type: String).returns(T.attached_class) }
            def new(is_required: nil, key: nil, name: nil, type: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::WidgetGetByCodeResponse::Widget::SettingsTemplate,
                Amocrm::Internal::AnyHash
              )
            end
        end

        module Version
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::WidgetGetByCodeResponse::Widget::Version::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias { T.any(String, Integer) }
        end
      end
    end

    class WidgetInstallParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.anything) }
      attr_accessor :body

      sig { override.returns({ body: T.anything, request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(body: T.anything, request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(body:, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WidgetInstallParams, Amocrm::Internal::AnyHash)
        end
    end

    module WidgetInstallResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WidgetInstallResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetInstallResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WidgetInstallResponse::Widget,
            Amocrm::Models::WidgetInstallResponse::Problem
          )
        end

      class Widget < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(String)) }
        attr_accessor :client_uuid

        sig { returns(T.nilable(String)) }
        attr_reader :code

        sig { params(code: String).void }
        attr_writer :code

        sig { returns(T.nilable(Integer)) }
        attr_reader :id

        sig { params(id: Integer).void }
        attr_writer :id

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_active_in_account

        sig { params(is_active_in_account: T::Boolean).void }
        attr_writer :is_active_in_account

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_crm_template

        sig { params(is_crm_template: T::Boolean).void }
        attr_writer :is_crm_template

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_lead_source

        sig { params(is_lead_source: T::Boolean).void }
        attr_writer :is_lead_source

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_work_with_dp

        sig { params(is_work_with_dp: T::Boolean).void }
        attr_writer :is_work_with_dp

        sig { returns(T.nilable(Integer)) }
        attr_accessor :pipeline_id

        sig do
          returns(T.nilable(
              Amocrm::Models::WidgetInstallResponse::Widget::Rating::Variants
            ))
        end
        attr_accessor :rating

        sig { returns(T.nilable(T.anything)) }
        attr_accessor :settings

        sig do
          returns(T.nilable(
              T::Array[
                Amocrm::Models::WidgetInstallResponse::Widget::SettingsTemplate
              ]
            ))
        end
        attr_reader :settings_template

        sig do
          params(
            settings_template: T::Array[
                Amocrm::Models::WidgetInstallResponse::Widget::SettingsTemplate::OrHash
              ]
          ).void
        end
        attr_writer :settings_template

        sig do
          returns(T.nilable(
              Amocrm::Models::WidgetInstallResponse::Widget::Version::Variants
            ))
        end
        attr_accessor :version

        sig do
          override
            .returns({
              id: Integer,
              _links: T.anything,
              client_uuid: T.nilable(String),
              code: String,
              is_active_in_account: T::Boolean,
              is_crm_template: T::Boolean,
              is_lead_source: T::Boolean,
              is_work_with_dp: T::Boolean,
              pipeline_id: T.nilable(Integer),
              rating:
                T.nilable(
                  Amocrm::Models::WidgetInstallResponse::Widget::Rating::Variants
                ),
              settings: T.nilable(T.anything),
              settings_template:
                T::Array[
                  Amocrm::Models::WidgetInstallResponse::Widget::SettingsTemplate
                ],
              version:
                T.nilable(
                  Amocrm::Models::WidgetInstallResponse::Widget::Version::Variants
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: Integer,
              _links: T.anything,
              client_uuid: T.nilable(String),
              code: String,
              is_active_in_account: T::Boolean,
              is_crm_template: T::Boolean,
              is_lead_source: T::Boolean,
              is_work_with_dp: T::Boolean,
              pipeline_id: T.nilable(Integer),
              rating: T.nilable(
                Amocrm::Models::WidgetInstallResponse::Widget::Rating::Variants
              ),
              settings: T.nilable(T.anything),
              settings_template: T::Array[
                Amocrm::Models::WidgetInstallResponse::Widget::SettingsTemplate::OrHash
              ],
              version: T.nilable(
                Amocrm::Models::WidgetInstallResponse::Widget::Version::Variants
              )
            ).returns(T.attached_class)
          end
          def new(id: nil, _links: nil, client_uuid: nil, code: nil, is_active_in_account: nil, is_crm_template: nil, is_lead_source: nil, is_work_with_dp: nil, pipeline_id: nil, rating: nil, settings: nil, settings_template: nil, version: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetInstallResponse::Widget,
              Amocrm::Internal::AnyHash
            )
          end

        module Rating
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::WidgetInstallResponse::Widget::Rating::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias { T.any(String, Float) }
        end

        class SettingsTemplate < Amocrm::Internal::Type::BaseModel
          sig { returns(T.nilable(T::Boolean)) }
          attr_reader :is_required

          sig { params(is_required: T::Boolean).void }
          attr_writer :is_required

          sig { returns(T.nilable(String)) }
          attr_reader :key

          sig { params(key: String).void }
          attr_writer :key

          sig { returns(T.nilable(String)) }
          attr_reader :name

          sig { params(name: String).void }
          attr_writer :name

          sig { returns(T.nilable(String)) }
          attr_reader :type

          sig { params(type: String).void }
          attr_writer :type

          sig do
            override
              .returns({
                is_required: T::Boolean,
                key: String,
                name: String,
                type: String
              })
          end
          def to_hash; end

          class << self
            sig { params(is_required: T::Boolean, key: String, name: String, type: String).returns(T.attached_class) }
            def new(is_required: nil, key: nil, name: nil, type: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::WidgetInstallResponse::Widget::SettingsTemplate,
                Amocrm::Internal::AnyHash
              )
            end
        end

        module Version
          extend Amocrm::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Amocrm::Models::WidgetInstallResponse::Widget::Version::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias { T.any(String, Integer) }
        end
      end
    end

    class WidgetListParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig { returns(T.nilable(Integer)) }
      attr_reader :page

      sig { params(page: Integer).void }
      attr_writer :page

      sig do
        override
          .returns({
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            limit: Integer,
            page: Integer,
            request_options: Amocrm::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(limit: nil, page: nil, request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WidgetListParams, Amocrm::Internal::AnyHash)
        end
    end

    module WidgetListResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WidgetListResponse::Variants]) }
        def variants; end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetListResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WidgetListResponse::WidgetListResponse,
            Amocrm::Models::WidgetListResponse::Problem
          )
        end

      class WidgetListResponse < Amocrm::Internal::Type::BaseModel
        sig do
          returns(T.nilable(
              Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded
            ))
        end
        attr_reader :_embedded

        sig { params(_embedded: Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::OrHash).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { returns(T.nilable(Integer)) }
        attr_reader :_page

        sig { params(_page: Integer).void }
        attr_writer :_page

        sig do
          override
            .returns({
              _embedded:
                Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded,
              _links: T.anything,
              _page: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              _embedded: Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::OrHash,
              _links: T.anything,
              _page: Integer
            ).returns(T.attached_class)
          end
          def new(_embedded: nil, _links: nil, _page: nil); end
        end

        class Embedded < Amocrm::Internal::Type::BaseModel
          sig do
            returns(T.nilable(
                T::Array[
                  Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget
                ]
              ))
          end
          attr_reader :widgets

          sig do
            params(
              widgets: T::Array[
                  Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::OrHash
                ]
            ).void
          end
          attr_writer :widgets

          sig do
            override
              .returns({
                widgets:
                  T::Array[
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget
                  ]
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                widgets: T::Array[
                  Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::OrHash
                ]
              ).returns(T.attached_class)
            end
            def new(widgets: nil); end
          end

          OrHash = T.type_alias do
              T.any(
                Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded,
                Amocrm::Internal::AnyHash
              )
            end

          class Widget < Amocrm::Internal::Type::BaseModel
            sig { returns(T.nilable(T.anything)) }
            attr_reader :_links

            sig { params(_links: T.anything).void }
            attr_writer :_links

            sig { returns(T.nilable(String)) }
            attr_accessor :client_uuid

            sig { returns(T.nilable(String)) }
            attr_reader :code

            sig { params(code: String).void }
            attr_writer :code

            sig { returns(T.nilable(Integer)) }
            attr_reader :id

            sig { params(id: Integer).void }
            attr_writer :id

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_active_in_account

            sig { params(is_active_in_account: T::Boolean).void }
            attr_writer :is_active_in_account

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_crm_template

            sig { params(is_crm_template: T::Boolean).void }
            attr_writer :is_crm_template

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_lead_source

            sig { params(is_lead_source: T::Boolean).void }
            attr_writer :is_lead_source

            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :is_work_with_dp

            sig { params(is_work_with_dp: T::Boolean).void }
            attr_writer :is_work_with_dp

            sig { returns(T.nilable(Integer)) }
            attr_accessor :pipeline_id

            sig do
              returns(T.nilable(
                  Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Rating::Variants
                ))
            end
            attr_accessor :rating

            sig { returns(T.nilable(T.anything)) }
            attr_accessor :settings

            sig do
              returns(T.nilable(
                  T::Array[
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::SettingsTemplate
                  ]
                ))
            end
            attr_reader :settings_template

            sig do
              params(
                settings_template: T::Array[
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::SettingsTemplate::OrHash
                  ]
              ).void
            end
            attr_writer :settings_template

            sig do
              returns(T.nilable(
                  Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Version::Variants
                ))
            end
            attr_accessor :version

            sig do
              override
                .returns({
                  id: Integer,
                  _links: T.anything,
                  client_uuid: T.nilable(String),
                  code: String,
                  is_active_in_account: T::Boolean,
                  is_crm_template: T::Boolean,
                  is_lead_source: T::Boolean,
                  is_work_with_dp: T::Boolean,
                  pipeline_id: T.nilable(Integer),
                  rating:
                    T.nilable(
                      Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Rating::Variants
                    ),
                  settings: T.nilable(T.anything),
                  settings_template:
                    T::Array[
                      Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::SettingsTemplate
                    ],
                  version:
                    T.nilable(
                      Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Version::Variants
                    )
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  id: Integer,
                  _links: T.anything,
                  client_uuid: T.nilable(String),
                  code: String,
                  is_active_in_account: T::Boolean,
                  is_crm_template: T::Boolean,
                  is_lead_source: T::Boolean,
                  is_work_with_dp: T::Boolean,
                  pipeline_id: T.nilable(Integer),
                  rating: T.nilable(
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Rating::Variants
                  ),
                  settings: T.nilable(T.anything),
                  settings_template: T::Array[
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::SettingsTemplate::OrHash
                  ],
                  version: T.nilable(
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Version::Variants
                  )
                ).returns(T.attached_class)
              end
              def new(id: nil, _links: nil, client_uuid: nil, code: nil, is_active_in_account: nil, is_crm_template: nil, is_lead_source: nil, is_work_with_dp: nil, pipeline_id: nil, rating: nil, settings: nil, settings_template: nil, version: nil); end
            end

            OrHash = T.type_alias do
                T.any(
                  Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget,
                  Amocrm::Internal::AnyHash
                )
              end

            module Rating
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Rating::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Float) }
            end

            class SettingsTemplate < Amocrm::Internal::Type::BaseModel
              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :is_required

              sig { params(is_required: T::Boolean).void }
              attr_writer :is_required

              sig { returns(T.nilable(String)) }
              attr_reader :key

              sig { params(key: String).void }
              attr_writer :key

              sig { returns(T.nilable(String)) }
              attr_reader :name

              sig { params(name: String).void }
              attr_writer :name

              sig { returns(T.nilable(String)) }
              attr_reader :type

              sig { params(type: String).void }
              attr_writer :type

              sig do
                override
                  .returns({
                    is_required: T::Boolean,
                    key: String,
                    name: String,
                    type: String
                  })
              end
              def to_hash; end

              class << self
                sig do
                  params(
                    is_required: T::Boolean,
                    key: String,
                    name: String,
                    type: String
                  ).returns(T.attached_class)
                end
                def new(is_required: nil, key: nil, name: nil, type: nil); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::SettingsTemplate,
                    Amocrm::Internal::AnyHash
                  )
                end
            end

            module Version
              extend Amocrm::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Amocrm::Models::WidgetListResponse::WidgetListResponse::Embedded::Widget::Version::Variants
                  ])
                end
                def variants; end
              end

              Variants = T.type_alias { T.any(String, Integer) }
            end
          end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetListResponse::WidgetListResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end
    end

    class WidgetUninstallParams < Amocrm::Internal::Type::BaseModel
      extend Amocrm::Internal::Type::RequestParameters::Converter
      include Amocrm::Internal::Type::RequestParameters

      sig { override.returns({ request_options: Amocrm::RequestOptions }) }
      def to_hash; end

      class << self
        sig { params(request_options: Amocrm::RequestOptions::OrHash).returns(T.attached_class) }
        def new(request_options: {}); end
      end

      OrHash = T.type_alias do
          T.any(Amocrm::WidgetUninstallParams, Amocrm::Internal::AnyHash)
        end
    end

    module WidgetUninstallResponse
      extend Amocrm::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Amocrm::Models::WidgetUninstallResponse::Variants]) }
        def variants; end
      end

      class EmptyResponse < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_reader :_embedded

        sig { params(_embedded: T.anything).void }
        attr_writer :_embedded

        sig { returns(T.nilable(T.anything)) }
        attr_reader :_links

        sig { params(_links: T.anything).void }
        attr_writer :_links

        sig { override.returns({ _embedded: T.anything, _links: T.anything }) }
        def to_hash; end

        class << self
          sig { params(_embedded: T.anything, _links: T.anything).returns(T.attached_class) }
          def new(_embedded: nil, _links: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetUninstallResponse::EmptyResponse,
              Amocrm::Internal::AnyHash
            )
          end
      end

      class Problem < Amocrm::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_reader :detail

        sig { params(detail: String).void }
        attr_writer :detail

        sig { returns(T.nilable(Integer)) }
        attr_reader :status

        sig { params(status: Integer).void }
        attr_writer :status

        sig { returns(T.nilable(String)) }
        attr_reader :title

        sig { params(title: String).void }
        attr_writer :title

        sig { returns(T.nilable(String)) }
        attr_reader :type

        sig { params(type: String).void }
        attr_writer :type

        sig { override.returns({ detail: String, status: Integer, title: String, type: String }) }
        def to_hash; end

        class << self
          sig { params(detail: String, status: Integer, title: String, type: String).returns(T.attached_class) }
          def new(detail: nil, status: nil, title: nil, type: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Amocrm::Models::WidgetUninstallResponse::Problem,
              Amocrm::Internal::AnyHash
            )
          end
      end

      Variants = T.type_alias do
          T.any(
            Amocrm::Models::WidgetUninstallResponse::EmptyResponse,
            Amocrm::Models::WidgetUninstallResponse::Problem
          )
        end
    end
  end

  PipelineCreateParams = Amocrm::Models::PipelineCreateParams
  PipelineDeleteByIDParams = Amocrm::Models::PipelineDeleteByIDParams
  PipelineGetByIDParams = Amocrm::Models::PipelineGetByIDParams
  PipelineListParams = Amocrm::Models::PipelineListParams
  PipelineStatusCreateParams = Amocrm::Models::PipelineStatusCreateParams

  PipelineStatusDeleteByIDParams = Amocrm::Models::PipelineStatusDeleteByIDParams

  PipelineStatusGetByIDParams = Amocrm::Models::PipelineStatusGetByIDParams
  PipelineStatusListParams = Amocrm::Models::PipelineStatusListParams

  PipelineStatusUpdateByIDParams = Amocrm::Models::PipelineStatusUpdateByIDParams

  PipelineStatusUpdateParams = Amocrm::Models::PipelineStatusUpdateParams
  PipelineUpdateByIDParams = Amocrm::Models::PipelineUpdateByIDParams
  PipelineUpdateParams = Amocrm::Models::PipelineUpdateParams

  # Specify HTTP behaviour to use for a specific request. These options supplement
  # or override those provided at the client level.
  #
  # When making a request, you can pass an actual {RequestOptions} instance, or
  # simply pass a Hash with symbol keys matching the attributes on this class.
  class RequestOptions < Amocrm::Internal::Type::BaseModel
    # Extra data to send with the request. These are deep merged into any data
    # generated as part of the normal request.
    sig { returns(T.nilable(T.anything)) }
    attr_accessor :extra_body

    # Extra headers to send with the request. These are `.merged`d into any
    # `extra_headers` given at the client level.
    sig { returns(T.nilable(T::Hash[String, T.nilable(String)])) }
    attr_accessor :extra_headers

    # Extra query params to send with the request. These are `.merge`d into any
    # `query` given at the client level.
    sig { returns(T.nilable(T::Hash[String, T.nilable(T.any(T::Array[String], String))])) }
    attr_accessor :extra_query

    # Idempotency key to send with request and all associated retries. Will only be
    # sent for write requests.
    sig { returns(T.nilable(String)) }
    attr_accessor :idempotency_key

    # Maximum number of retries to attempt after a failed initial request.
    sig { returns(T.nilable(Integer)) }
    attr_accessor :max_retries

    # Request timeout in seconds.
    sig { returns(T.nilable(Float)) }
    attr_accessor :timeout

    class << self
      # Returns a new instance of RequestOptions.
      sig { params(values: Amocrm::Internal::AnyHash).returns(T.attached_class) }
      def new(values = {}); end

      # @api private
      sig { params(opts: Amocrm::RequestOptions::OrHash).void }
      def validate!(opts); end
    end

    OrHash = T.type_alias { T.any(Amocrm::RequestOptions, Amocrm::Internal::AnyHash) }
  end

  module Resources
    class Account
      # Get account info.
      sig do
        params(
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::AccountGetResponse::Variants)
      end
      def get(
        with: nil, # Additional data to include (comma-separated).
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Calls
      # Add calls (batch).
      sig do
        params(
          body: T::Array[Amocrm::CallCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CallCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CatalogElements
      # Create catalog elements.
      sig do
        params(
          catalog_id: Integer,
          body: T::Array[Amocrm::CatalogElementCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogElementCreateResponse::Variants)
      end
      def create(catalog_id, body:, request_options: {}); end

      # Get catalog element by id.
      sig do
        params(
          id: Integer,
          catalog_id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogElementGetByIDResponse::Variants)
      end
      def get_by_id(
        id, # Path param
        catalog_id:, # Path param
        with: nil, # Query param: Additional data to include (comma-separated).
        request_options: {}
); end

      # Get catalog elements list.
      sig do
        params(
          catalog_id: Integer,
          filter: T.anything,
          limit: Integer,
          page: Integer,
          query: Amocrm::CatalogElementListParams::Query::Variants,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogElementListResponse::Variants)
      end
      def list(catalog_id, filter: nil, limit: nil, page: nil, query: nil, request_options: {}); end

      # Update catalog elements (batch).
      sig do
        params(
          catalog_id: Integer,
          body: T::Array[Amocrm::CatalogElementUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogElementUpdateResponse::Variants)
      end
      def update(catalog_id, body:, request_options: {}); end

      # Update catalog element by id.
      sig do
        params(
          id: Integer,
          catalog_id: Integer,
          custom_fields_values: T::Array[
              Amocrm::CatalogElementUpdateByIDParams::CustomFieldsValue::OrHash
            ],
          name: String,
          request_id: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogElementUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id, # Path param
        catalog_id:, # Path param
        custom_fields_values: nil, # Body param
        name: nil, # Body param
        request_id: nil, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Catalogs
      # Create catalogs.
      sig do
        params(
          body: T::Array[Amocrm::CatalogCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Get catalog by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogGetByIDResponse::Variants)
      end
      def get_by_id(id, request_options: {}); end

      # Get catalogs list.
      sig do
        params(
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogListResponse::Variants)
      end
      def list(limit: nil, page: nil, request_options: {}); end

      # Update catalogs (batch).
      sig do
        params(
          body: T::Array[Amocrm::CatalogUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update catalog by id.
      sig do
        params(
          id: Integer,
          can_add_elements: T::Boolean,
          can_link_multiple: T::Boolean,
          name: String,
          request_id: String,
          sort: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CatalogUpdateByIDResponse::Variants)
      end
      def update_by_id(id, can_add_elements: nil, can_link_multiple: nil, name: nil, request_id: nil, sort: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Companies
      # Create companies.
      sig do
        params(
          body: T::Array[Amocrm::CompanyCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CompanyCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Get a company by id.
      sig do
        params(
          id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CompanyGetByIDResponse::Variants)
      end
      def get_by_id(
        id,
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Get a list of companies (pagination, sorting, filtering).
      sig do
        params(
          filter: T.anything,
          limit: Integer,
          order: T.anything,
          page: Integer,
          query: Amocrm::CompanyListParams::Query::Variants,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CompanyListResponse::Variants)
      end
      def list(
        filter: nil, # Filtering parameters
        limit: nil, # Pagination limit
        order: nil, # Sorting, e.g. order[updated_at]=asc
        page: nil, # Pagination page
        query: nil, # Search by query string or id
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Update companies (batch).
      sig do
        params(
          body: T::Array[Amocrm::CompanyUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CompanyUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update a company by id.
      sig do
        params(
          id: Integer,
          _embedded: Amocrm::CompanyUpdateByIDParams::Embedded::OrHash,
          created_at: Integer,
          created_by: Integer,
          custom_fields_values: T::Array[
              Amocrm::CompanyUpdateByIDParams::CustomFieldsValue::OrHash
            ],
          name: String,
          responsible_user_id: Integer,
          tags_to_add: T::Array[Amocrm::CompanyUpdateByIDParams::TagsToAdd::OrHash],
          tags_to_delete: T::Array[Amocrm::CompanyUpdateByIDParams::TagsToDelete::OrHash],
          updated_at: Integer,
          updated_by: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CompanyUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id,
        _embedded: nil,
        created_at: nil,
        created_by: nil,
        custom_fields_values: nil, # Custom fields payload
        name: nil,
        responsible_user_id: nil,
        tags_to_add: nil, # Tags to attach
        tags_to_delete: nil, # Tags to delete
        updated_at: nil,
        updated_by: nil,
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class ContactChats
      # Link chats to contacts.
      sig do
        params(
          body: T::Array[Amocrm::ContactChatLinkParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ContactChatLinkResponse::Variants)
      end
      def link(body:, request_options: {}); end

      # Get list of linked chats.
      sig do
        params(
          filter: T.anything,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ContactChatListResponse::Variants)
      end
      def list(filter: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Contacts
      # Create contacts.
      sig do
        params(
          body: T::Array[Amocrm::ContactCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ContactCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Get a contact by id.
      sig do
        params(
          id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ContactGetByIDResponse::Variants)
      end
      def get_by_id(
        id,
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Get a list of contacts (pagination, sorting, filtering).
      sig do
        params(
          filter: T.anything,
          limit: Integer,
          order: T.anything,
          page: Integer,
          query: Amocrm::ContactListParams::Query::Variants,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ContactListResponse::Variants)
      end
      def list(
        filter: nil, # Filtering parameters
        limit: nil, # Pagination limit
        order: nil, # Sorting, e.g. order[updated_at]=asc
        page: nil, # Pagination page
        query: nil, # Search by query string or id
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Update contacts (batch).
      sig do
        params(
          body: T::Array[Amocrm::ContactUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ContactUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update a contact by id.
      sig do
        params(
          id: Integer,
          _embedded: Amocrm::ContactUpdateByIDParams::Embedded::OrHash,
          created_at: Integer,
          created_by: Integer,
          custom_fields_values: T::Array[
              Amocrm::ContactUpdateByIDParams::CustomFieldsValue::OrHash
            ],
          first_name: String,
          last_name: String,
          name: String,
          responsible_user_id: Integer,
          tags_to_add: T::Array[Amocrm::ContactUpdateByIDParams::TagsToAdd::OrHash],
          tags_to_delete: T::Array[Amocrm::ContactUpdateByIDParams::TagsToDelete::OrHash],
          updated_at: Integer,
          updated_by: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ContactUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id,
        _embedded: nil,
        created_at: nil,
        created_by: nil,
        custom_fields_values: nil, # Custom fields payload
        first_name: nil,
        last_name: nil,
        name: nil,
        responsible_user_id: nil,
        tags_to_add: nil, # Tags to attach
        tags_to_delete: nil, # Tags to delete
        updated_at: nil,
        updated_by: nil,
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CustomFieldGroups
      # Create custom field groups.
      sig do
        params(
          entity_type: String,
          body: T::Array[Amocrm::CustomFieldGroupCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldGroupCreateResponse::Variants)
      end
      def create(entity_type, body:, request_options: {}); end

      # Delete a custom field group by id.
      sig do
        params(
          id: Integer,
          entity_type: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldGroupDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, entity_type:, request_options: {}); end

      # Get custom field group by id.
      sig do
        params(
          id: Integer,
          entity_type: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldGroupGetByIDResponse::Variants)
      end
      def get_by_id(id, entity_type:, request_options: {}); end

      # Get custom field groups list.
      sig do
        params(
          entity_type: String,
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldGroupListResponse::Variants)
      end
      def list(entity_type, limit: nil, page: nil, request_options: {}); end

      # Update a custom field group by id.
      sig do
        params(
          id: Integer,
          entity_type: String,
          name: String,
          sort: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldGroupUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id, # Path param
        entity_type:, # Path param
        name: nil, # Body param
        sort: nil, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CustomFields
      # Create custom fields.
      sig do
        params(
          entity_type: String,
          body: T::Array[Amocrm::CustomFieldCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldCreateResponse::Variants)
      end
      def create(entity_type, body:, request_options: {}); end

      # Delete a custom field by id.
      sig do
        params(
          id: Integer,
          entity_type: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, entity_type:, request_options: {}); end

      # Get custom field by id.
      sig do
        params(
          id: Integer,
          entity_type: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldGetByIDResponse::Variants)
      end
      def get_by_id(id, entity_type:, request_options: {}); end

      # Get custom fields list.
      sig do
        params(
          entity_type: String,
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldListResponse::Variants)
      end
      def list(entity_type, limit: nil, page: nil, request_options: {}); end

      # Update custom fields (batch).
      sig do
        params(
          entity_type: String,
          body: T::Array[Amocrm::CustomFieldUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldUpdateResponse::Variants)
      end
      def update(entity_type, body:, request_options: {}); end

      # Update a custom field by id.
      sig do
        params(
          id: Integer,
          entity_type: String,
          code: String,
          enums: T::Array[T.anything],
          group_id: Integer,
          is_deletable: T::Boolean,
          is_multiple: T::Boolean,
          is_required: T::Boolean,
          is_visible: T::Boolean,
          name: String,
          settings: T.anything,
          sort: Integer,
          type: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomFieldUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id, # Path param
        entity_type:, # Path param
        code: nil, # Body param
        enums: nil, # Body param
        group_id: nil, # Body param
        is_deletable: nil, # Body param
        is_multiple: nil, # Body param
        is_required: nil, # Body param
        is_visible: nil, # Body param
        name: nil, # Body param
        settings: nil, # Body param
        sort: nil, # Body param
        type: nil, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CustomerBonusPoints
      # Earn or redeem bonus points.
      sig do
        params(
          customer_id: Integer,
          earn: Integer,
          redeem: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerBonusPointChangeResponse::Variants)
      end
      def change(customer_id, earn:, redeem:, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CustomerSegments
      # Create segments.
      sig do
        params(
          body: T::Array[Amocrm::CustomerSegmentCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerSegmentCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Delete a segment by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerSegmentDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, request_options: {}); end

      # Get segment by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerSegmentGetByIDResponse::Variants)
      end
      def get_by_id(id, request_options: {}); end

      # Get segments list.
      sig do
        params(
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerSegmentListResponse::Variants)
      end
      def list(request_options: {}); end

      # Update a segment by id.
      sig do
        params(
          id: Integer,
          color: String,
          custom_fields_values: T::Array[
              Amocrm::CustomerSegmentUpdateByIDParams::CustomFieldsValue::OrHash
            ],
          name: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerSegmentUpdateByIDResponse::Variants)
      end
      def update_by_id(id, color: nil, custom_fields_values: nil, name: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CustomerStatuses
      # Create statuses.
      sig do
        params(
          body: T::Array[Amocrm::CustomerStatusCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerStatusCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Delete a status by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerStatusDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, request_options: {}); end

      # Get status by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerStatusGetByIDResponse::Variants)
      end
      def get_by_id(id, request_options: {}); end

      # Get statuses list.
      sig do
        params(
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerStatusListResponse::Variants)
      end
      def list(request_options: {}); end

      # Update a status by id.
      sig do
        params(
          id: Integer,
          color: String,
          name: String,
          sort: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerStatusUpdateByIDResponse::Variants)
      end
      def update_by_id(id, color: nil, name: nil, sort: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CustomerTransactions
      # Create transactions for a customer.
      sig do
        params(
          customer_id: Integer,
          body: T::Array[Amocrm::CustomerTransactionCreateParams::Body::OrHash],
          accrue_bonus: T::Boolean,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerTransactionCreateResponse::Variants)
      end
      def create(
        customer_id, # Path param
        body:, # Body param
        accrue_bonus: nil, # Query param
        request_options: {}
); end

      # Delete a transaction for a customer.
      sig do
        params(
          transaction_id: Integer,
          customer_id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerTransactionDeleteByIDResponse::Variants)
      end
      def delete_by_id(transaction_id, customer_id:, request_options: {}); end

      # Get list of transactions.
      sig do
        params(
          filter: T.anything,
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerTransactionListResponse::Variants)
      end
      def list(filter: nil, limit: nil, page: nil, request_options: {}); end

      # Get list of transactions for a customer.
      sig do
        params(
          customer_id: Integer,
          filter: T.anything,
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerTransactionListByCustomerResponse::Variants)
      end
      def list_by_customer(customer_id, filter: nil, limit: nil, page: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Customers
      # Create customers.
      sig do
        params(
          body: T::Array[Amocrm::CustomerCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Get a customer by id.
      sig do
        params(
          id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerGetByIDResponse::Variants)
      end
      def get_by_id(
        id,
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Get a list of customers.
      sig do
        params(
          filter: T.anything,
          limit: Integer,
          order: T.anything,
          page: Integer,
          query: Amocrm::CustomerListParams::Query::Variants,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerListResponse::Variants)
      end
      def list(
        filter: nil,
        limit: nil,
        order: nil,
        page: nil,
        query: nil,
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Update customers (batch).
      sig do
        params(
          body: T::Array[Amocrm::CustomerUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update a customer by id.
      sig do
        params(
          id: Integer,
          _embedded: Amocrm::CustomerUpdateByIDParams::Embedded::OrHash,
          custom_fields_values: T::Array[
              Amocrm::CustomerUpdateByIDParams::CustomFieldsValue::OrHash
            ],
          main_user_id: Integer,
          name: String,
          next_date: Integer,
          next_price: Integer,
          periodicity: Integer,
          responsible_user_id: Integer,
          status_id: Integer,
          tags_to_add: T::Array[Amocrm::CustomerUpdateByIDParams::TagsToAdd::OrHash],
          tags_to_delete: T::Array[Amocrm::CustomerUpdateByIDParams::TagsToDelete::OrHash],
          updated_at: Integer,
          updated_by: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomerUpdateByIDResponse::Variants)
      end
      def update_by_id(id, _embedded: nil, custom_fields_values: nil, main_user_id: nil, name: nil, next_date: nil, next_price: nil, periodicity: nil, responsible_user_id: nil, status_id: nil, tags_to_add: nil, tags_to_delete: nil, updated_at: nil, updated_by: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class CustomersMode
      # Enable or switch customers mode.
      sig do
        params(
          is_enabled: T::Boolean,
          mode: Amocrm::CustomersModeSetModeParams::Mode::OrSymbol,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::CustomersModeSetModeResponse::Variants)
      end
      def set_mode(is_enabled:, mode:, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class EntityFollowers
      # Add followers.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityFollowerAddParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityFollowerAddParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityFollowerAddResponse::Variants)
      end
      def add(
        entity_id, # Path param
        entity_type:, # Path param
        body:, # Body param
        request_options: {}
); end

      # Get followers list.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityFollowerListParams::EntityType::OrSymbol,
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityFollowerListResponse::Variants)
      end
      def list(
        entity_id, # Path param
        entity_type:, # Path param
        limit: nil, # Query param
        page: nil, # Query param
        request_options: {}
); end

      # Remove followers.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityFollowerRemoveParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityFollowerRemoveParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityFollowerRemoveResponse::Variants)
      end
      def remove(
        entity_id, # Path param
        entity_type:, # Path param
        body:, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class EntityLinks
      # Link entities (bulk).
      sig do
        params(
          entity_type: Amocrm::EntityLinkLinkParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityLinkLinkParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityLinkLinkResponse::Variants)
      end
      def link(entity_type, body:, request_options: {}); end

      # Link entities for a specific entity.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityLinkLinkByEntityParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityLinkLinkByEntityParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityLinkLinkByEntityResponse::Variants)
      end
      def link_by_entity(
        entity_id, # Path param
        entity_type:, # Path param
        body:, # Body param
        request_options: {}
); end

      # Get list of linked entities (bulk).
      sig do
        params(
          entity_type: Amocrm::EntityLinkListParams::EntityType::OrSymbol,
          filter: T.anything,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityLinkListResponse::Variants)
      end
      def list(entity_type, filter: nil, request_options: {}); end

      # Get links for a specific entity.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityLinkListByEntityParams::EntityType::OrSymbol,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityLinkListByEntityResponse::Variants)
      end
      def list_by_entity(entity_id, entity_type:, request_options: {}); end

      # Unlink entities (bulk).
      sig do
        params(
          entity_type: Amocrm::EntityLinkUnlinkParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityLinkUnlinkParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityLinkUnlinkResponse::Variants)
      end
      def unlink(entity_type, body:, request_options: {}); end

      # Unlink entities for a specific entity.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityLinkUnlinkByEntityParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityLinkUnlinkByEntityParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityLinkUnlinkByEntityResponse::Variants)
      end
      def unlink_by_entity(
        entity_id, # Path param
        entity_type:, # Path param
        body:, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class EntityNotes
      # Create notes for entity type.
      sig do
        params(
          entity_type: Amocrm::EntityNoteCreateParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityNoteCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNoteCreateResponse::Variants)
      end
      def create(entity_type, body:, request_options: {}); end

      # Get note by id.
      sig do
        params(
          id: Integer,
          entity_type: Amocrm::EntityNoteGetByIDParams::EntityType::OrSymbol,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNoteGetByIDResponse::Variants)
      end
      def get_by_id(
        id, # Path param
        entity_type:, # Path param
        with: nil, # Query param
        request_options: {}
); end

      # Get notes list for entity type.
      sig do
        params(
          entity_type: Amocrm::EntityNoteListParams::EntityType::OrSymbol,
          filter: T.anything,
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNoteListResponse::Variants)
      end
      def list(entity_type, filter: nil, limit: nil, page: nil, request_options: {}); end

      # Pin note by id.
      sig do
        params(
          id: Integer,
          entity_type: Amocrm::EntityNotePinParams::EntityType::OrSymbol,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNotePinResponse::Variants)
      end
      def pin(id, entity_type:, request_options: {}); end

      # Unpin note by id.
      sig do
        params(
          id: Integer,
          entity_type: Amocrm::EntityNoteUnpinParams::EntityType::OrSymbol,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNoteUnpinResponse::Variants)
      end
      def unpin(id, entity_type:, request_options: {}); end

      # Update notes for entity type (batch).
      sig do
        params(
          entity_type: Amocrm::EntityNoteUpdateParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::EntityNoteUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNoteUpdateResponse::Variants)
      end
      def update(entity_type, body:, request_options: {}); end

      # Update note by id.
      sig do
        params(
          id: Integer,
          entity_type: Amocrm::EntityNoteUpdateByIDParams::EntityType::OrSymbol,
          entity_id: Integer,
          note_type: String,
          params: T.anything,
          updated_at: Integer,
          updated_by: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNoteUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id, # Path param
        entity_type:, # Path param
        entity_id: nil, # Body param
        note_type: nil, # Body param
        params: nil, # Body param
        updated_at: nil, # Body param
        updated_by: nil, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class EntityNotesByParent
      # Create notes for a specific entity.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityNotesByParentCreateByParentParams::EntityType::OrSymbol,
          body: T::Array[
              Amocrm::EntityNotesByParentCreateByParentParams::Body::OrHash
            ],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNotesByParentCreateByParentResponse::Variants)
      end
      def create_by_parent(
        entity_id, # Path param
        entity_type:, # Path param
        body:, # Body param
        request_options: {}
); end

      # Get note by id for a specific entity.
      sig do
        params(
          note_id: Integer,
          entity_type: Amocrm::EntityNotesByParentGetByParentIDParams::EntityType::OrSymbol,
          entity_id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNotesByParentGetByParentIDResponse::Variants)
      end
      def get_by_parent_id(
        note_id, # Path param
        entity_type:, # Path param
        entity_id:, # Path param
        with: nil, # Query param
        request_options: {}
); end

      # Get notes list for a specific entity.
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityNotesByParentListByParentParams::EntityType::OrSymbol,
          filter: T.anything,
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNotesByParentListByParentResponse::Variants)
      end
      def list_by_parent(
        entity_id, # Path param
        entity_type:, # Path param
        filter: nil, # Query param
        limit: nil, # Query param
        page: nil, # Query param
        request_options: {}
); end

      # Update notes for a specific entity (batch).
      sig do
        params(
          entity_id: Integer,
          entity_type: Amocrm::EntityNotesByParentUpdateByParentParams::EntityType::OrSymbol,
          body: T::Array[
              Amocrm::EntityNotesByParentUpdateByParentParams::Body::OrHash
            ],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNotesByParentUpdateByParentResponse::Variants)
      end
      def update_by_parent(
        entity_id, # Path param
        entity_type:, # Path param
        body:, # Body param
        request_options: {}
); end

      # Update note by id for a specific entity.
      sig do
        params(
          note_id: Integer,
          entity_type: Amocrm::EntityNotesByParentUpdateByParentIDParams::EntityType::OrSymbol,
          body_entity_id: Integer,
          note_type: String,
          params: T.anything,
          updated_at: Integer,
          updated_by: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EntityNotesByParentUpdateByParentIDResponse::Variants)
      end
      def update_by_parent_id(
        note_id, # Path param
        entity_type:, # Path param
        body_entity_id: nil, # Body param
        note_type: nil, # Body param
        params: nil, # Body param
        updated_at: nil, # Body param
        updated_by: nil, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Events
      # Get event by id.
      sig do
        params(
          id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EventGetByIDResponse::Variants)
      end
      def get_by_id(id, with: nil, request_options: {}); end

      # Get events list.
      sig do
        params(
          filter: T.anything,
          limit: Integer,
          page: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EventListResponse::Variants)
      end
      def list(filter: nil, limit: nil, page: nil, with: nil, request_options: {}); end

      # Get event types.
      sig do
        params(
          language_code: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::EventListTypesResponse::Variants)
      end
      def list_types(language_code: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Leads
      # Create leads.
      sig do
        params(
          body: T::Array[Amocrm::LeadCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::LeadCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Create leads using the complex method (supports unsorted metadata).
      sig do
        params(
          body: T::Array[Amocrm::LeadCreateComplexParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::LeadCreateComplexResponse::Variants)
      end
      def create_complex(body:, request_options: {}); end

      # Get a lead by id.
      sig do
        params(
          id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::LeadGetByIDResponse::Variants)
      end
      def get_by_id(
        id,
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Get a list of leads (pagination, sorting, filtering).
      sig do
        params(
          filter: T.anything,
          limit: Integer,
          order: T.anything,
          page: Integer,
          query: Amocrm::LeadListParams::Query::Variants,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::LeadListResponse::Variants)
      end
      def list(
        filter: nil, # Filtering parameters, see filters API
        limit: nil, # Pagination limit
        order: nil, # Sorting, e.g. order[updated_at]=asc
        page: nil, # Pagination page
        query: nil, # Search by query string or id
        with: nil, # Expand related entities; comma-separated values
        request_options: {}
); end

      # Update leads (batch).
      sig do
        params(
          body: T::Array[Amocrm::LeadUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::LeadUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update a lead by id.
      sig do
        params(
          id: Integer,
          _embedded: Amocrm::LeadUpdateByIDParams::Embedded::OrHash,
          closed_at: Integer,
          custom_fields_values: T::Array[Amocrm::LeadUpdateByIDParams::CustomFieldsValue::OrHash],
          group_id: Integer,
          loss_reason_id: Integer,
          name: String,
          pipeline_id: Integer,
          price: Integer,
          responsible_user_id: Integer,
          status_id: Integer,
          tags_to_add: T::Array[Amocrm::LeadUpdateByIDParams::TagsToAdd::OrHash],
          tags_to_delete: T::Array[Amocrm::LeadUpdateByIDParams::TagsToDelete::OrHash],
          updated_at: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::LeadUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id,
        _embedded: nil,
        closed_at: nil,
        custom_fields_values: nil, # Custom fields payload
        group_id: nil,
        loss_reason_id: nil,
        name: nil,
        pipeline_id: nil,
        price: nil,
        responsible_user_id: nil,
        status_id: nil,
        tags_to_add: nil, # Tags to attach
        tags_to_delete: nil, # Tags to delete
        updated_at: nil,
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class PipelineStatuses
      # Create statuses.
      sig do
        params(
          pipeline_id: Integer,
          body: T::Array[Amocrm::PipelineStatusCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineStatusCreateResponse::Variants)
      end
      def create(pipeline_id, body:, request_options: {}); end

      # Delete status by id.
      sig do
        params(
          id: Integer,
          pipeline_id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineStatusDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, pipeline_id:, request_options: {}); end

      # Get status by id.
      sig do
        params(
          id: Integer,
          pipeline_id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineStatusGetByIDResponse::Variants)
      end
      def get_by_id(
        id, # Path param
        pipeline_id:, # Path param
        with: nil, # Query param: Expand related entities; comma-separated values (e.g.
                   # descriptions).
        request_options: {}
); end

      # Get statuses for a pipeline.
      sig do
        params(
          pipeline_id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineStatusListResponse::Variants)
      end
      def list(
        pipeline_id,
        with: nil, # Expand related entities; comma-separated values (e.g. descriptions).
        request_options: {}
); end

      # Update statuses (batch).
      sig do
        params(
          pipeline_id: Integer,
          body: T::Array[Amocrm::PipelineStatusUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineStatusUpdateResponse::Variants)
      end
      def update(pipeline_id, body:, request_options: {}); end

      # Update status by id.
      sig do
        params(
          id: Integer,
          pipeline_id: Integer,
          color: String,
          descriptions: T::Array[
              Amocrm::PipelineStatusUpdateByIDParams::Description::OrHash
            ],
          name: String,
          request_id: String,
          sort: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineStatusUpdateByIDResponse::Variants)
      end
      def update_by_id(
        id, # Path param
        pipeline_id:, # Path param
        color: nil, # Body param
        descriptions: nil, # Body param
        name: nil, # Body param
        request_id: nil, # Body param
        sort: nil, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Pipelines
      # Create pipelines.
      sig do
        params(
          body: T::Array[Amocrm::PipelineCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Delete pipeline by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, request_options: {}); end

      # Get pipeline by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineGetByIDResponse::Variants)
      end
      def get_by_id(id, request_options: {}); end

      # Get pipelines list.
      sig do
        params(
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineListResponse::Variants)
      end
      def list(request_options: {}); end

      # Update pipelines (batch).
      sig do
        params(
          body: T::Array[Amocrm::PipelineUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update pipeline by id.
      sig do
        params(
          id: Integer,
          is_archive: T::Boolean,
          is_main: T::Boolean,
          is_unsorted_on: T::Boolean,
          name: String,
          request_id: String,
          sort: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::PipelineUpdateByIDResponse::Variants)
      end
      def update_by_id(id, is_archive: nil, is_main: nil, is_unsorted_on: nil, name: nil, request_id: nil, sort: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Roles
      # Create roles (batch).
      sig do
        params(
          body: T::Array[Amocrm::RoleCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::RoleCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Delete role by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::RoleDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, request_options: {}); end

      # Get role by id.
      sig do
        params(
          id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::RoleGetByIDResponse::Variants)
      end
      def get_by_id(id, with: nil, request_options: {}); end

      # Get roles list.
      sig do
        params(
          limit: Integer,
          page: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::RoleListResponse::Variants)
      end
      def list(limit: nil, page: nil, with: nil, request_options: {}); end

      # Update role by id.
      sig do
        params(
          id: Integer,
          name: String,
          request_id: String,
          rights: T.nilable(Amocrm::RoleUpdateByIDParams::Rights::OrHash),
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::RoleUpdateByIDResponse::Variants)
      end
      def update_by_id(id, name: nil, request_id: nil, rights: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Salesbot
      # Run salesbot (batch, up to 100 tasks).
      sig do
        params(
          body: T::Array[Amocrm::SalesbotRunParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SalesbotRunResponse::Variants)
      end
      def run(body:, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class ShortLinks
      # Create short link.
      sig do
        params(
          url: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::ShortLinkCreateResponse::Variants)
      end
      def create(url:, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Sources
      # Create sources (batch).
      sig do
        params(
          body: T::Array[Amocrm::SourceCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SourceCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Delete sources (batch).
      sig do
        params(
          body: T::Array[Amocrm::SourceDeleteParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SourceDeleteResponse::Variants)
      end
      def delete(body:, request_options: {}); end

      # Delete source by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SourceDeleteByIDResponse::Variants)
      end
      def delete_by_id(id, request_options: {}); end

      # Get source by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SourceGetByIDResponse::Variants)
      end
      def get_by_id(id, request_options: {}); end

      # Get sources list.
      sig do
        params(
          filter: Amocrm::SourceListParams::Filter::OrHash,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SourceListResponse::Variants)
      end
      def list(filter: nil, request_options: {}); end

      # Update sources (batch).
      sig do
        params(
          body: T::Array[Amocrm::SourceUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SourceUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update source by id.
      sig do
        params(
          id: Integer,
          default: T::Boolean,
          external_id: String,
          name: String,
          origin_code: T.nilable(String),
          pipeline_id: T.nilable(Integer),
          request_id: String,
          services: Amocrm::SourceUpdateByIDParams::Services::Variants,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::SourceUpdateByIDResponse::Variants)
      end
      def update_by_id(id, default: nil, external_id: nil, name: nil, origin_code: nil, pipeline_id: nil, request_id: nil, services: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Tags
      # Create tags.
      sig do
        params(
          entity_type: Amocrm::TagCreateParams::EntityType::OrSymbol,
          body: T::Array[Amocrm::TagCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TagCreateResponse::Variants)
      end
      def create(entity_type, body:, request_options: {}); end

      # Get tags list.
      sig do
        params(
          entity_type: Amocrm::TagListParams::EntityType::OrSymbol,
          filter: T.anything,
          limit: Integer,
          page: Integer,
          query: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TagListResponse::Variants)
      end
      def list(entity_type, filter: nil, limit: nil, page: nil, query: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Talks
      # Close talk by id (optionally force without NPS bot).
      sig do
        params(
          id: Integer,
          force_close: T::Boolean,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TalkCloseResponse::Variants)
      end
      def close(
        id,
        force_close: nil, # Force close talk without NPS bot.
        request_options: {}
); end

      # Get talk by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TalkGetByIDResponse::Variants)
      end
      def get_by_id(id, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Tasks
      # Create tasks.
      sig do
        params(
          body: T::Array[Amocrm::TaskCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TaskCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Get a task by id.
      sig do
        params(
          id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TaskGetByIDResponse::Variants)
      end
      def get_by_id(id, request_options: {}); end

      # Get a list of tasks (pagination, sorting, filtering).
      sig do
        params(
          filter: T.anything,
          limit: Integer,
          order: T.anything,
          page: Integer,
          query: Amocrm::TaskListParams::Query::Variants,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TaskListResponse::Variants)
      end
      def list(
        filter: nil, # Filtering parameters
        limit: nil, # Pagination limit
        order: nil, # Sorting, e.g. order[updated_at]=asc
        page: nil, # Pagination page
        query: nil, # Search by query string or id
        request_options: {}
); end

      # Update tasks (batch).
      sig do
        params(
          body: T::Array[Amocrm::TaskUpdateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TaskUpdateResponse::Variants)
      end
      def update(body:, request_options: {}); end

      # Update a task by id.
      sig do
        params(
          id: Integer,
          complete_till: Integer,
          entity_id: Integer,
          entity_type: String,
          is_completed: T::Boolean,
          responsible_user_id: Integer,
          result: Amocrm::TaskUpdateByIDParams::Result::OrHash,
          task_type_id: Integer,
          text: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::TaskUpdateByIDResponse::Variants)
      end
      def update_by_id(id, complete_till: nil, entity_id: nil, entity_type: nil, is_completed: nil, responsible_user_id: nil, result: nil, task_type_id: nil, text: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class UnsortedLeads
      sig do
        params(
          uid: String,
          status_id: Integer,
          user_id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::UnsortedLeadAcceptResponse::Variants)
      end
      def accept(
        uid,
        status_id: nil, # Status id for the created lead
        user_id: nil, # User id on whose behalf the item is accepted
        request_options: {}
); end

      sig do
        params(
          body: T::Array[Amocrm::UnsortedLeadCreateFormsParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::UnsortedLeadCreateFormsResponse::Variants)
      end
      def create_forms(body:, request_options: {}); end

      sig do
        params(
          uid: String,
          user_id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::UnsortedLeadDeclineResponse::Variants)
      end
      def decline(
        uid,
        user_id: nil, # User id on whose behalf the item is declined
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Users
      # Create users (batch).
      sig do
        params(
          body: T::Array[Amocrm::UserCreateParams::Body::OrHash],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::UserCreateResponse::Variants)
      end
      def create(body:, request_options: {}); end

      # Get user by id.
      sig do
        params(
          id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::UserGetByIDResponse::Variants)
      end
      def get_by_id(id, with: nil, request_options: {}); end

      # Get users list.
      sig do
        params(
          limit: Integer,
          page: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::UserListResponse::Variants)
      end
      def list(limit: nil, page: nil, with: nil, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Webhooks
      # Get webhooks list.
      sig do
        params(
          filter: Amocrm::WebhookListParams::Filter::OrHash,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebhookListResponse::Variants)
      end
      def list(filter: nil, request_options: {}); end

      # Subscribe to webhook events.
      sig do
        params(
          destination: String,
          settings: T::Array[String],
          sort: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebhookSubscribeResponse::Variants)
      end
      def subscribe(destination:, settings:, sort: nil, request_options: {}); end

      # Unsubscribe webhook by destination.
      sig do
        params(
          destination: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebhookUnsubscribeResponse::Variants)
      end
      def unsubscribe(destination:, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class WebsiteButtons
      # Connect online chat to CRM Plugin.
      sig do
        params(
          source_id: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebsiteButtonConnectOnlineChatResponse::Variants)
      end
      def connect_online_chat(source_id, request_options: {}); end

      # Create CRM Plugin.
      sig do
        params(
          pipeline_id: Integer,
          is_used_in_app: T::Boolean,
          trusted_websites: T::Array[String],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebsiteButtonCreateResponse::Variants)
      end
      def create(pipeline_id:, is_used_in_app: nil, trusted_websites: nil, request_options: {}); end

      # Get CRM Plugin by source id.
      sig do
        params(
          source_id: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebsiteButtonGetBySourceIDResponse::Variants)
      end
      def get_by_source_id(source_id, with: nil, request_options: {}); end

      # Get CRM Plugin list.
      sig do
        params(
          limit: Integer,
          page: Integer,
          with: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebsiteButtonListResponse::Variants)
      end
      def list(limit: nil, page: nil, with: nil, request_options: {}); end

      # Update CRM Plugin trusted domains.
      sig do
        params(
          source_id: Integer,
          trusted_websites: Amocrm::WebsiteButtonUpdateParams::TrustedWebsites::OrHash,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WebsiteButtonUpdateResponse::Variants)
      end
      def update(source_id, trusted_websites:, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class WidgetBotContinue
      sig do
        params(
          continue_id: Integer,
          bot_type: Amocrm::WidgetBotContinueContinueParams::BotType::OrSymbol,
          bot_id: Integer,
          data: T.anything,
          execute_handlers: T::Array[
              Amocrm::WidgetBotContinueContinueParams::ExecuteHandler::OrHash
            ],
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WidgetBotContinueContinueResponse::Variants)
      end
      def continue(
        continue_id, # Path param
        bot_type:, # Path param
        bot_id:, # Path param
        data: nil, # Body param
        execute_handlers: nil, # Body param
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Widgets
      # Get widget info by code.
      sig do
        params(
          widget_code: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WidgetGetByCodeResponse::Variants)
      end
      def get_by_code(widget_code, request_options: {}); end

      # Install widget in account.
      sig do
        params(
          widget_code: String,
          body: T.anything,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WidgetInstallResponse::Variants)
      end
      def install(widget_code, body:, request_options: {}); end

      # Get widgets list.
      sig do
        params(
          limit: Integer,
          page: Integer,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WidgetListResponse::Variants)
      end
      def list(limit: nil, page: nil, request_options: {}); end

      # Uninstall widget from account.
      sig do
        params(
          widget_code: String,
          request_options: Amocrm::RequestOptions::OrHash
        ).returns(Amocrm::Models::WidgetUninstallResponse::Variants)
      end
      def uninstall(widget_code, request_options: {}); end

      class << self
        # @api private
        sig { params(client: Amocrm::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end
  end

  RoleCreateParams = Amocrm::Models::RoleCreateParams
  RoleDeleteByIDParams = Amocrm::Models::RoleDeleteByIDParams
  RoleGetByIDParams = Amocrm::Models::RoleGetByIDParams
  RoleListParams = Amocrm::Models::RoleListParams
  RoleUpdateByIDParams = Amocrm::Models::RoleUpdateByIDParams
  SalesbotRunParams = Amocrm::Models::SalesbotRunParams
  ShortLinkCreateParams = Amocrm::Models::ShortLinkCreateParams
  SourceCreateParams = Amocrm::Models::SourceCreateParams
  SourceDeleteByIDParams = Amocrm::Models::SourceDeleteByIDParams
  SourceDeleteParams = Amocrm::Models::SourceDeleteParams
  SourceGetByIDParams = Amocrm::Models::SourceGetByIDParams
  SourceListParams = Amocrm::Models::SourceListParams
  SourceUpdateByIDParams = Amocrm::Models::SourceUpdateByIDParams
  SourceUpdateParams = Amocrm::Models::SourceUpdateParams
  TagCreateParams = Amocrm::Models::TagCreateParams
  TagListParams = Amocrm::Models::TagListParams
  TalkCloseParams = Amocrm::Models::TalkCloseParams
  TalkGetByIDParams = Amocrm::Models::TalkGetByIDParams
  TaskCreateParams = Amocrm::Models::TaskCreateParams
  TaskGetByIDParams = Amocrm::Models::TaskGetByIDParams
  TaskListParams = Amocrm::Models::TaskListParams
  TaskUpdateByIDParams = Amocrm::Models::TaskUpdateByIDParams
  TaskUpdateParams = Amocrm::Models::TaskUpdateParams
  UnsortedLeadAcceptParams = Amocrm::Models::UnsortedLeadAcceptParams
  UnsortedLeadCreateFormsParams = Amocrm::Models::UnsortedLeadCreateFormsParams
  UnsortedLeadDeclineParams = Amocrm::Models::UnsortedLeadDeclineParams
  UserCreateParams = Amocrm::Models::UserCreateParams
  UserGetByIDParams = Amocrm::Models::UserGetByIDParams
  UserListParams = Amocrm::Models::UserListParams
  VERSION = T.let(T.unsafe(nil), String)
  WebhookListParams = Amocrm::Models::WebhookListParams
  WebhookSubscribeParams = Amocrm::Models::WebhookSubscribeParams
  WebhookUnsubscribeParams = Amocrm::Models::WebhookUnsubscribeParams

  WebsiteButtonConnectOnlineChatParams = Amocrm::Models::WebsiteButtonConnectOnlineChatParams

  WebsiteButtonCreateParams = Amocrm::Models::WebsiteButtonCreateParams

  WebsiteButtonGetBySourceIDParams = Amocrm::Models::WebsiteButtonGetBySourceIDParams

  WebsiteButtonListParams = Amocrm::Models::WebsiteButtonListParams
  WebsiteButtonUpdateParams = Amocrm::Models::WebsiteButtonUpdateParams

  WidgetBotContinueContinueParams = Amocrm::Models::WidgetBotContinueContinueParams

  WidgetGetByCodeParams = Amocrm::Models::WidgetGetByCodeParams
  WidgetInstallParams = Amocrm::Models::WidgetInstallParams
  WidgetListParams = Amocrm::Models::WidgetListParams
  WidgetUninstallParams = Amocrm::Models::WidgetUninstallParams
end
