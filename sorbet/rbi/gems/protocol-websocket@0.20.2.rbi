# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-websocket` gem.
# Please instead update this file by running `bin/tapioca gem protocol-websocket`.


# source://protocol-websocket//lib/protocol/websocket/error.rb#8
module Protocol; end

# source://protocol-websocket//lib/protocol/websocket/error.rb#9
module Protocol::WebSocket; end

# Represents a binary frame that is sent or received by a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/binary_frame.rb#13
class Protocol::WebSocket::BinaryFrame < ::Protocol::WebSocket::Frame
  # Apply this frame to the specified connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/binary_frame.rb#28
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/binary_frame.rb#17
  def data?; end

  # Decode the binary buffer into a suitable binary message.
  #
  # source://protocol-websocket//lib/protocol/websocket/binary_frame.rb#23
  def read_message(buffer); end
end

# source://protocol-websocket//lib/protocol/websocket/binary_frame.rb#14
Protocol::WebSocket::BinaryFrame::OPCODE = T.let(T.unsafe(nil), Integer)

# Represents a binary message that can be sent or received over a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/message.rb#70
class Protocol::WebSocket::BinaryMessage < ::Protocol::WebSocket::Message
  # source://protocol-websocket//lib/protocol/websocket/message.rb#71
  def send(connection, **options); end
end

# Represents a close frame that is sent or received by a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/close_frame.rb#12
class Protocol::WebSocket::CloseFrame < ::Protocol::WebSocket::Frame
  # Apply this frame to the specified connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/close_frame.rb#71
  def apply(connection); end

  # Pack a close code and reason into the frame data.
  # If code is missing, reason is ignored.
  #
  # source://protocol-websocket//lib/protocol/websocket/close_frame.rb#50
  def pack(code = T.unsafe(nil), reason = T.unsafe(nil)); end

  # Generate a suitable reply.
  #
  # source://protocol-websocket//lib/protocol/websocket/close_frame.rb#64
  def reply(code = T.unsafe(nil), reason = T.unsafe(nil)); end

  # Unpack the frame data into a close code and reason.
  #
  # source://protocol-websocket//lib/protocol/websocket/close_frame.rb#18
  def unpack; end
end

# source://protocol-websocket//lib/protocol/websocket/close_frame.rb#14
Protocol::WebSocket::CloseFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-websocket//lib/protocol/websocket/close_frame.rb#13
Protocol::WebSocket::CloseFrame::OPCODE = T.let(T.unsafe(nil), Integer)

# The connection was closed, maybe unexpectedly.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#55
class Protocol::WebSocket::ClosedError < ::Protocol::WebSocket::ProtocolError; end

# source://protocol-websocket//lib/protocol/websocket/coder/json.rb#10
module Protocol::WebSocket::Coder; end

# The default coder for WebSocket messages.
#
# source://protocol-websocket//lib/protocol/websocket/coder.rb#12
Protocol::WebSocket::Coder::DEFAULT = T.let(T.unsafe(nil), Protocol::WebSocket::Coder::JSON)

# A JSON coder that uses the standard JSON library.
#
# source://protocol-websocket//lib/protocol/websocket/coder/json.rb#12
class Protocol::WebSocket::Coder::JSON
  # @return [JSON] a new instance of JSON
  #
  # source://protocol-websocket//lib/protocol/websocket/coder/json.rb#13
  def initialize(**options); end

  # Generate a JSON buffer from an object.
  #
  # source://protocol-websocket//lib/protocol/websocket/coder/json.rb#23
  def generate(object); end

  # Parse a JSON buffer into an object.
  #
  # source://protocol-websocket//lib/protocol/websocket/coder/json.rb#18
  def parse(buffer); end
end

# The default JSON coder. This coder will symbolize names.
#
# source://protocol-websocket//lib/protocol/websocket/coder/json.rb#28
Protocol::WebSocket::Coder::JSON::DEFAULT = T.let(T.unsafe(nil), Protocol::WebSocket::Coder::JSON)

# Wraps a framer and implements for implementing connection specific interactions like reading and writing text.
#
# source://protocol-websocket//lib/protocol/websocket/connection.rb#13
class Protocol::WebSocket::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#15
  def initialize(framer, mask: T.unsafe(nil), **options); end

  # Immediately transition the connection to the closed state *and* close the underlying connection. Any data not yet read will be lost.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#92
  def close(*_arg0, **_arg1, &_arg2); end

  # If not already closed, transition the connection to the closed state and send a close frame.
  # Will try to send a close frame with the specified code and reason, but will ignore any errors that occur while sending.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#72
  def close!(*_arg0, **_arg1, &_arg2); end

  # Close the connection gracefully, sending a close frame with the specified error code and reason. If an error occurs while sending the close frame, the connection will be closed immediately. You may continue to read data from the connection after calling this method, but you should not write any more data.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#101
  def close_write(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#87
  def closed?; end

  # Flush the underlying framer to ensure all buffered data is written to the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#59
  def flush; end

  # Returns the value of attribute framer.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#29
  def framer; end

  # Returns the value of attribute frames.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#38
  def frames; end

  # Sets the attribute frames
  #
  # @param value the value to set the attribute frames to.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#38
  def frames=(_arg0); end

  # Returns the value of attribute mask.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#32
  def mask; end

  # Transition the connection to the open state (the default for new connections).
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#64
  def open!; end

  # Pack a binary frame with the specified buffer. This is used by the {#writer} interface.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#240
  def pack_binary_frame(buffer, **options); end

  # Pack a text frame with the specified buffer. This is used by the {#writer} interface.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#224
  def pack_text_frame(buffer, **options); end

  # Read a message from the connection. If an error occurs while reading the message, the connection will be closed.
  #
  # If the message is fragmented, this method will buffer the frames until a complete message is received.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#292
  def read(**options); end

  # Read a frame from the framer, and apply it to the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#120
  def read_frame; end

  # Returns the value of attribute reader.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#41
  def reader; end

  # Sets the attribute reader
  #
  # @param value the value to set the attribute reader to.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#41
  def reader=(_arg0); end

  # Receive a binary frame for the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#160
  def receive_binary(frame); end

  # Receive a close frame from the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#178
  def receive_close(frame); end

  # Receive a continuation frame for the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#169
  def receive_continuation(frame); end

  # Receive a frame that is not a control frame. By default, this method raises a {ProtocolError}.
  #
  # @raise [ProtocolError]
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#217
  def receive_frame(frame); end

  # Receive a ping frame from the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#203
  def receive_ping(frame); end

  # Receive a pong frame from the connection. By default, this method does nothing.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#212
  def receive_pong(frame); end

  # Receive a text frame from the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#151
  def receive_text(frame); end

  # Reserve a bit in the reserved flags for an extension.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#48
  def reserve!(bit); end

  # Returns the value of attribute reserved.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#35
  def reserved; end

  # Send a binary frame with the specified buffer.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#249
  def send_binary(buffer, **options); end

  # Send a control frame with data containing a specified control sequence to begin the closing handshake. Does not close the connection, until the remote end responds with a close frame.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#256
  def send_close(code = T.unsafe(nil), reason = T.unsafe(nil)); end

  # Send a ping frame with the specified data.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#191
  def send_ping(data = T.unsafe(nil)); end

  # Send a text frame with the specified buffer.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#233
  def send_text(buffer, **options); end

  # Close the connection gracefully. This will send a close frame and wait for the remote end to respond with a close frame. Any data received after the close frame is sent will be ignored. If you want to process this data, use {#close_write} instead, and read the data before calling {#close}.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#110
  def shutdown; end

  # The default implementation for reading a message buffer. This is used by the {#reader} interface.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#283
  def unpack_frames(frames); end

  # Write a message to the connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#266
  def write(message, **options); end

  # Write a frame to the framer.
  # Note: This does not immediately write the frame to the connection, you must call {#flush} to ensure the frame is written.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#144
  def write_frame(frame); end

  # Returns the value of attribute writer.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#44
  def writer; end

  # Sets the attribute writer
  #
  # @param value the value to set the attribute writer to.
  #
  # source://protocol-websocket//lib/protocol/websocket/connection.rb#44
  def writer=(_arg0); end
end

# Represents a continuation frame that is sent or received by a WebSocket connection when a message is split into multiple frames.
#
# source://protocol-websocket//lib/protocol/websocket/continuation_frame.rb#11
class Protocol::WebSocket::ContinuationFrame < ::Protocol::WebSocket::Frame
  # Apply this frame to the specified connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/continuation_frame.rb#15
  def apply(connection); end
end

# source://protocol-websocket//lib/protocol/websocket/continuation_frame.rb#12
Protocol::WebSocket::ContinuationFrame::OPCODE = T.let(T.unsafe(nil), Integer)

# Represents an error that occurred during the WebSocket protocol negotiation or communication.
# Status codes as defined by <https://tools.ietf.org/html/rfc6455#section-7.4.1>.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#12
class Protocol::WebSocket::Error < ::Protocol::HTTP::Error; end

# Indicates that an endpoint is "going away", such as a server going down or a browser having navigated away from a page.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#17
Protocol::WebSocket::Error::GOING_AWAY = T.let(T.unsafe(nil), Integer)

# Indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#39
Protocol::WebSocket::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# Indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept. (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#23
Protocol::WebSocket::Error::INVALID_DATA = T.let(T.unsafe(nil), Integer)

# Indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 data within a text message).
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#27
Protocol::WebSocket::Error::INVALID_PAYLOAD = T.let(T.unsafe(nil), Integer)

# Indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#33
Protocol::WebSocket::Error::MESSAGE_TOO_LARGE = T.let(T.unsafe(nil), Integer)

# Indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake. The list of extensions that are needed should appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#36
Protocol::WebSocket::Error::MISSING_EXTENSION = T.let(T.unsafe(nil), Integer)

# Indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#14
Protocol::WebSocket::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)

# Indicates that an endpoint is terminating the connection because it has received a message that violates its policy. This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#30
Protocol::WebSocket::Error::POLICY_VIOLATION = T.let(T.unsafe(nil), Integer)

# Indicates that an endpoint is terminating the connection due to a protocol error.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#20
Protocol::WebSocket::Error::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-websocket//lib/protocol/websocket/extension/compression/constants.rb#10
module Protocol::WebSocket::Extension; end

# Provides support for the permessage-deflate extension.
#
# source://protocol-websocket//lib/protocol/websocket/extension/compression/constants.rb#11
module Protocol::WebSocket::Extension::Compression
  class << self
    # Accept on the client, the negotiated server response.
    #
    # source://protocol-websocket//lib/protocol/websocket/extension/compression.rb#94
    def accept(arguments, **options); end

    # source://protocol-websocket//lib/protocol/websocket/extension/compression.rb#114
    def client(connection, **options); end

    # Negotiate on the server a response to client based on the incoming client offer.
    #
    # source://protocol-websocket//lib/protocol/websocket/extension/compression.rb#53
    def negotiate(arguments, **options); end

    # Client offer to server, construct a list of requested compression parameters suitable for the `Sec-WebSocket-Extensions` header.
    #
    # source://protocol-websocket//lib/protocol/websocket/extension/compression.rb#17
    def offer(client_max_window_bits: T.unsafe(nil), server_max_window_bits: T.unsafe(nil), client_no_context_takeover: T.unsafe(nil), server_no_context_takeover: T.unsafe(nil)); end

    # source://protocol-websocket//lib/protocol/websocket/extension/compression.rb#84
    def server(connection, **options); end
  end
end

# source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#12
class Protocol::WebSocket::Extension::Compression::Deflate
  # @return [Deflate] a new instance of Deflate
  #
  # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#31
  def initialize(parent, level: T.unsafe(nil), memory_level: T.unsafe(nil), strategy: T.unsafe(nil), window_bits: T.unsafe(nil), context_takeover: T.unsafe(nil), **options); end

  # Returns the value of attribute context_takeover.
  #
  # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#54
  def context_takeover; end

  # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#70
  def pack_binary_frame(buffer, compress: T.unsafe(nil), **options); end

  # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#56
  def pack_text_frame(buffer, compress: T.unsafe(nil), **options); end

  # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#49
  def to_s; end

  # Returns the value of attribute window_bits.
  #
  # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#53
  def window_bits; end

  private

  # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#86
  def deflate(buffer); end

  class << self
    # Client writing to server.
    #
    # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#14
    def client(parent, client_max_window_bits: T.unsafe(nil), client_no_context_takeover: T.unsafe(nil), **options); end

    # Server writing to client.
    #
    # source://protocol-websocket//lib/protocol/websocket/extension/compression/deflate.rb#23
    def server(parent, server_max_window_bits: T.unsafe(nil), server_no_context_takeover: T.unsafe(nil), **options); end
  end
end

# source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#12
class Protocol::WebSocket::Extension::Compression::Inflate
  # @return [Inflate] a new instance of Inflate
  #
  # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#31
  def initialize(parent, context_takeover: T.unsafe(nil), window_bits: T.unsafe(nil)); end

  # Returns the value of attribute context_takeover.
  #
  # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#50
  def context_takeover; end

  # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#45
  def to_s; end

  # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#52
  def unpack_frames(frames, **options); end

  # Returns the value of attribute window_bits.
  #
  # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#49
  def window_bits; end

  private

  # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#67
  def inflate(buffer); end

  class << self
    # Client reading from server.
    #
    # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#14
    def client(parent, server_max_window_bits: T.unsafe(nil), server_no_context_takeover: T.unsafe(nil), **options); end

    # Server reading from client.
    #
    # source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#22
    def server(parent, client_max_window_bits: T.unsafe(nil), client_no_context_takeover: T.unsafe(nil), **options); end
  end
end

# source://protocol-websocket//lib/protocol/websocket/extension/compression/inflate.rb#29
Protocol::WebSocket::Extension::Compression::Inflate::TRAILER = T.let(T.unsafe(nil), String)

# Zlib is not capable of handling < 9 window bits.
#
# source://protocol-websocket//lib/protocol/websocket/extension/compression/constants.rb#15
Protocol::WebSocket::Extension::Compression::MINIMUM_WINDOW_BITS = T.let(T.unsafe(nil), Integer)

# source://protocol-websocket//lib/protocol/websocket/extension/compression/constants.rb#12
Protocol::WebSocket::Extension::Compression::NAME = T.let(T.unsafe(nil), String)

# source://protocol-websocket//lib/protocol/websocket/extensions.rb#11
module Protocol::WebSocket::Extensions
  class << self
    # source://protocol-websocket//lib/protocol/websocket/extensions.rb#12
    def parse(headers); end
  end
end

# source://protocol-websocket//lib/protocol/websocket/extensions.rb#26
class Protocol::WebSocket::Extensions::Client
  # @return [Client] a new instance of Client
  #
  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#33
  def initialize(extensions = T.unsafe(nil)); end

  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#55
  def accept(headers); end

  # Returns the value of attribute accepted.
  #
  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#39
  def accepted; end

  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#72
  def apply(connection); end

  # Returns the value of attribute extensions.
  #
  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#38
  def extensions; end

  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#41
  def named; end

  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#47
  def offer; end

  class << self
    # source://protocol-websocket//lib/protocol/websocket/extensions.rb#27
    def default; end
  end
end

# source://protocol-websocket//lib/protocol/websocket/extensions.rb#79
class Protocol::WebSocket::Extensions::Server
  # @return [Server] a new instance of Server
  #
  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#86
  def initialize(extensions); end

  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#100
  def accept(headers); end

  # Returns the value of attribute accepted.
  #
  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#92
  def accepted; end

  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#127
  def apply(connection); end

  # Returns the value of attribute extensions.
  #
  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#91
  def extensions; end

  # source://protocol-websocket//lib/protocol/websocket/extensions.rb#94
  def named; end

  class << self
    # source://protocol-websocket//lib/protocol/websocket/extensions.rb#80
    def default; end
  end
end

# HTTP/2 frame type mapping as defined by the spec.
#
# source://protocol-websocket//lib/protocol/websocket/framer.rb#18
Protocol::WebSocket::FRAMES = T.let(T.unsafe(nil), Hash)

# source://protocol-websocket//lib/protocol/websocket/frame.rb#13
class Protocol::WebSocket::Frame
  include ::Comparable

  # @return [Frame] a new instance of Frame
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#25
  def initialize(finished = T.unsafe(nil), payload = T.unsafe(nil), flags: T.unsafe(nil), opcode: T.unsafe(nil), mask: T.unsafe(nil)); end

  # source://protocol-websocket//lib/protocol/websocket/frame.rb#42
  def <=>(other); end

  # source://protocol-websocket//lib/protocol/websocket/frame.rb#145
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#63
  def continued?; end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#50
  def control?; end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#55
  def data?; end

  # The generic frame header uses the following binary representation:
  #
  #  0                   1                   2                   3
  #  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  # +-+-+-+-+-------+-+-------------+-------------------------------+
  # |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
  # |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
  # |N|V|V|V|       |S|             |   (if payload len==126/127)   |
  # +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  # + - - - - - - - - - - - - - - - +-------------------------------+
  # +-------------------------------+-------------------------------+
  # +-------------------------------- - - - - - - - - - - - - - - - +
  # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
  # +---------------------------------------------------------------+
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#88
  def finished; end

  # The generic frame header uses the following binary representation:
  #
  #  0                   1                   2                   3
  #  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  # +-+-+-+-+-------+-+-------------+-------------------------------+
  # |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
  # |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
  # |N|V|V|V|       |S|             |   (if payload len==126/127)   |
  # +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  # + - - - - - - - - - - - - - - - +-------------------------------+
  # +-------------------------------+-------------------------------+
  # +-------------------------------- - - - - - - - - - - - - - - - +
  # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
  # +---------------------------------------------------------------+
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#88
  def finished=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#59
  def finished?; end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#38
  def flag?(value); end

  # Returns the value of attribute flags.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#89
  def flags; end

  # Sets the attribute flags
  #
  # @param value the value to set the attribute flags to.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#89
  def flags=(_arg0); end

  # Returns the value of attribute length.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#92
  def length; end

  # Sets the attribute length
  #
  # @param value the value to set the attribute length to.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#92
  def length=(_arg0); end

  # Returns the value of attribute mask.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#91
  def mask; end

  # Sets the attribute mask
  #
  # @param value the value to set the attribute mask to.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#91
  def mask=(_arg0); end

  # Returns the value of attribute opcode.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#90
  def opcode; end

  # Sets the attribute opcode
  #
  # @param value the value to set the attribute opcode to.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#90
  def opcode=(_arg0); end

  # source://protocol-websocket//lib/protocol/websocket/frame.rb#119
  def pack(data = T.unsafe(nil)); end

  # Returns the value of attribute payload.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#93
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://protocol-websocket//lib/protocol/websocket/frame.rb#93
  def payload=(_arg0); end

  # source://protocol-websocket//lib/protocol/websocket/frame.rb#46
  def to_ary; end

  # source://protocol-websocket//lib/protocol/websocket/frame.rb#137
  def unpack; end

  # source://protocol-websocket//lib/protocol/websocket/frame.rb#205
  def write(stream); end

  private

  # source://protocol-websocket//lib/protocol/websocket/frame.rb#96
  def mask_xor(data, mask); end

  class << self
    # source://protocol-websocket//lib/protocol/websocket/frame.rb#149
    def parse_header(buffer); end

    # source://protocol-websocket//lib/protocol/websocket/frame.rb#165
    def read(finished, flags, opcode, stream, maximum_frame_size); end
  end
end

# source://protocol-websocket//lib/protocol/websocket/frame.rb#21
Protocol::WebSocket::Frame::OPCODE = T.let(T.unsafe(nil), Integer)

# source://protocol-websocket//lib/protocol/websocket/frame.rb#19
Protocol::WebSocket::Frame::RESERVED = T.let(T.unsafe(nil), Integer)

# source://protocol-websocket//lib/protocol/websocket/frame.rb#16
Protocol::WebSocket::Frame::RSV1 = T.let(T.unsafe(nil), Integer)

# source://protocol-websocket//lib/protocol/websocket/frame.rb#17
Protocol::WebSocket::Frame::RSV2 = T.let(T.unsafe(nil), Integer)

# source://protocol-websocket//lib/protocol/websocket/frame.rb#18
Protocol::WebSocket::Frame::RSV3 = T.let(T.unsafe(nil), Integer)

# When the frame payload does not match expectations.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#59
class Protocol::WebSocket::FrameSizeError < ::Protocol::WebSocket::ProtocolError; end

# Wraps an underlying {Async::IO::Stream} for reading and writing binary data into structured frames.
#
# source://protocol-websocket//lib/protocol/websocket/framer.rb#31
class Protocol::WebSocket::Framer
  # @return [Framer] a new instance of Framer
  #
  # source://protocol-websocket//lib/protocol/websocket/framer.rb#32
  def initialize(stream, frames = T.unsafe(nil)); end

  # Close the underlying stream.
  #
  # source://protocol-websocket//lib/protocol/websocket/framer.rb#38
  def close; end

  # Flush the underlying stream.
  #
  # source://protocol-websocket//lib/protocol/websocket/framer.rb#43
  def flush; end

  # Read a frame from the underlying stream.
  #
  # source://protocol-websocket//lib/protocol/websocket/framer.rb#49
  def read_frame(maximum_frame_size = T.unsafe(nil)); end

  # Read the header of the frame.
  #
  # @raise [EOFError]
  #
  # source://protocol-websocket//lib/protocol/websocket/framer.rb#66
  def read_header; end

  # Write a frame to the underlying stream.
  #
  # source://protocol-websocket//lib/protocol/websocket/framer.rb#61
  def write_frame(frame); end
end

# source://protocol-websocket//lib/protocol/websocket/headers.rb#11
module Protocol::WebSocket::Headers; end

# source://protocol-websocket//lib/protocol/websocket/headers.rb#26
module Protocol::WebSocket::Headers::Nounce
  class << self
    # Valid for the `SEC_WEBSOCKET_ACCEPT` header.
    #
    # source://protocol-websocket//lib/protocol/websocket/headers.rb#35
    def accept_digest(key); end

    # Valid for the `SEC_WEBSOCKET_KEY` header.
    #
    # source://protocol-websocket//lib/protocol/websocket/headers.rb#30
    def generate_key; end
  end
end

# source://protocol-websocket//lib/protocol/websocket/headers.rb#27
Protocol::WebSocket::Headers::Nounce::GUID = T.let(T.unsafe(nil), String)

# The protocol string used for the `upgrade:` header (HTTP/1) and `:protocol` pseudo-header (HTTP/2).
#
# source://protocol-websocket//lib/protocol/websocket/headers.rb#13
Protocol::WebSocket::Headers::PROTOCOL = T.let(T.unsafe(nil), String)

# source://protocol-websocket//lib/protocol/websocket/headers.rb#22
Protocol::WebSocket::Headers::SEC_WEBSOCKET_ACCEPT = T.let(T.unsafe(nil), String)

# source://protocol-websocket//lib/protocol/websocket/headers.rb#24
Protocol::WebSocket::Headers::SEC_WEBSOCKET_EXTENSIONS = T.let(T.unsafe(nil), String)

# source://protocol-websocket//lib/protocol/websocket/headers.rb#21
Protocol::WebSocket::Headers::SEC_WEBSOCKET_KEY = T.let(T.unsafe(nil), String)

# The WebSocket protocol header, used for application level protocol negotiation.
#
# source://protocol-websocket//lib/protocol/websocket/headers.rb#16
Protocol::WebSocket::Headers::SEC_WEBSOCKET_PROTOCOL = T.let(T.unsafe(nil), String)

# The WebSocket version header. Used for negotiating binary protocol version.
#
# source://protocol-websocket//lib/protocol/websocket/headers.rb#19
Protocol::WebSocket::Headers::SEC_WEBSOCKET_VERSION = T.let(T.unsafe(nil), String)

# The maximum allowed frame size in bytes.
#
# source://protocol-websocket//lib/protocol/websocket/framer.rb#28
Protocol::WebSocket::MAXIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# Represents a message that can be sent or received over a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/message.rb#12
class Protocol::WebSocket::Message
  # Create a new message from a buffer.
  #
  # @return [Message] a new instance of Message
  #
  # source://protocol-websocket//lib/protocol/websocket/message.rb#15
  def initialize(buffer = T.unsafe(nil)); end

  # Compare this message to another message or buffer.
  #
  # source://protocol-websocket//lib/protocol/websocket/message.rb#28
  def ==(other); end

  # Returns the value of attribute buffer.
  #
  # source://protocol-websocket//lib/protocol/websocket/message.rb#20
  def buffer; end

  # The encoding of the message buffer.
  #
  # source://protocol-websocket//lib/protocol/websocket/message.rb#39
  def encoding; end

  # Parse the message buffer using the given coder. Defaults to JSON.
  #
  # source://protocol-websocket//lib/protocol/websocket/message.rb#51
  def parse(coder = T.unsafe(nil)); end

  # source://protocol-websocket//lib/protocol/websocket/message.rb#60
  def send(connection, **options); end

  # source://protocol-websocket//lib/protocol/websocket/message.rb#23
  def size; end

  # Convert the message buffer to a hash using the given coder. Defaults to JSON.
  #
  # source://protocol-websocket//lib/protocol/websocket/message.rb#56
  def to_h(*_arg0, **_arg1, &_arg2); end

  # A message is implicitly convertible to it's buffer.
  #
  # source://protocol-websocket//lib/protocol/websocket/message.rb#33
  def to_str; end

  class << self
    # Generate a message from a value using the given coder.
    #
    # source://protocol-websocket//lib/protocol/websocket/message.rb#46
    def generate(value, coder = T.unsafe(nil)); end
  end
end

# Represents a ping frame that is sent or received by a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/ping_frame.rb#12
class Protocol::WebSocket::PingFrame < ::Protocol::WebSocket::Frame
  # Apply this frame to the specified connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/ping_frame.rb#22
  def apply(connection); end

  # Generate a suitable reply.
  #
  # source://protocol-websocket//lib/protocol/websocket/ping_frame.rb#17
  def reply(**options); end
end

# source://protocol-websocket//lib/protocol/websocket/ping_frame.rb#13
Protocol::WebSocket::PingFrame::OPCODE = T.let(T.unsafe(nil), Integer)

# Represents a ping message that can be sent over a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/message.rb#77
class Protocol::WebSocket::PingMessage < ::Protocol::WebSocket::Message
  # source://protocol-websocket//lib/protocol/websocket/message.rb#78
  def send(connection); end
end

# Represents a pong frame that is sent or received by a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/pong_frame.rb#11
class Protocol::WebSocket::PongFrame < ::Protocol::WebSocket::Frame
  # Apply this frame to the specified connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/pong_frame.rb#15
  def apply(connection); end
end

# source://protocol-websocket//lib/protocol/websocket/pong_frame.rb#12
Protocol::WebSocket::PongFrame::OPCODE = T.let(T.unsafe(nil), Integer)

# Raised by stream or connection handlers, results in GOAWAY frame which signals termination of the current connection. You *cannot* recover from this exception, or any exceptions subclassed from it.
#
# source://protocol-websocket//lib/protocol/websocket/error.rb#43
class Protocol::WebSocket::ProtocolError < ::Protocol::WebSocket::Error
  # @return [ProtocolError] a new instance of ProtocolError
  #
  # source://protocol-websocket//lib/protocol/websocket/error.rb#44
  def initialize(message, code = T.unsafe(nil)); end

  # Returns the value of attribute code.
  #
  # source://protocol-websocket//lib/protocol/websocket/error.rb#51
  def code; end
end

# Represents a text frame that is sent or received by a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/text_frame.rb#13
class Protocol::WebSocket::TextFrame < ::Protocol::WebSocket::Frame
  # Apply this frame to the specified connection.
  #
  # source://protocol-websocket//lib/protocol/websocket/text_frame.rb#34
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-websocket//lib/protocol/websocket/text_frame.rb#17
  def data?; end

  # Decode the binary buffer into a suitable text message.
  #
  # source://protocol-websocket//lib/protocol/websocket/text_frame.rb#23
  def read_message(buffer); end
end

# source://protocol-websocket//lib/protocol/websocket/text_frame.rb#14
Protocol::WebSocket::TextFrame::OPCODE = T.let(T.unsafe(nil), Integer)

# Represents a text message that can be sent or received over a WebSocket connection.
#
# source://protocol-websocket//lib/protocol/websocket/message.rb#66
class Protocol::WebSocket::TextMessage < ::Protocol::WebSocket::Message; end

# source://protocol-websocket//lib/protocol/websocket/version.rb#8
Protocol::WebSocket::VERSION = T.let(T.unsafe(nil), String)
