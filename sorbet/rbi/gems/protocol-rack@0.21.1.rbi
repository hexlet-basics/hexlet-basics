# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-rack` gem.
# Please instead update this file by running `bin/tapioca gem protocol-rack`.


# source://protocol-rack//lib/protocol/rack/constants.rb#6
module Protocol; end

# source://protocol-rack//lib/protocol/rack/constants.rb#7
module Protocol::Rack; end

# The Rack adapter provides a bridge between Protocol::HTTP and Rack applications.
# It automatically selects the appropriate implementation based on the installed Rack version.
#
# ```ruby
# app = ->(env) { [200, {"content-type" => "text/plain"}, ["Hello World"]] }
# adapter = Protocol::Rack::Adapter.new(app)
# response = adapter.call(request)
# ```
#
# source://protocol-rack//lib/protocol/rack/adapter.rb#18
module Protocol::Rack::Adapter
  class << self
    # Converts a Rack response into a Protocol::HTTP response.
    #
    # source://protocol-rack//lib/protocol/rack/adapter.rb#46
    def make_response(env, response); end

    # Creates a new adapter instance for the given Rack application.
    #
    # source://protocol-rack//lib/protocol/rack/adapter.rb#37
    def new(app); end

    # Parses a file path from the Rack environment.
    #
    # source://protocol-rack//lib/protocol/rack/adapter.rb#54
    def parse_file(*_arg0, **_arg1, &_arg2); end
  end
end

# The base adapter class that provides common functionality for all Rack adapters.
# It handles the conversion between {Protocol::HTTP} and Rack environments.
#
# source://protocol-rack//lib/protocol/rack/adapter/generic.rb#18
class Protocol::Rack::Adapter::Generic
  # Initialize the rack adaptor middleware.
  #
  # @raise [ArgumentError]
  # @return [Generic] a new instance of Generic
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#41
  def initialize(app); end

  # Build a rack `env` from the incoming request and apply it to the rack middleware.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#176
  def call(request); end

  # Generate a suitable response for the given exception.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#202
  def failure_response(exception); end

  # Handle errors that occur during request processing. Logs the error, closes any response body, invokes `rack.response_finished` callbacks, and returns an appropriate failure response.
  #
  # The `rack.response_finished` callbacks are invoked in reverse order of registration, as specified by the Rack specification. If a callback raises an exception, it is caught and logged, but does not prevent other callbacks from being invoked.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#149
  def handle_error(env, status, headers, body, error); end

  # The logger to use for this adapter.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#50
  def logger; end

  # Create a base environment hash for the request.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#133
  def make_environment(request); end

  # Unwrap HTTP headers into the CGI-style expected by Rack middleware, and add them to the rack `env`.
  #
  # e.g. `accept-encoding` becomes `HTTP_ACCEPT_ENCODING`.
  #
  # Headers keys with underscores will generate the same CGI-style header key as headers with dashes.
  #
  # e.g `accept_encoding` becomes `HTTP_ACCEPT_ENCODING` too.
  #
  # You should not implicitly trust the `HTTP_` headers for security purposes, as they are generated by the client.
  #
  # Multiple headers are combined with a comma, with one exception: `HTTP_COOKIE` headers are combined with a semicolon.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#68
  def unwrap_headers(headers, env); end

  # Process the incoming request into a valid rack `env`.
  #
  # - Set the `env['CONTENT_TYPE']` and `env['CONTENT_LENGTH']` based on the incoming request body.
  # - Set the `env['HTTP_HOST']` header to the request authority.
  # - Set the `env['HTTP_X_FORWARDED_PROTO']` header to the request scheme.
  # - Set `env['REMOTE_ADDR']` to the request remote adress.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#93
  def unwrap_request(request, env); end

  class << self
    # Extract protocol information from the environment and response.
    #
    # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#211
    def extract_protocol(env, response, headers); end

    # Parses a Rackup file and returns the application.
    #
    # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#32
    def parse_file(*_arg0, **_arg1, &_arg2); end

    # Creates a new adapter instance for the given Rack application.
    # Wraps the adapter in a {Rewindable} instance to ensure request body can be read multiple times, which is required for Rack < 3.
    #
    # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#24
    def wrap(app); end
  end
end

# source://protocol-rack//lib/protocol/rack/adapter.rb#24
Protocol::Rack::Adapter::IMPLEMENTATION = Protocol::Rack::Adapter::Rack31

# The Rack 3 adapter provides compatibility with Rack 3.x applications.
# It handles the conversion between {Protocol::HTTP} and Rack 3 environments.
# Unlike Rack 2, this adapter supports streaming responses and has a simpler environment setup.
#
# source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#17
class Protocol::Rack::Adapter::Rack3 < ::Protocol::Rack::Adapter::Generic
  # Create a Rack 3 environment hash for the request.
  # Sets up all required Rack 3 environment variables and processes the request.
  # Unlike Rack 2, this adapter doesn't set Rack version or threading flags.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#42
  def make_environment(request); end

  # Process the rack response headers into a {Protocol::HTTP::Headers} instance, along with any extra `rack.` metadata.
  # Unlike Rack 2, this adapter handles array values directly without splitting on newlines.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#95
  def wrap_headers(fields); end

  class << self
    # Convert a {Protocol::HTTP::Response} into a Rack 3 response tuple.
    # Handles protocol upgrades and streaming responses.
    # Unlike Rack 2, this adapter forces streaming responses by converting the body to a callable.
    #
    # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#123
    def make_response(env, response); end

    # Parses a Rackup file and returns the application.
    # Uses the Rack 3.x interface for parsing Rackup files.
    #
    # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#32
    def parse_file(*_arg0, **_arg1, &_arg2); end

    # Creates a new adapter instance for the given Rack application.
    # Unlike Rack 2, this adapter doesn't require a {Rewindable} wrapper.
    #
    # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#23
    def wrap(app); end
  end
end

# The Rack 3.1 adapter provides compatibility with Rack 3.1.x applications.
# It extends the Rack 3 adapter with improved request body handling and protocol support.
# Key improvements include:
# - Better handling of empty request bodies
# - Direct protocol support via {RACK_PROTOCOL}
# - More efficient body streaming
#
# source://protocol-rack//lib/protocol/rack/adapter/rack31.rb#20
class Protocol::Rack::Adapter::Rack31 < ::Protocol::Rack::Adapter::Rack3
  # Create a Rack 3.1 environment hash for the request.
  # Sets up all required Rack 3.1 environment variables and processes the request.
  # Unlike Rack 3, this adapter has improved body handling and protocol support.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/rack31.rb#27
  def make_environment(request); end
end

# The version of Rack being used. Can be overridden using the PROTOCOL_RACK_ADAPTER_VERSION environment variable.
#
# source://protocol-rack//lib/protocol/rack/adapter.rb#20
Protocol::Rack::Adapter::VERSION = T.let(T.unsafe(nil), String)

# The Body module provides functionality for handling Rack response bodies.
# It includes methods for wrapping different types of response bodies and handling completion callbacks.
#
# source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#11
module Protocol::Rack::Body
  class << self
    # Create a completion callback for response finished handlers. The callback is called with any error that occurred during response processing.
    #
    # Callbacks are invoked in reverse order of registration, as specified by the Rack specification.
    # If a callback raises an exception, it is caught and logged, but does not prevent other callbacks from being invoked.
    #
    # source://protocol-rack//lib/protocol/rack/body.rb#117
    def completion_callback(response_finished, env, status, headers); end

    # Check if the given status code indicates no content should be returned.
    # Status codes 204 (No Content), 205 (Reset Content), and 304 (Not Modified) should not include a response body.
    #
    # @return [Boolean]
    #
    # source://protocol-rack//lib/protocol/rack/body.rb#27
    def no_content?(status); end

    # Wrap a Rack response body into a {Protocol::HTTP::Body} instance.
    # Handles different types of response bodies:
    # - {Protocol::HTTP::Body::Readable} instances are returned as-is.
    # - Bodies that respond to `to_path` are wrapped in {Protocol::HTTP::Body::File}.
    # - Enumerable bodies are wrapped in {Body::Enumerable}.
    # - Other bodies are wrapped in {Body::Streaming}.
    #
    # source://protocol-rack//lib/protocol/rack/body.rb#45
    def wrap(env, status, headers, body, input = T.unsafe(nil), head = T.unsafe(nil)); end
  end
end

# The `content-length` header key.
#
# source://protocol-rack//lib/protocol/rack/body.rb#20
Protocol::Rack::Body::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# Wraps a Rack response body that responds to `each`.
# The body must only yield `String` values and may optionally respond to `close`.
# This class provides both streaming and buffered access to the response body.
#
# source://protocol-rack//lib/protocol/rack/body/enumerable.rb#15
class Protocol::Rack::Body::Enumerable < ::Protocol::HTTP::Body::Readable
  # Initialize the enumerable body wrapper.
  #
  # @return [Enumerable] a new instance of Enumerable
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#38
  def initialize(body, length); end

  # Returns the value of attribute body.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#46
  def body; end

  # Stream the response body to the given stream.
  # The body is automatically closed after streaming.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#110
  def call(stream); end

  # Close the response body.
  # If the body responds to `close`, it will be called.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#71
  def close(error = T.unsafe(nil)); end

  # Enumerate the response body.
  # Each chunk yielded must be a String.
  # The body is automatically closed after enumeration.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#90
  def each(&block); end

  # Check if the response body is empty.
  # A body is considered empty if its length is 0 or if it responds to `empty?` and is empty.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#55
  def empty?; end

  # Get a string representation of the body.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#133
  def inspect; end

  # Returns the value of attribute length.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#49
  def length; end

  # Read the next chunk from the response body.
  # Returns nil when there are no more chunks.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#122
  def read; end

  # Check if the response body can be read immediately.
  # A body is ready if it's an Array or responds to `to_ary`.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#63
  def ready?; end

  # Check if the body is a streaming response.
  # A body is streaming if it doesn't respond to `each`.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#102
  def stream?; end

  class << self
    # Wraps a Rack response body into an {Enumerable} instance.
    # If the body is an Array, its total size is calculated automatically.
    #
    # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#25
    def wrap(body, length = T.unsafe(nil)); end
  end
end

# The content-length header key.
#
# source://protocol-rack//lib/protocol/rack/body/enumerable.rb#17
Protocol::Rack::Body::Enumerable::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# Wraps a Rack input object into a readable body.
# This class provides a consistent interface for reading from Rack input streams,
# which may be any IO-like object that responds to `read` and `close`.
#
# source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#15
class Protocol::Rack::Body::InputWrapper < ::Protocol::HTTP::Body::Readable
  # Initialize the input wrapper.
  #
  # @return [InputWrapper] a new instance of InputWrapper
  #
  # source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#23
  def initialize(io, block_size: T.unsafe(nil)); end

  # Close the input stream.
  # If the input object responds to `close`, it will be called.
  #
  # source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#34
  def close(error = T.unsafe(nil)); end

  # Read the next chunk from the input stream.
  # Returns nil when there is no more data to read.
  #
  # source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#45
  def read; end
end

# The default block size for reading from the input stream.
#
# source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#17
Protocol::Rack::Body::InputWrapper::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# Wraps a Rack streaming response body.
# The body must be callable and accept a stream argument.
# This is typically used for Rack hijack responses or bodies wrapped in `Rack::BodyProxy`.
# When closed, this class ensures the wrapped body's `close` method is called if it exists.
#
# source://protocol-rack//lib/protocol/rack/body/streaming.rb#15
class Protocol::Rack::Body::Streaming < ::Protocol::HTTP::Body::Streamable::ResponseBody
  # Initialize the streaming body wrapper.
  #
  # @return [Streaming] a new instance of Streaming
  #
  # source://protocol-rack//lib/protocol/rack/body/streaming.rb#20
  def initialize(body, input = T.unsafe(nil)); end

  # Close the streaming body and clean up resources.
  # If the wrapped body responds to `close`, it will be called to allow proper cleanup.
  # This ensures that `Rack::BodyProxy` cleanup callbacks are invoked correctly.
  #
  # source://protocol-rack//lib/protocol/rack/body/streaming.rb#31
  def close(error = T.unsafe(nil)); end
end

# CGI keys <https://tools.ietf.org/html/rfc3875#section-4.1>:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#12
module Protocol::Rack::CGI; end

# source://protocol-rack//lib/protocol/rack/constants.rb#26
Protocol::Rack::CGI::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#25
Protocol::Rack::CGI::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#28
Protocol::Rack::CGI::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#13
Protocol::Rack::CGI::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#14
Protocol::Rack::CGI::HTTP_UPGRADE = T.let(T.unsafe(nil), String)

# Header constants:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#31
Protocol::Rack::CGI::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#15
Protocol::Rack::CGI::PATH_INFO = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#20
Protocol::Rack::CGI::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#24
Protocol::Rack::CGI::REMOTE_ADDR = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#16
Protocol::Rack::CGI::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#17
Protocol::Rack::CGI::REQUEST_PATH = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#18
Protocol::Rack::CGI::REQUEST_URI = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#19
Protocol::Rack::CGI::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#22
Protocol::Rack::CGI::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#23
Protocol::Rack::CGI::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#21
Protocol::Rack::CGI::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# Wraps a streaming input body into the interface required by `rack.input`.
#
# The input stream is an `IO`-like object which contains the raw HTTP POST data. When applicable, its external encoding must be `ASCII-8BIT` and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to `gets`, `each`, `read` and `rewind`.
#
# This implementation is not always rewindable, to avoid buffering the input when handling large uploads. See {Rewindable} for more details.
#
# source://protocol-rack//lib/protocol/rack/input.rb#16
class Protocol::Rack::Input
  include ::IO::Stream::Readable

  # Initialize the input wrapper.
  #
  # @return [Input] a new instance of Input
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#21
  def initialize(body, *_arg1, **_arg2, &_arg3); end

  # The input body.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#30
  def body; end

  # Close the input and output bodies.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#46
  def close(error = T.unsafe(nil)); end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#77
  def closed?; end

  # Enumerate chunks of the request body.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#35
  def each(&block); end

  # Whether there are any input chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#82
  def empty?; end

  # Rewind the input stream back to the start.
  #
  # `rewind` must be called without arguments. It rewinds the input stream back to the beginning. It must not raise Errno::ESPIPE: that is, it may not be a pipe or a socket. Therefore, handler developers must buffer the input data into some rewindable object if the underlying input stream is not rewindable.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#62
  def rewind; end

  private

  # source://protocol-rack//lib/protocol/rack/input.rb#88
  def flush; end

  # source://protocol-rack//lib/protocol/rack/input.rb#92
  def sysread(size, buffer); end
end

# Used for injecting the raw request in the the rack environment.
#
# source://protocol-rack//lib/protocol/rack/constants.rb#9
Protocol::Rack::PROTOCOL_HTTP_REQUEST = T.let(T.unsafe(nil), String)

# Rack environment variables:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#35
Protocol::Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#44
Protocol::Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#37
Protocol::Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# Rack hijack support:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#43
Protocol::Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#36
Protocol::Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#39
Protocol::Rack::RACK_PROTOCOL = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#40
Protocol::Rack::RACK_RESPONSE_FINISHED = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#38
Protocol::Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# A Rack-compatible HTTP request wrapper.
# This class provides a bridge between Rack's environment hash and Protocol::HTTP::Request.
# It handles conversion of Rack environment variables to HTTP request properties.
#
# source://protocol-rack//lib/protocol/rack/request.rb#17
class Protocol::Rack::Request < ::Protocol::HTTP::Request
  # Initialize a new Request instance from a Rack environment.
  #
  # @return [Request] a new instance of Request
  #
  # source://protocol-rack//lib/protocol/rack/request.rb#30
  def initialize(env); end

  class << self
    # Get or create a Request instance for the given Rack environment.
    # The request is cached in the environment to avoid creating multiple instances.
    #
    # source://protocol-rack//lib/protocol/rack/request.rb#23
    def [](env); end

    # Extract HTTP headers from the Rack environment.
    # Converts Rack's `HTTP_*` environment variables to proper HTTP headers.
    #
    # source://protocol-rack//lib/protocol/rack/request.rb#63
    def headers(env); end

    # Extract the protocol list from the Rack environment.
    # Checks both `rack.protocol` and `HTTP_UPGRADE` headers.
    #
    # source://protocol-rack//lib/protocol/rack/request.rb#50
    def protocol(env); end
  end
end

# A wrapper for a `Rack` response.
#
# A Rack response consisting of `[status, headers, body]` includes various rack-specific elements, including:
#
# - A `headers['rack.hijack']` callback which bypasses normal response handling.
# - Potentially invalid content length.
# - Potentially invalid body when processing a `HEAD` request.
# - Newline-separated header values.
# - Other `rack.` specific header key/value pairs.
#
# This wrapper takes those issues into account and adapts the rack response tuple into a {Protocol::HTTP::Response}.
#
# source://protocol-rack//lib/protocol/rack/response.rb#26
class Protocol::Rack::Response < ::Protocol::HTTP::Response
  # Initialize the response wrapper.
  #
  # @return [Response] a new instance of Response
  #
  # source://protocol-rack//lib/protocol/rack/response.rb#71
  def initialize(status, headers, body, protocol = T.unsafe(nil)); end

  class << self
    # Wrap a rack response.
    #
    # source://protocol-rack//lib/protocol/rack/response.rb#42
    def wrap(env, status, headers, meta, body, request = T.unsafe(nil)); end
  end
end

# HTTP hop headers which *should* not be passed through the proxy.
#
# source://protocol-rack//lib/protocol/rack/response.rb#28
Protocol::Rack::Response::HOP_HEADERS = T.let(T.unsafe(nil), Array)

# Content-type driven input buffering, specific to the needs of `rack`.
# This middleware ensures that request bodies for certain content types
# can be read multiple times, which is required by Rack's specification.
#
# source://protocol-rack//lib/protocol/rack/rewindable.rb#14
class Protocol::Rack::Rewindable < ::Protocol::HTTP::Middleware
  # Initialize the rewindable middleware.
  #
  # @return [Rewindable] a new instance of Rewindable
  #
  # source://protocol-rack//lib/protocol/rack/rewindable.rb#31
  def initialize(app); end

  # Wrap the request body in a rewindable buffer if required.
  # If the request needs a rewindable body, wraps it in a {Protocol::HTTP::Body::Rewindable}.
  #
  # source://protocol-rack//lib/protocol/rack/rewindable.rb#70
  def call(request); end

  # Create a Rack environment from the request.
  # Delegates to the wrapped middleware.
  #
  # source://protocol-rack//lib/protocol/rack/rewindable.rb#61
  def make_environment(request); end

  # Determine whether the request needs a rewindable body.
  # A request needs a rewindable body if:
  # - It's a POST request with no content type (legacy behavior)
  # - It has a content type that matches BUFFERED_MEDIA_TYPES
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/rewindable.rb#42
  def needs_rewind?(request); end
end

# Media types that require buffering.
# These types typically contain form data or file uploads that may need
# to be read multiple times by Rack applications.
#
# source://protocol-rack//lib/protocol/rack/rewindable.rb#18
Protocol::Rack::Rewindable::BUFFERED_MEDIA_TYPES = T.let(T.unsafe(nil), Regexp)

# The HTTP POST method.
#
# source://protocol-rack//lib/protocol/rack/rewindable.rb#26
Protocol::Rack::Rewindable::POST = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/version.rb#8
Protocol::Rack::VERSION = T.let(T.unsafe(nil), String)
