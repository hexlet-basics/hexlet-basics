# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.


# source://protocol-http//lib/protocol/http/error.rb#6
module Protocol; end

# source://protocol-http//lib/protocol/http/error.rb#7
module Protocol::HTTP; end

# A middleware that sets the accept-encoding header and decodes the response according to the content-encoding header.
#
# source://protocol-http//lib/protocol/http/accept_encoding.rb#14
class Protocol::HTTP::AcceptEncoding < ::Protocol::HTTP::Middleware
  # Initialize the middleware with the given delegate and wrappers.
  #
  # @return [AcceptEncoding] a new instance of AcceptEncoding
  #
  # source://protocol-http//lib/protocol/http/accept_encoding.rb#34
  def initialize(delegate, wrappers = T.unsafe(nil)); end

  # Set the accept-encoding header and decode the response body.
  #
  # source://protocol-http//lib/protocol/http/accept_encoding.rb#45
  def call(request); end
end

# The header used to request encodings.
#
# source://protocol-http//lib/protocol/http/accept_encoding.rb#16
Protocol::HTTP::AcceptEncoding::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)

# The header used to specify encodings.
#
# source://protocol-http//lib/protocol/http/accept_encoding.rb#19
Protocol::HTTP::AcceptEncoding::CONTENT_ENCODING = T.let(T.unsafe(nil), String)

# The default wrappers to use for decoding content.
#
# source://protocol-http//lib/protocol/http/accept_encoding.rb#22
Protocol::HTTP::AcceptEncoding::DEFAULT_WRAPPERS = T.let(T.unsafe(nil), Hash)

# Represents a bad request error (as opposed to a server error).
# This is used to indicate that the request was malformed or invalid.
#
# source://protocol-http//lib/protocol/http/error.rb#14
module Protocol::HTTP::BadRequest; end

# source://protocol-http//lib/protocol/http/body/readable.rb#9
module Protocol::HTTP::Body; end

# A body which buffers all its contents.
#
# source://protocol-http//lib/protocol/http/body/buffered.rb#14
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # Initialize the buffered body with some chunks.
  #
  # @return [Buffered] a new instance of Buffered
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#51
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # A rewindable body wraps some other body. Convert it to a buffered body. The buffered body will share the same chunks as the rewindable body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#64
  def buffered; end

  # Returns the value of attribute chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#59
  def chunks; end

  # Clear the buffered chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#85
  def clear; end

  # Ensure that future reads return `nil`, but allow for rewinding.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#78
  def close(error = T.unsafe(nil)); end

  # Close the body for writing. This is a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#132
  def close_write(error); end

  # Discard the body. Invokes {#close}.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#121
  def discard; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#97
  def empty?; end

  # Finish the body, this is a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#71
  def finish; end

  # Inspect the buffered body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#155
  def inspect; end

  # The length of the body. Will compute and cache the length of the body, if it was not provided.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#92
  def length; end

  # Read the next chunk from the buffered body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#110
  def read; end

  # Whether the body is ready to be read.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#103
  def ready?; end

  # Rewind the body to the beginning, causing a subsequent read to return the first chunk.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#144
  def rewind; end

  # Whether the body can be rewound.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#139
  def rewindable?; end

  # Write a chunk to the buffered body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#127
  def write(chunk); end

  class << self
    # Read the entire body into a buffered representation.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#37
    def read(body); end

    # Tries to wrap an object in a {Buffered} instance.
    #
    # For compatibility, also accepts anything that behaves like an `Array(String)`.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#21
    def wrap(object); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
#
# source://protocol-http//lib/protocol/http/body/completable.rb#12
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # Initialize the completable body with a callback.
  #
  # @return [Completable] a new instance of Completable
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#29
  def initialize(body, callback); end

  # Convert the body to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#60
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Close the body and invoke the callback. If an error is given, it is passed to the callback.
  #
  # The calback is only invoked once, and before `super` is invoked.
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#48
  def close(error = T.unsafe(nil)); end

  # Inspect the completable body.
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#69
  def inspect; end

  # Rewind the body, is not supported.
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#41
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#36
  def rewindable?; end

  class << self
    # Wrap a message body with a callback. If the body is empty, the callback is invoked immediately.
    #
    # source://protocol-http//lib/protocol/http/body/completable.rb#17
    def wrap(message, &block); end
  end
end

# A body which compresses the contents using the DEFLATE or GZIP algorithm.
#
# source://protocol-http//lib/protocol/http/body/deflate.rb#98
class Protocol::HTTP::Body::Deflate < ::Protocol::HTTP::Body::ZStream
  # Read a chunk from the underlying body and compress it. If the body is finished, the stream is flushed and finished, and the remaining data is returned.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#112
  def read; end

  class << self
    # Create a new body which compresses the given body using the GZIP algorithm by default.
    #
    # source://protocol-http//lib/protocol/http/body/deflate.rb#105
    def for(body, window_size = T.unsafe(nil), level = T.unsafe(nil)); end
  end
end

# Invokes a callback once the body has finished reading.
#
# source://protocol-http//lib/protocol/http/body/digestable.rb#14
class Protocol::HTTP::Body::Digestable < ::Protocol::HTTP::Body::Wrapper
  # Initialize the digestable body with a callback.
  #
  # @return [Digestable] a new instance of Digestable
  #
  # source://protocol-http//lib/protocol/http/body/digestable.rb#31
  def initialize(body, digest = T.unsafe(nil), callback = T.unsafe(nil)); end

  # Convert the body to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/body/digestable.rb#71
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute digest.
  #
  # source://protocol-http//lib/protocol/http/body/digestable.rb#39
  def digest; end

  # Generate an appropriate ETag for the digest, assuming it is complete. If you call this method before the body is fully read, the ETag will be incorrect.
  #
  # source://protocol-http//lib/protocol/http/body/digestable.rb#45
  def etag(weak: T.unsafe(nil)); end

  # Read the body and update the digest. When the body is fully read, the callback is invoked with `self` as the argument.
  #
  # source://protocol-http//lib/protocol/http/body/digestable.rb#56
  def read; end

  class << self
    # Wrap a message body with a callback. If the body is empty, the callback is not invoked, as there is no data to digest.
    #
    # source://protocol-http//lib/protocol/http/body/digestable.rb#20
    def wrap(message, digest = T.unsafe(nil), &block); end
  end
end

# A body which reads from a file.
#
# source://protocol-http//lib/protocol/http/body/file.rb#12
class Protocol::HTTP::Body::File < ::Protocol::HTTP::Body::Readable
  # Initialize the file body with the given file.
  #
  # @return [File] a new instance of File
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#32
  def initialize(file, range = T.unsafe(nil), size: T.unsafe(nil), block_size: T.unsafe(nil)); end

  # Returns a copy of the body, by duplicating the file descriptor, including the same range if specified.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#81
  def buffered; end

  # Close the file.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#52
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#69
  def empty?; end

  # Returns the value of attribute file.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#60
  def file; end

  # Inspect the file body.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#137
  def inspect; end

  # Read all the remaining data from the file and return it as a single string.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#124
  def join; end

  # Returns the value of attribute length.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#66
  def length; end

  # Returns the value of attribute offset.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#63
  def offset; end

  # Read the next chunk of data from the file.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#99
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#74
  def ready?; end

  # Rewind the file to the beginning of the range.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#86
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#92
  def rewindable?; end

  class << self
    # Open a file at the given path.
    #
    # source://protocol-http//lib/protocol/http/body/file.rb#22
    def open(path, *arguments, **options); end
  end
end

# The default block size.
#
# source://protocol-http//lib/protocol/http/body/file.rb#14
Protocol::HTTP::Body::File::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# The default mode for opening files.
#
# source://protocol-http//lib/protocol/http/body/file.rb#17
Protocol::HTTP::Body::File::MODE = T.let(T.unsafe(nil), Integer)

# Represents a body suitable for HEAD requests, in other words, a body that is empty and has a known length.
#
# source://protocol-http//lib/protocol/http/body/head.rb#13
class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # Initialize the head body with the given length.
  #
  # @return [Head] a new instance of Head
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#38
  def initialize(length); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#43
  def empty?; end

  # Inspect the head body.
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#60
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/head.rb#53
  def length; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#48
  def ready?; end

  class << self
    # Create a head body for the given body, capturing its length and then closing it.
    #
    # If a body is provided, the length is determined from the body, and the body is closed.
    # If no body is provided, and the content length is provided, a head body is created with that length.
    # This is useful for creating a head body when you only know the content length but not the actual body, which may happen in adapters for HTTP applications where the application may not provide a body for HEAD requests, but the content length is known.
    #
    # source://protocol-http//lib/protocol/http/body/head.rb#23
    def for(body, length = T.unsafe(nil)); end
  end
end

# A body which decompresses the contents using the DEFLATE or GZIP algorithm.
#
# source://protocol-http//lib/protocol/http/body/inflate.rb#14
class Protocol::HTTP::Body::Inflate < ::Protocol::HTTP::Body::ZStream
  # Read from the underlying stream and inflate it.
  #
  # source://protocol-http//lib/protocol/http/body/inflate.rb#26
  def read; end

  class << self
    # Create a new body which decompresses the given body using the GZIP algorithm by default.
    #
    # source://protocol-http//lib/protocol/http/body/inflate.rb#19
    def for(body, window_size = T.unsafe(nil)); end
  end
end

# Represents a readable input streams.
#
# There are two major modes of operation:
#
# 1. Reading chunks using {read} (or {each}/{join}), until the body is empty, or
# 2. Streaming chunks using {call}, which writes chunks to a provided output stream.
#
# In both cases, reading can fail, for example if the body represents a streaming upload, and the connection is lost. In this case, {read} will raise some kind of error, or the stream will be closed with an error.
#
# At any point, you can use {close} to close the stream and release any resources, or {discard} to read all remaining data without processing it which may allow the underlying connection to be reused (but can be slower).
#
# source://protocol-http//lib/protocol/http/body/readable.rb#20
class Protocol::HTTP::Body::Readable
  # Convert the body to a hash suitable for serialization. This won't include the contents of the body, but will include metadata such as the length, streamability, and readiness, etc.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#173
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Return a buffered representation of this body.
  #
  # This method must return a buffered body if `#rewindable?`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#67
  def buffered; end

  # Invoke the body with the given stream.
  #
  # The default implementation simply writes each chunk to the stream. If the body is not ready, it will be flushed after each chunk. Closes the stream when finished or if an error occurs.
  #
  # Write the body to the given stream.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#138
  def call(stream); end

  # Close the stream immediately. After invoking this method, the stream should be considered closed, and all internal resources should be released.
  #
  # If an error occured while handling the output, it can be passed as an argument. This may be propagated to the client, for example the client may be informed that the stream was not fully read correctly.
  #
  # Invoking {read} after {close} will return `nil`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#28
  def close(error = T.unsafe(nil)); end

  # Discard the body as efficiently as possible.
  #
  # The default implementation simply reads all chunks until the body is empty.
  #
  # Useful for discarding the body when it is not needed, but preserving the underlying connection.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#165
  def discard; end

  # Enumerate all chunks until finished, then invoke {close}.
  #
  # Closes the stream when finished or if an error occurs.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#92
  def each; end

  # Optimistically determine whether read (may) return any data.
  #
  # - If this returns true, then calling read will definitely return nil.
  # - If this returns false, then calling read may return nil.
  #
  # @return [Boolean] Whether the stream is empty.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#37
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#155
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#109
  def join; end

  # The total length of the body, if known.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#74
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#82
  def read; end

  # Whether calling read will return a chunk of data without blocking. We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean] Whether the stream is ready (read will not block).
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#44
  def ready?; end

  # Rewind the stream to the beginning.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#58
  def rewind; end

  # Whether the stream can be rewound using {rewind}.
  #
  # @return [Boolean] Whether the stream is rewindable.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#51
  def rewindable?; end

  # Whether to prefer streaming the body using {call} rather than reading it using {read} or {each}.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#126
  def stream?; end

  # Convert the body to JSON.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#186
  def to_json(*_arg0, **_arg1, &_arg2); end
end

# General operations for interacting with a request or response body.
#
# This module is included in both {Request} and {Response}.
#
# source://protocol-http//lib/protocol/http/body/reader.rb#13
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#98
  def body?; end

  # Buffer the entire request/response body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#61
  def buffered!; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#88
  def close(error = T.unsafe(nil)); end

  # Discard the body as efficiently as possible.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#49
  def discard; end

  # Read chunks from the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#17
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#39
  def finish; end

  # Reads the entire request/response body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#27
  def read; end

  # Write the body of the response to the given file path.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#75
  def save(path, mode = T.unsafe(nil), **options); end
end

# A body which buffers all its contents as it is read.
#
# As the body is buffered in memory, you may want to ensure your server has sufficient (virtual) memory available to buffer the entire body.
#
# source://protocol-http//lib/protocol/http/body/rewindable.rb#16
class Protocol::HTTP::Body::Rewindable < ::Protocol::HTTP::Body::Wrapper
  # Initialize the body with the given body.
  #
  # @return [Rewindable] a new instance of Rewindable
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#33
  def initialize(body); end

  # Convert the body to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#88
  def as_json(*_arg0, **_arg1, &_arg2); end

  # A rewindable body wraps some other body. Convert it to a buffered body. The buffered body will share the same chunks as the rewindable body.
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#53
  def buffered; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#41
  def empty?; end

  # Inspect the rewindable body.
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#98
  def inspect; end

  # Read the next available chunk. This may return a buffered chunk if the stream has been rewound, or a chunk from the underlying stream, if available.
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#60
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#46
  def ready?; end

  # Rewind the stream to the beginning.
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#76
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#81
  def rewindable?; end

  class << self
    # Wrap the given message body in a rewindable body, if it is not already rewindable.
    #
    # source://protocol-http//lib/protocol/http/body/rewindable.rb#20
    def wrap(message); end
  end
end

# The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be "ASCII-8BIT" and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#14
class Protocol::HTTP::Body::Stream
  include ::Protocol::HTTP::Body::Stream::Reader

  # Initialize the stream with the given input and output.
  #
  # @raise [ArgumentError]
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#22
  def initialize(input = T.unsafe(nil), output = T.unsafe(nil)); end

  # Write data to the stream using {write}.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#319
  def <<(buffer); end

  # Close the input and output bodies.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#376
  def close(error = T.unsafe(nil)); end

  # Close the input body.
  #
  # If, while processing the data that was read from this stream, an error is encountered, it should be passed to this method.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#350
  def close_read(error = T.unsafe(nil)); end

  # Close the output body.
  #
  # If, while generating the data that is written to this stream, an error is encountered, it should be passed to this method.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#365
  def close_write(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#386
  def closed?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#406
  def empty?; end

  # Flush the output stream.
  #
  # This is currently a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#342
  def flush; end

  # Returns the value of attribute input.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#36
  def input; end

  # Inspect the stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#393
  def inspect; end

  # Returns the value of attribute output.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#39
  def output; end

  # Write lines to the stream.
  #
  # The current implementation buffers the lines and writes them in a single operation.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#329
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Write data to the underlying stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#298
  def write(buffer); end

  # Write data to the stream using {write}.
  #
  # Provided for compatibility with IO-like objects.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#314
  def write_nonblock(buffer, exception: T.unsafe(nil)); end

  private

  # Read the next chunk of data from the input stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#416
  def read_next; end
end

# The default line separator, used by {gets}.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#16
Protocol::HTTP::Body::Stream::NEWLINE = T.let(T.unsafe(nil), String)

# This provides a read-only interface for data, which is surprisingly tricky to implement correctly.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#42
module Protocol::HTTP::Body::Stream::Reader
  # Iterate over each chunk of data from the input stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#147
  def each(&block); end

  # Read a single line from the stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#227
  def gets(separator = T.unsafe(nil), limit = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Read data from the underlying stream.
  #
  # If given a non-negative length, it will read at most that many bytes from the stream. If the stream is at EOF, it will return nil.
  #
  # If the length is not given, it will read all data until EOF, or return an empty string if the stream is already at EOF.
  #
  # If buffer is given, then the read data will be placed into buffer instead of a newly created String object.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#54
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read data from the stream without blocking if possible.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#164
  def read_nonblock(length, buffer = T.unsafe(nil), exception: T.unsafe(nil)); end

  # Read some bytes from the stream.
  #
  # If the length is given, at most length bytes will be read. Otherwise, one chunk of data from the underlying stream will be read.
  #
  # Will avoid reading from the underlying stream if there is buffered data available.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#102
  def read_partial(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read data from the stream until encountering pattern.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#196
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Similar to {read_partial} but raises an `EOFError` if the stream is at EOF.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#140
  def readpartial(length, buffer = T.unsafe(nil)); end
end

# A body that invokes a block that can read and write to a stream.
#
# In some cases, it's advantageous to directly read and write to the underlying stream if possible. For example, HTTP/1 upgrade requests, WebSockets, and similar. To handle that case, response bodies can implement {stream?} and return `true`. When {stream?} returns true, the body **should** be consumed by calling `call(stream)`. Server implementations may choose to always invoke `call(stream)` if it's efficient to do so. Bodies that don't support it will fall back to using {each}.
#
# When invoking `call(stream)`, the stream can be read from and written to, and closed. However, the stream is only guaranteed to be open for the duration of the `call(stream)` call. Once the method returns, the stream **should** be closed by the server.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#19
module Protocol::HTTP::Body::Streamable
  class << self
    # Generate a new streaming request body using the given block to generate the body.
    #
    # source://protocol-http//lib/protocol/http/body/streamable.rb#24
    def request(&block); end

    # Generate a new streaming response body using the given block to generate the body.
    #
    # source://protocol-http//lib/protocol/http/body/streamable.rb#33
    def response(request, &block); end
  end
end

# A streaming body that can be read from and written to.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#85
class Protocol::HTTP::Body::Streamable::Body < ::Protocol::HTTP::Body::Readable
  # Initialize the body with the given block and input.
  #
  # @return [Body] a new instance of Body
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#90
  def initialize(block, input = T.unsafe(nil)); end

  # Invoke the block with the given stream. The block can read and write to the stream, and must close the stream when finishing.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#119
  def call(stream); end

  # Close the input. The streaming body will eventually read all the input.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#139
  def close_input(error = T.unsafe(nil)); end

  # Close the output, the streaming body will be unable to write any more output.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#149
  def close_output(error = T.unsafe(nil)); end

  # Inspect the streaming body.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#159
  def inspect; end

  # Invokes the block in a fiber which yields chunks when they are available.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#102
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#97
  def stream?; end
end

# Raised when a streaming body is consumed more than once.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#81
class Protocol::HTTP::Body::Streamable::ConsumedError < ::StandardError; end

# A output stream that can be written to by a block.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#38
class Protocol::HTTP::Body::Streamable::Output
  # Initialize the output stream with the given input and block.
  #
  # @return [Output] a new instance of Output
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#52
  def initialize(input, block); end

  # Close the output stream.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#75
  def close(error = T.unsafe(nil)); end

  # Read from the output stream (may block).
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#68
  def read; end

  # Schedule the block to be executed in a fiber.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#61
  def schedule; end

  class << self
    # Schedule the block to be executed in a fiber.
    #
    # source://protocol-http//lib/protocol/http/body/streamable.rb#44
    def schedule(input, block); end
  end
end

# A request body is used on the client side to generate the request body using a block.
#
# As the response body isn't available until the request is sent, the response body must be {stream}ed into the request body.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#181
class Protocol::HTTP::Body::Streamable::RequestBody < ::Protocol::HTTP::Body::Streamable::Body
  # Initialize the request body with the given block.
  #
  # @return [RequestBody] a new instance of RequestBody
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#185
  def initialize(block); end

  # Close will be invoked when all the input is read.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#190
  def close(error = T.unsafe(nil)); end

  # Stream the response body into the block's input.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#195
  def stream(body); end
end

# A response body is used on the server side to generate the response body using a block.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#171
class Protocol::HTTP::Body::Streamable::ResponseBody < ::Protocol::HTTP::Body::Streamable::Body
  # Close will be invoked when all the output is written.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#173
  def close(error = T.unsafe(nil)); end
end

# Wrapping body instance. Typically you'd override `#read`.
#
# source://protocol-http//lib/protocol/http/body/wrapper.rb#12
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # Initialize the wrapper with the given body.
  #
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#26
  def initialize(body); end

  # Convert the body to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#86
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#31
  def body; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#54
  def buffered; end

  # Close the body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#36
  def close(error = T.unsafe(nil)); end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#79
  def discard; end

  # Forwards to the wrapped body.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#44
  def empty?; end

  # Inspect the wrapped body. The wrapper, by default, is transparent.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#103
  def inspect; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#69
  def length; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#74
  def read; end

  # Forwards to the wrapped body.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#49
  def ready?; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#59
  def rewind; end

  # Forwards to the wrapped body.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#64
  def rewindable?; end

  # Convert the body to JSON.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#96
  def to_json(*_arg0, **_arg1, &_arg2); end

  class << self
    # Wrap the body of the given message in a new instance of this class.
    #
    # source://protocol-http//lib/protocol/http/body/wrapper.rb#17
    def wrap(message); end
  end
end

# A dynamic body which you can write to and read from.
#
# source://protocol-http//lib/protocol/http/body/writable.rb#12
class Protocol::HTTP::Body::Writable < ::Protocol::HTTP::Body::Readable
  # Initialize the writable body.
  #
  # @return [Writable] a new instance of Writable
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#21
  def initialize(length = T.unsafe(nil), queue: T.unsafe(nil)); end

  # Stop generating output; cause the next call to write to fail with the given error. Does not prevent existing chunks from being read. In other words, this indicates both that no more data will be or should be written to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#34
  def close(error = T.unsafe(nil)); end

  # Signal that no more data will be written to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#98
  def close_write(error = T.unsafe(nil)); end

  # Whether the body is closed. A closed body can not be written to or read from.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#46
  def closed?; end

  # Indicates whether the body is empty. This can occur if the body has been closed, or if the producer has invoked {close_write} and the reader has consumed all available chunks.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#58
  def empty?; end

  # Inspect the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#167
  def inspect; end

  # Returns the value of attribute length.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#29
  def length; end

  # Create an output wrapper which can be used to write chunks to the body.
  #
  # If a block is given, and the block raises an error, the error will used to close the body by invoking {close} with the error.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#148
  def output; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#66
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#51
  def ready?; end

  # Write a single chunk to the body. Signal completion by calling {close_write}.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#86
  def write(chunk); end

  private

  # source://protocol-http//lib/protocol/http/body/writable.rb#178
  def status; end
end

# An error indicating that the body has been closed and no further writes are allowed.
#
# source://protocol-http//lib/protocol/http/body/writable.rb#14
class Protocol::HTTP::Body::Writable::Closed < ::StandardError; end

# The output interface for writing chunks to the body.
#
# source://protocol-http//lib/protocol/http/body/writable.rb#104
class Protocol::HTTP::Body::Writable::Output
  # Initialize the output with the given writable body.
  #
  # @return [Output] a new instance of Output
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#108
  def initialize(writable); end

  # Write a chunk to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#123
  def <<(chunk); end

  # Close the output stream.
  #
  # If an error is given, the error will be used to close the body by invoking {close} with the error. Otherwise, only the write side of the body will be closed.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#130
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#114
  def closed?; end

  # Write a chunk to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#119
  def write(chunk); end
end

# A body which compresses or decompresses the contents using the DEFLATE or GZIP algorithm.
#
# source://protocol-http//lib/protocol/http/body/deflate.rb#14
class Protocol::HTTP::Body::ZStream < ::Protocol::HTTP::Body::Wrapper
  # Initialize the body with the given stream.
  #
  # @return [ZStream] a new instance of ZStream
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#34
  def initialize(body, stream); end

  # Convert the body to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#81
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Close the stream.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#46
  def close(error = T.unsafe(nil)); end

  # Returns the value of attribute input_length.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#62
  def input_length; end

  # Inspect the body, including the compression ratio.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#92
  def inspect; end

  # The length of the output, if known. Generally, this is not known due to the nature of compression.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#56
  def length; end

  # Returns the value of attribute output_length.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#65
  def output_length; end

  # The compression ratio, according to the input and output lengths.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#70
  def ratio; end
end

# The default compression level.
#
# source://protocol-http//lib/protocol/http/body/deflate.rb#16
Protocol::HTTP::Body::ZStream::DEFAULT_LEVEL = T.let(T.unsafe(nil), Integer)

# The DEFLATE window size.
#
# source://protocol-http//lib/protocol/http/body/deflate.rb#19
Protocol::HTTP::Body::ZStream::DEFLATE = T.let(T.unsafe(nil), Integer)

# The supported encodings.
#
# source://protocol-http//lib/protocol/http/body/deflate.rb#25
Protocol::HTTP::Body::ZStream::ENCODINGS = T.let(T.unsafe(nil), Hash)

# The GZIP window size.
#
# source://protocol-http//lib/protocol/http/body/deflate.rb#22
Protocol::HTTP::Body::ZStream::GZIP = T.let(T.unsafe(nil), Integer)

# Encode a response according the the request's acceptable encodings.
#
# source://protocol-http//lib/protocol/http/content_encoding.rb#14
class Protocol::HTTP::ContentEncoding < ::Protocol::HTTP::Middleware
  # Initialize the content encoding middleware.
  #
  # @return [ContentEncoding] a new instance of ContentEncoding
  #
  # source://protocol-http//lib/protocol/http/content_encoding.rb#28
  def initialize(delegate, content_types = T.unsafe(nil), wrappers = T.unsafe(nil)); end

  # Encode the response body according to the request's acceptable encodings.
  #
  # source://protocol-http//lib/protocol/http/content_encoding.rb#39
  def call(request); end
end

# The default content types to apply encoding to.
#
# source://protocol-http//lib/protocol/http/content_encoding.rb#21
Protocol::HTTP::ContentEncoding::DEFAULT_CONTENT_TYPES = T.let(T.unsafe(nil), Regexp)

# The default wrappers to use for encoding content.
#
# source://protocol-http//lib/protocol/http/content_encoding.rb#16
Protocol::HTTP::ContentEncoding::DEFAULT_WRAPPERS = T.let(T.unsafe(nil), Hash)

# Represents an individual cookie key-value pair.
#
# source://protocol-http//lib/protocol/http/cookie.rb#12
class Protocol::HTTP::Cookie
  # Initialize the cookie with the given name, value, and directives.
  #
  # @return [Cookie] a new instance of Cookie
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#29
  def initialize(name, value, directives = T.unsafe(nil)); end

  # Returns the value of attribute directives.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#50
  def directives; end

  # Sets the attribute directives
  #
  # @param value the value to set the attribute directives to.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#50
  def directives=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#44
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#44
  def name=(_arg0); end

  # Convert the cookie to a string.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#55
  def to_s; end

  # Returns the value of attribute value.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#47
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#47
  def value=(_arg0); end

  class << self
    # Parse a string into a cookie.
    #
    # source://protocol-http//lib/protocol/http/cookie.rb#78
    def parse(string); end

    # Parse a list of strings into a hash of directives.
    #
    # source://protocol-http//lib/protocol/http/cookie.rb#91
    def parse_directives(strings); end
  end
end

# Valid cookie name characters according to RFC 6265.
# cookie-name = token (RFC 2616 defines token)
#
# source://protocol-http//lib/protocol/http/cookie.rb#15
Protocol::HTTP::Cookie::VALID_COOKIE_KEY = T.let(T.unsafe(nil), Regexp)

# Valid cookie value characters according to RFC 6265.
# cookie-value = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
# cookie-octet = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
# Excludes control chars, whitespace, DQUOTE, comma, semicolon, and backslash
#
# source://protocol-http//lib/protocol/http/cookie.rb#21
Protocol::HTTP::Cookie::VALID_COOKIE_VALUE = T.let(T.unsafe(nil), Regexp)

# Raised when a singleton (e.g. `content-length`) header is duplicated in a request or response.
#
# source://protocol-http//lib/protocol/http/error.rb#18
class Protocol::HTTP::DuplicateHeaderError < ::Protocol::HTTP::Error
  include ::Protocol::HTTP::BadRequest

  # @return [DuplicateHeaderError] a new instance of DuplicateHeaderError
  #
  # source://protocol-http//lib/protocol/http/error.rb#22
  def initialize(key, existing_value, new_value); end

  # Provides a detailed error message including the existing and new values.
  #
  # @return [String] The detailed error message.
  #
  # source://protocol-http//lib/protocol/http/error.rb#42
  def detailed_message(highlight: T.unsafe(nil)); end

  # Returns the value of attribute existing_value.
  #
  # source://protocol-http//lib/protocol/http/error.rb#34
  def existing_value; end

  # Returns the value of attribute key.
  #
  # source://protocol-http//lib/protocol/http/error.rb#31
  def key; end

  # Returns the value of attribute new_value.
  #
  # source://protocol-http//lib/protocol/http/error.rb#37
  def new_value; end
end

# A generic, HTTP protocol error.
#
# source://protocol-http//lib/protocol/http/error.rb#9
class Protocol::HTTP::Error < ::StandardError; end

# source://protocol-http//lib/protocol/http/header/split.rb#8
module Protocol::HTTP::Header; end

# The `accept-content-type` header represents a list of content-types that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept.rb#15
class Protocol::HTTP::Header::Accept < ::Protocol::HTTP::Header::Split
  # Adds one or more comma-separated values to the header.
  #
  # The input string is split into distinct entries and appended to the array.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#84
  def <<(value); end

  # Parse the `accept` header.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#104
  def media_ranges; end

  # Converts the parsed header value into a raw header value.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#91
  def to_s; end

  private

  # source://protocol-http//lib/protocol/http/header/accept.rb#112
  def parse_media_range(value); end

  class << self
    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/accept.rb#75
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/accept.rb#97
    def trailer?; end
  end
end

# source://protocol-http//lib/protocol/http/header/accept.rb#28
Protocol::HTTP::Header::Accept::MEDIA_RANGE = T.let(T.unsafe(nil), Regexp)

# A single entry in the Accept: header, which includes a mime type and associated parameters. A media range can include wild cards, but a media type is a specific type and subtype.
#
# source://protocol-http//lib/protocol/http/header/accept.rb#33
class Protocol::HTTP::Header::Accept::MediaRange < ::Struct
  # Create a new media range.
  #
  # @return [MediaRange] a new instance of MediaRange
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#39
  def initialize(type, subtype = T.unsafe(nil), parameters = T.unsafe(nil)); end

  # Compare the media range with another media range or a string, based on the quality factor.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#44
  def <=>(other); end

  # Returns the value of attribute parameters
  #
  # @return [Object] the current value of parameters
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#33
  def parameters; end

  # Sets the attribute parameters
  #
  # @param value [Object] the value to set the attribute parameters to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#33
  def parameters=(_); end

  # The quality factor associated with the media range, which is used to determine the order of preference.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#66
  def quality_factor; end

  # Returns the value of attribute subtype
  #
  # @return [Object] the current value of subtype
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#33
  def subtype; end

  # Sets the attribute subtype
  #
  # @param value [Object] the value to set the attribute subtype to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#33
  def subtype=(_); end

  # The string representation of the media range, including the type, subtype, and any parameters.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#57
  def to_s; end

  # The string representation of the media range, including the type, subtype, and any parameters.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#61
  def to_str; end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#33
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#33
  def type=(_); end

  private

  # source://protocol-http//lib/protocol/http/header/accept.rb#48
  def parameters_string; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept.rb#33
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept.rb#33
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept.rb#33
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept.rb#33
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept.rb#33
    def new(*_arg0); end
  end
end

# source://protocol-http//lib/protocol/http/header/accept.rb#30
Protocol::HTTP::Header::Accept::PARAMETER = T.let(T.unsafe(nil), Regexp)

class Protocol::HTTP::Header::Accept::ParseError < ::Protocol::HTTP::Error; end

# Regular expression used to split values on commas, with optional surrounding whitespace, taking into account quoted strings.
#
# source://protocol-http//lib/protocol/http/header/accept.rb#17
Protocol::HTTP::Header::Accept::SEPARATOR = T.let(T.unsafe(nil), Regexp)

# The `accept-charset` header represents a list of character sets that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept_charset.rb#14
class Protocol::HTTP::Header::AcceptCharset < ::Protocol::HTTP::Header::Split
  # Parse the `accept-charset` header value into a list of character sets.
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#33
  def charsets; end
end

# https://tools.ietf.org/html/rfc7231#section-5.3.3
#
# source://protocol-http//lib/protocol/http/header/accept_charset.rb#18
Protocol::HTTP::Header::AcceptCharset::CHARSET = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
class Protocol::HTTP::Header::AcceptCharset::Charset < ::Struct
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#25
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def name=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def q=(_); end

  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#21
  def quality_factor; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def new(*_arg0); end
  end
end

class Protocol::HTTP::Header::AcceptCharset::ParseError < ::Protocol::HTTP::Error; end

# The `accept-encoding` header represents a list of encodings that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#14
class Protocol::HTTP::Header::AcceptEncoding < ::Protocol::HTTP::Header::Split
  # Parse the `accept-encoding` header value into a list of encodings.
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#36
  def encodings; end
end

# https://tools.ietf.org/html/rfc7231#section-5.3.4
#
# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#21
Protocol::HTTP::Header::AcceptEncoding::ENCODING = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
class Protocol::HTTP::Header::AcceptEncoding::Encoding < ::Struct
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#28
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def name=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def q=(_); end

  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#24
  def quality_factor; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def new(*_arg0); end
  end
end

class Protocol::HTTP::Header::AcceptEncoding::ParseError < ::Protocol::HTTP::Error; end

# https://tools.ietf.org/html/rfc7231#section-5.3.1
#
# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#18
Protocol::HTTP::Header::AcceptEncoding::QVALUE = T.let(T.unsafe(nil), Regexp)

# The `accept-language` header represents a list of languages that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#14
class Protocol::HTTP::Header::AcceptLanguage < ::Protocol::HTTP::Header::Split
  # Parse the `accept-language` header value into a list of languages.
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#39
  def languages; end
end

# https://greenbytes.de/tech/webdav/rfc7231.html#quality.values
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#24
Protocol::HTTP::Header::AcceptLanguage::LANGUAGE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept_language.rb#26
class Protocol::HTTP::Header::AcceptLanguage::Language < ::Struct
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#31
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def name=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def q=(_); end

  # source://protocol-http//lib/protocol/http/header/accept_language.rb#27
  def quality_factor; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def new(*_arg0); end
  end
end

# https://tools.ietf.org/html/rfc3066#section-2.1
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#18
Protocol::HTTP::Header::AcceptLanguage::NAME = T.let(T.unsafe(nil), Regexp)

class Protocol::HTTP::Header::AcceptLanguage::ParseError < ::Protocol::HTTP::Error; end

# https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#21
Protocol::HTTP::Header::AcceptLanguage::QVALUE = T.let(T.unsafe(nil), Regexp)

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
#
# TODO Support other authorization mechanisms, e.g. bearer token.
#
# source://protocol-http//lib/protocol/http/header/authorization.rb#17
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header into the credentials.
  #
  # source://protocol-http//lib/protocol/http/header/authorization.rb#37
  def credentials; end

  class << self
    # Generate a new basic authorization header, encoding the given username and password.
    #
    # source://protocol-http//lib/protocol/http/header/authorization.rb#46
    def basic(username, password); end

    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/authorization.rb#30
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/authorization.rb#22
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/authorization.rb#56
    def trailer?; end
  end
end

# Represents the `cache-control` header, which is a list of cache directives.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#13
class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # Adds a directive to the `cache-control` header. The value will be normalized to lowercase before being added.
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#71
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#81
  def dynamic?; end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#121
  def max_age; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#111
  def must_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#101
  def no_cache?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#106
  def no_store?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#91
  def private?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#116
  def proxy_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#96
  def public?; end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#126
  def s_maxage; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#76
  def static?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#86
  def streaming?; end

  private

  # Finds and parses an integer value from a directive.
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#136
  def find_integer_value(value_name); end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/cache_control.rb#59
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/cache_control.rb#51
    def parse(value); end
  end
end

# The `dynamic` directive is a custom directive used to indicate that the resource is generated dynamically and may change frequently, requiring shorter caching periods.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#36
Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

# The `max-age` directive indicates the maximum amount of time, in seconds, that a response is considered fresh.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#27
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

# The `must-revalidate` directive indicates that once a response becomes stale, caches must not use it to satisfy subsequent requests without revalidating it with the origin server.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#42
Protocol::HTTP::Header::CacheControl::MUST_REVALIDATE = T.let(T.unsafe(nil), String)

# The `no-cache` directive indicates that caches must revalidate the response with the origin server before serving it to clients.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#21
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

# The `no-store` directive indicates that caches must not store the response under any circumstances.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#24
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

# The `private` directive indicates that the response is intended for a single user and must not be stored by shared caches.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#15
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

# The `proxy-revalidate` directive is similar to `must-revalidate` but applies only to shared caches.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#45
Protocol::HTTP::Header::CacheControl::PROXY_REVALIDATE = T.let(T.unsafe(nil), String)

# The `public` directive indicates that the response may be stored by any cache, even if it would normally be considered non-cacheable.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#18
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

# The `static` directive is a custom directive often used to indicate that the resource is immutable or rarely changes, allowing longer caching periods.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#33
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

# The `streaming` directive is a custom directive used to indicate that the resource is intended for progressive or chunked delivery, such as live video streams.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#39
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

# The `s-maxage` directive is similar to `max-age` but applies only to shared caches. If both `s-maxage` and `max-age` are present, `s-maxage` takes precedence in shared caches.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#30
Protocol::HTTP::Header::CacheControl::S_MAXAGE = T.let(T.unsafe(nil), String)

# Represents the `connection` HTTP header, which controls options for the current connection.
#
# The `connection` header is used to specify control options such as whether the connection should be kept alive, closed, or upgraded to a different protocol.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#15
class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # Adds a directive to the `connection` header. The value will be normalized to lowercase before being added.
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#49
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#59
  def close?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#54
  def keep_alive?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#64
  def upgrade?; end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/connection.rb#37
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/connection.rb#29
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    # Connection headers control the current connection and must not appear in trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/connection.rb#71
    def trailer?; end
  end
end

# The `close` directive indicates that the connection should be closed after the current request and response are complete.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#20
Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

# The `keep-alive` directive indicates that the connection should remain open for future requests or responses, avoiding the overhead of opening a new connection.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#17
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# The `upgrade` directive indicates that the connection should be upgraded to a different protocol, as specified in the `Upgrade` header.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#23
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The `cookie` header contains stored HTTP cookies previously sent by the server with the `set-cookie` header.
#
# It is used by clients to send key-value pairs representing stored cookies back to the server.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#15
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  # Parses the `cookie` header into a hash of cookie names and their corresponding cookie objects.
  #
  # source://protocol-http//lib/protocol/http/header/cookie.rb#19
  def to_h; end

  # Serializes the `cookie` header by joining individual cookie strings with semicolons.
  #
  # source://protocol-http//lib/protocol/http/header/cookie.rb#28
  def to_s; end

  class << self
    # Whether this header is acceptable in HTTP trailers.
    # Cookie headers should not appear in trailers as they contain state information needed early in processing.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/cookie.rb#35
    def trailer?; end
  end
end

# The `date` header represents the date and time at which the message was originated.
#
# This header is typically included in HTTP responses and follows the format defined in RFC 9110.
#
# source://protocol-http//lib/protocol/http/header/date.rb#14
class Protocol::HTTP::Header::Date < ::String
  # Replaces the current value of the `date` header.
  #
  # source://protocol-http//lib/protocol/http/header/date.rb#34
  def <<(value); end

  # Converts the `date` header value to a `Time` object.
  #
  # source://protocol-http//lib/protocol/http/header/date.rb#41
  def to_time; end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/date.rb#27
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/date.rb#19
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    # Date headers can safely appear in trailers as they provide metadata about response generation.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/date.rb#48
    def trailer?; end
  end
end

# The `digest` header provides a digest of the message body for integrity verification.
#
# This header allows servers to send cryptographic hashes of the response body, enabling clients to verify data integrity. Multiple digest algorithms can be specified, and the header is particularly useful as a trailer since the digest can only be computed after the entire message body is available.
#
# ## Examples
#
# ```ruby
# digest = Digest.new("sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=")
# digest << "md5=9bb58f26192e4ba00f01e2e7b136bbd8"
# puts digest.to_s
# # => "sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=, md5=9bb58f26192e4ba00f01e2e7b136bbd8"
# ```
#
# source://protocol-http//lib/protocol/http/header/digest.rb#25
class Protocol::HTTP::Header::Digest < ::Protocol::HTTP::Header::Split
  # Parse the `digest` header value into a list of digest entries.
  #
  # source://protocol-http//lib/protocol/http/header/digest.rb#52
  def entries; end

  class << self
    # Whether this header is acceptable in HTTP trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/digest.rb#64
    def trailer?; end
  end
end

# https://tools.ietf.org/html/rfc3230#section-4.3.2
#
# source://protocol-http//lib/protocol/http/header/digest.rb#29
Protocol::HTTP::Header::Digest::ENTRY = T.let(T.unsafe(nil), Regexp)

# A single digest entry in the Digest header.
#
# source://protocol-http//lib/protocol/http/header/digest.rb#32
class Protocol::HTTP::Header::Digest::Entry < ::Struct
  # Create a new digest entry.
  #
  # @return [Entry] a new instance of Entry
  #
  # source://protocol-http//lib/protocol/http/header/digest.rb#37
  def initialize(algorithm, value); end

  # Returns the value of attribute algorithm
  #
  # @return [Object] the current value of algorithm
  #
  # source://protocol-http//lib/protocol/http/header/digest.rb#32
  def algorithm; end

  # Sets the attribute algorithm
  #
  # @param value [Object] the value to set the attribute algorithm to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/digest.rb#32
  def algorithm=(_); end

  # Convert the entry to its string representation.
  #
  # source://protocol-http//lib/protocol/http/header/digest.rb#44
  def to_s; end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  #
  # source://protocol-http//lib/protocol/http/header/digest.rb#32
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/digest.rb#32
  def value=(_); end

  class << self
    # source://protocol-http//lib/protocol/http/header/digest.rb#32
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/digest.rb#32
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/digest.rb#32
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/digest.rb#32
    def members; end

    # source://protocol-http//lib/protocol/http/header/digest.rb#32
    def new(*_arg0); end
  end
end

class Protocol::HTTP::Header::Digest::ParseError < ::Protocol::HTTP::Error; end

# The `etag` header represents the entity tag for a resource.
#
# The `etag` header provides a unique identifier for a specific version of a resource, typically used for cache validation or conditional requests. It can be either a strong or weak validator as defined in RFC 9110.
#
# source://protocol-http//lib/protocol/http/header/etag.rb#12
class Protocol::HTTP::Header::ETag < ::String
  # Replaces the current value of the `etag` header.
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#32
  def <<(value); end

  # Checks whether the `etag` is a weak validator.
  #
  # Weak validators indicate semantically equivalent content but may not be byte-for-byte identical.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#41
  def weak?; end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/etag.rb#25
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/etag.rb#17
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    # ETag headers can safely appear in trailers as they provide cache validation metadata.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/etag.rb#48
    def trailer?; end
  end
end

# The `etags` header represents a list of entity tags (ETags) for resources.
#
# The `etags` header is used for conditional requests to compare the current version of a resource with previously stored versions. It supports both strong and weak validators, as well as the wildcard character (`*`) to indicate a match for any resource.
#
# source://protocol-http//lib/protocol/http/header/etags.rb#15
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # Checks if the specified ETag matches the `etags` header.
  #
  # This method returns `true` if the wildcard is present or if the exact ETag is found in the list. Note that this implementation is not strictly compliant with the RFC-specified format.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#31
  def match?(etag); end

  # Checks for a strong match with the specified ETag, useful with the `if-match` header.
  #
  # A strong match requires that the ETag in the header list matches the specified ETag and that neither is a weak validator.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#41
  def strong_match?(etag); end

  # Checks for a weak match with the specified ETag, useful with the `if-none-match` header.
  #
  # A weak match allows for semantically equivalent content, including weak validators and their strong counterparts.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#51
  def weak_match?(etag); end

  # Checks if the `etags` header contains the wildcard (`*`) character.
  #
  # The wildcard character matches any resource version, regardless of its actual value.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#21
  def wildcard?; end

  private

  # Converts a weak tag to its strong counterpart or vice versa.
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#61
  def opposite_tag(etag); end

  # Checks if the given ETag is a weak validator.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#69
  def weak_tag?(tag); end
end

# Represents generic or custom headers that can be used in trailers.
#
# This class is used as the default policy for headers not explicitly defined in the POLICY hash.
#
# It allows generic headers to be used in HTTP trailers, which is important for:
# - Custom application headers.
# - gRPC status headers (grpc-status, grpc-message).
# - Headers used by proxies and middleware.
# - Future HTTP extensions.
#
# source://protocol-http//lib/protocol/http/header/generic.rb#20
class Protocol::HTTP::Header::Generic < ::Protocol::HTTP::Header::Split
  class << self
    # Whether this header is acceptable in HTTP trailers.
    # Generic headers are allowed in trailers by default to support extensibility.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/generic.rb#24
    def trailer?; end
  end
end

# Represents headers that can contain multiple distinct values separated by newline characters.
#
# This isn't a specific header but is used as a base for headers that store multiple values, such as cookies. The values are split and stored as an array internally, and serialized back to a newline-separated string when needed.
#
# source://protocol-http//lib/protocol/http/header/multiple.rb#12
class Protocol::HTTP::Header::Multiple < ::Array
  # Initializes the multiple header with the given values.
  #
  # @return [Multiple] a new instance of Multiple
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#41
  def initialize(value = T.unsafe(nil)); end

  # Converts the parsed header value into a raw header value.
  #
  # Multiple headers are transmitted as separate header entries, so this serializes to a newline-separated string for storage.
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#54
  def to_s; end

  class << self
    # Coerces a value into a parsed header object.
    #
    # This method is used by the Headers class when setting values via `[]=` to convert application values into the appropriate policy type.
    #
    # source://protocol-http//lib/protocol/http/header/multiple.rb#29
    def coerce(value); end

    # Parses a raw header value.
    #
    # Multiple headers receive each value as a separate header entry, so this method takes a single string value and creates a new instance containing it.
    #
    # source://protocol-http//lib/protocol/http/header/multiple.rb#19
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    # This is a base class for headers with multiple values, default is to disallow in trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/multiple.rb#61
    def trailer?; end
  end
end

# Represents the `priority` header, used to indicate the relative importance of an HTTP request.
#
# The `priority` header allows clients to express their preference for how resources should be prioritized by the server. It supports directives like `u=` to specify the urgency level of a request, and `i` to indicate whether a response can be delivered incrementally. The urgency levels range from 0 (highest priority) to 7 (lowest priority), while the `i` directive is a boolean flag.
#
# source://protocol-http//lib/protocol/http/header/priority.rb#14
class Protocol::HTTP::Header::Priority < ::Protocol::HTTP::Header::Split
  # Add a value to the priority header.
  #
  # source://protocol-http//lib/protocol/http/header/priority.rb#39
  def <<(value); end

  # Checks if the response should be delivered incrementally.
  #
  # The `i` directive, when present, indicates that the response can be delivered incrementally as data becomes available.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/priority.rb#65
  def incremental?; end

  # The urgency level, if specified using `u=`. 0 is the highest priority, and 7 is the lowest.
  #
  # Note that when duplicate Dictionary keys are encountered, all but the last instance are ignored.
  #
  # source://protocol-http//lib/protocol/http/header/priority.rb#51
  def urgency(default = T.unsafe(nil)); end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/priority.rb#27
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/priority.rb#19
    def parse(value); end
  end
end

# The default urgency level if not specified.
#
# source://protocol-http//lib/protocol/http/header/priority.rb#44
Protocol::HTTP::Header::Priority::DEFAULT_URGENCY = T.let(T.unsafe(nil), Integer)

# The `server-timing` header communicates performance metrics about the request-response cycle to the client.
#
# This header allows servers to send timing information about various server-side operations, which can be useful for performance monitoring and debugging. Each metric can include a name, optional duration, and optional description.
#
# ## Examples
#
# ```ruby
# server_timing = ServerTiming.new("db;dur=53.2")
# server_timing << "cache;dur=12.1;desc=\"Redis lookup\""
# puts server_timing.to_s
# # => "db;dur=53.2, cache;dur=12.1;desc=\"Redis lookup\""
# ```
#
# source://protocol-http//lib/protocol/http/header/server_timing.rb#25
class Protocol::HTTP::Header::ServerTiming < ::Protocol::HTTP::Header::Split
  # Parse the `server-timing` header value into a list of metrics.
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#57
  def metrics; end

  class << self
    # Whether this header is acceptable in HTTP trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/server_timing.rb#86
    def trailer?; end
  end
end

# https://www.w3.org/TR/server-timing/
#
# source://protocol-http//lib/protocol/http/header/server_timing.rb#29
Protocol::HTTP::Header::ServerTiming::METRIC = T.let(T.unsafe(nil), Regexp)

# A single metric in the Server-Timing header.
#
# source://protocol-http//lib/protocol/http/header/server_timing.rb#33
class Protocol::HTTP::Header::ServerTiming::Metric < ::Struct
  # Create a new server timing metric.
  #
  # @return [Metric] a new instance of Metric
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#39
  def initialize(name, duration = T.unsafe(nil), description = T.unsafe(nil)); end

  # Returns the value of attribute description
  #
  # @return [Object] the current value of description
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
  def description; end

  # Sets the attribute description
  #
  # @param value [Object] the value to set the attribute description to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
  def description=(_); end

  # Returns the value of attribute duration
  #
  # @return [Object] the current value of duration
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
  def duration; end

  # Sets the attribute duration
  #
  # @param value [Object] the value to set the attribute duration to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
  def duration=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
  def name=(_); end

  # Convert the metric to its string representation.
  #
  # source://protocol-http//lib/protocol/http/header/server_timing.rb#46
  def to_s; end

  class << self
    # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
    def members; end

    # source://protocol-http//lib/protocol/http/header/server_timing.rb#33
    def new(*_arg0); end
  end
end

# source://protocol-http//lib/protocol/http/header/server_timing.rb#30
Protocol::HTTP::Header::ServerTiming::PARAMETER = T.let(T.unsafe(nil), Regexp)

class Protocol::HTTP::Header::ServerTiming::ParseError < ::Protocol::HTTP::Error; end

# The `set-cookie` header sends cookies from the server to the user agent.
#
# It is used to store cookies on the client side, which are then sent back to the server in subsequent requests using the `cookie` header.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#43
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Represents headers that can contain multiple distinct values separated by commas.
#
# This isn't a specific header  class is a utility for handling headers with comma-separated values, such as `accept`, `cache-control`, and other similar headers. The values are split and stored as an array internally, and serialized back to a comma-separated string when needed.
#
# source://protocol-http//lib/protocol/http/header/split.rb#12
class Protocol::HTTP::Header::Split < ::Array
  # Initializes a `Split` header with the given values.
  #
  # @return [Split] a new instance of Split
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#44
  def initialize(value = T.unsafe(nil)); end

  # Adds one or more comma-separated values to the header.
  #
  # The input string is split into distinct entries and appended to the array.
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#61
  def <<(value); end

  # Converts the parsed header value into a raw header value.
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#68
  def to_s; end

  protected

  # source://protocol-http//lib/protocol/http/header/split.rb#81
  def reverse_find(&block); end

  class << self
    # Coerces a value into a parsed header object.
    #
    # This method is used by the Headers class when setting values via `[]=` to convert application values into the appropriate policy type.
    #
    # source://protocol-http//lib/protocol/http/header/split.rb#32
    def coerce(value); end

    # Parses a raw header value.
    #
    # Split headers receive comma-separated values in a single header entry. This method splits the raw value into individual entries.
    #
    # source://protocol-http//lib/protocol/http/header/split.rb#22
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    # This is a base class for comma-separated headers, default is to disallow in trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/split.rb#75
    def trailer?; end
  end
end

# Regular expression used to split values on commas, with optional surrounding whitespace.
#
# source://protocol-http//lib/protocol/http/header/split.rb#14
Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

# The `te` header indicates the transfer encodings the client is willing to accept. AKA `accept-transfer-encoding`. How we ended up with `te` instead of `accept-transfer-encoding` is a mystery lost to time.
#
# The `te` header allows a client to indicate which transfer encodings it can handle, and in what order of preference using quality factors.
#
# source://protocol-http//lib/protocol/http/header/te.rb#16
class Protocol::HTTP::Header::TE < ::Protocol::HTTP::Header::Split
  # Adds one or more comma-separated values to the TE header. The values are converted to lowercase for normalization.
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#89
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#107
  def chunked?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#122
  def compress?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#117
  def deflate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#112
  def gzip?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#127
  def identity?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#132
  def trailers?; end

  # Parse the `te` header value into a list of transfer codings with quality factors.
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#96
  def transfer_codings; end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/te.rb#77
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/te.rb#69
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    # TE headers negotiate transfer encodings and must not appear in trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/te.rb#139
    def trailer?; end
  end
end

# The `chunked` transfer encoding
#
# source://protocol-http//lib/protocol/http/header/te.rb#29
Protocol::HTTP::Header::TE::CHUNKED = T.let(T.unsafe(nil), String)

# The `compress` transfer encoding
#
# source://protocol-http//lib/protocol/http/header/te.rb#38
Protocol::HTTP::Header::TE::COMPRESS = T.let(T.unsafe(nil), String)

# The `deflate` transfer encoding
#
# source://protocol-http//lib/protocol/http/header/te.rb#35
Protocol::HTTP::Header::TE::DEFLATE = T.let(T.unsafe(nil), String)

# The `gzip` transfer encoding
#
# source://protocol-http//lib/protocol/http/header/te.rb#32
Protocol::HTTP::Header::TE::GZIP = T.let(T.unsafe(nil), String)

# The `identity` transfer encoding
#
# source://protocol-http//lib/protocol/http/header/te.rb#41
Protocol::HTTP::Header::TE::IDENTITY = T.let(T.unsafe(nil), String)

class Protocol::HTTP::Header::TE::ParseError < ::Protocol::HTTP::Error; end

# Quality value pattern (0.0 to 1.0)
#
# source://protocol-http//lib/protocol/http/header/te.rb#23
Protocol::HTTP::Header::TE::QVALUE = T.let(T.unsafe(nil), Regexp)

# Transfer encoding token pattern
#
# source://protocol-http//lib/protocol/http/header/te.rb#20
Protocol::HTTP::Header::TE::TOKEN = T.let(T.unsafe(nil), Regexp)

# The `trailers` pseudo-encoding indicates willingness to accept trailer fields
#
# source://protocol-http//lib/protocol/http/header/te.rb#44
Protocol::HTTP::Header::TE::TRAILERS = T.let(T.unsafe(nil), String)

# Pattern for parsing transfer encoding with optional quality factor
#
# source://protocol-http//lib/protocol/http/header/te.rb#26
Protocol::HTTP::Header::TE::TRANSFER_CODING = T.let(T.unsafe(nil), Regexp)

# A single transfer coding entry with optional quality factor
#
# source://protocol-http//lib/protocol/http/header/te.rb#47
class Protocol::HTTP::Header::TE::TransferCoding < ::Struct
  # source://protocol-http//lib/protocol/http/header/te.rb#52
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#47
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#47
  def name=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#47
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/te.rb#47
  def q=(_); end

  # source://protocol-http//lib/protocol/http/header/te.rb#48
  def quality_factor; end

  # source://protocol-http//lib/protocol/http/header/te.rb#56
  def to_s; end

  class << self
    # source://protocol-http//lib/protocol/http/header/te.rb#47
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/te.rb#47
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/te.rb#47
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/te.rb#47
    def members; end

    # source://protocol-http//lib/protocol/http/header/te.rb#47
    def new(*_arg0); end
  end
end

# Represents headers that can contain multiple distinct values separated by commas.
#
# This isn't a specific header  class is a utility for handling headers with comma-separated values, such as `accept`, `cache-control`, and other similar headers. The values are split and stored as an array internally, and serialized back to a comma-separated string when needed.
#
# source://protocol-http//lib/protocol/http/header/trailer.rb#14
class Protocol::HTTP::Header::Trailer < ::Protocol::HTTP::Header::Split
  class << self
    # Whether this header is acceptable in HTTP trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/trailer.rb#17
    def trailer?; end
  end
end

# The `transfer-encoding` header indicates the encoding transformations that have been applied to the message body.
#
# The `transfer-encoding` header is used to specify the form of encoding used to safely transfer the message body between the sender and receiver.
#
# source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#14
class Protocol::HTTP::Header::TransferEncoding < ::Protocol::HTTP::Header::Split
  # Adds one or more comma-separated values to the transfer encoding header. The values are converted to lowercase for normalization.
  #
  # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#54
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#59
  def chunked?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#74
  def compress?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#69
  def deflate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#64
  def gzip?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#79
  def identity?; end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#42
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#34
    def parse(value); end

    # Whether this header is acceptable in HTTP trailers.
    # Transfer-Encoding headers control message framing and must not appear in trailers.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#86
    def trailer?; end
  end
end

# The `chunked` transfer encoding allows a server to send data of unknown length by breaking it into chunks.
#
# source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#16
Protocol::HTTP::Header::TransferEncoding::CHUNKED = T.let(T.unsafe(nil), String)

# The `compress` transfer encoding compresses the message body using the compress algorithm.
#
# source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#25
Protocol::HTTP::Header::TransferEncoding::COMPRESS = T.let(T.unsafe(nil), String)

# The `deflate` transfer encoding compresses the message body using the deflate algorithm.
#
# source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#22
Protocol::HTTP::Header::TransferEncoding::DEFLATE = T.let(T.unsafe(nil), String)

# The `gzip` transfer encoding compresses the message body using the gzip algorithm.
#
# source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#19
Protocol::HTTP::Header::TransferEncoding::GZIP = T.let(T.unsafe(nil), String)

# The `identity` transfer encoding indicates no transformation has been applied.
#
# source://protocol-http//lib/protocol/http/header/transfer_encoding.rb#28
Protocol::HTTP::Header::TransferEncoding::IDENTITY = T.let(T.unsafe(nil), String)

# Represents the `vary` header, which specifies the request headers a server considers when determining the response.
#
# The `vary` header is used in HTTP responses to indicate which request headers affect the selected response. It allows caches to differentiate stored responses based on specific request headers.
#
# source://protocol-http//lib/protocol/http/header/vary.rb#14
class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # Adds one or more comma-separated values to the `vary` header. The values are converted to lowercase for normalization.
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#39
  def <<(value); end

  class << self
    # Coerces a value into a parsed header object.
    #
    # source://protocol-http//lib/protocol/http/header/vary.rb#27
    def coerce(value); end

    # Parses a raw header value.
    #
    # source://protocol-http//lib/protocol/http/header/vary.rb#19
    def parse(value); end
  end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
#
# source://protocol-http//lib/protocol/http/headers.rb#39
class Protocol::HTTP::Headers
  # Initialize the headers with the specified fields.
  #
  # @return [Headers] a new instance of Headers
  #
  # source://protocol-http//lib/protocol/http/headers.rb#74
  def initialize(fields = T.unsafe(nil), tail = T.unsafe(nil), indexed: T.unsafe(nil), policy: T.unsafe(nil)); end

  # Compare this object to another object. May depend on the order of the fields.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#495
  def ==(other); end

  # Get the value of the specified header key.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#310
  def [](key); end

  # Set the specified header key to the specified value, replacing any existing values.
  #
  # The value can be a String or a coercable value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#284
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#251
  def add(key, value, trailer: T.unsafe(nil)); end

  # Compute a hash table of headers, where the keys are normalized to lower case and the values are normalized according to the policy for that header.
  #
  # This will enforce policy rules, such as merging multiple headers into arrays, or raising errors for duplicate headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#483
  def as_json; end

  # Clear all headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#110
  def clear; end

  # Delete all header values for the given key, and return the merged value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#413
  def delete(key); end

  # Enumerate all header keys and values.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#213
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#204
  def empty?; end

  # Extract the specified keys from the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#232
  def extract(keys); end

  # Returns the value of attribute fields.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#132
  def fields; end

  # Flatten trailer into the headers, returning a new instance of {Headers}.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#127
  def flatten; end

  # Flatten trailer into the headers, in-place.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#117
  def flatten!; end

  # Freeze the headers, and ensure the indexed hash is generated.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#191
  def freeze; end

  # Enumerate all the headers in the header, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#167
  def header(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#218
  def include?(key); end

  # Inspect the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#488
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#222
  def key?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#225
  def keys; end

  # Merge the headers into a new instance of {Headers}.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#324
  def merge(headers); end

  # Merge the headers into this instance.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#315
  def merge!(headers); end

  # Returns the value of attribute policy.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#87
  def policy; end

  # Set the policy for the headers.
  #
  # The policy is used to determine how headers are merged and normalized. For example, if a header is specified multiple times, the policy will determine how the values are merged.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#94
  def policy=(policy); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#273
  def set(key, value); end

  # Returns the value of attribute tail.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#135
  def tail; end

  # source://protocol-http//lib/protocol/http/headers.rb#138
  def to_a; end

  # Compute a hash table of headers, where the keys are normalized to lower case and the values are normalized according to the policy for that header.
  #
  # This will enforce policy rules, such as merging multiple headers into arrays, or raising errors for duplicate headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#468
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#182
  def trailer(&block); end

  # Record the current headers, and prepare to add trailers.
  #
  # This method is typically used after headers are sent to capture any additional headers which should then be sent as trailers.
  #
  # A sender that intends to generate one or more trailer fields in a message should generate a trailer header field in the header section of that message to indicate which fields might be present in the trailers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#156
  def trailer!(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#143
  def trailer?; end

  protected

  # Merge the value into the hash according to the policy for the given key.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#447
  def merge_into(hash, key, value); end

  private

  # Initialize a copy of the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#102
  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    #
    # source://protocol-http//lib/protocol/http/headers.rb#48
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
#
# source://protocol-http//lib/protocol/http/headers.rb#507
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # Construct a merged list of headers.
  #
  # @return [Merged] a new instance of Merged
  #
  # source://protocol-http//lib/protocol/http/headers.rb#513
  def initialize(*all); end

  # Add a new set of headers to the merged list.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#535
  def <<(headers); end

  # Clear the references to all headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#528
  def clear; end

  # Enumerate all headers in the merged list.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#546
  def each(&block); end

  # source://protocol-http//lib/protocol/http/headers.rb#518
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#523
  def flatten; end
end

# source://protocol-http//lib/protocol/http/headers.rb#41
Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

# The policy for various headers, including how they are merged and normalized.
#
# A policy may be `false` to indicate that the header may only be specified once and is a simple string.
#
# Otherwise, the policy is a class which implements the header normalization logic, including `parse` and `coerce` class methods.
#
# source://protocol-http//lib/protocol/http/headers.rb#333
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/headers.rb#40
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

# source://protocol-http//lib/protocol/http/headers.rb#43
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# Raised when an invalid trailer header is encountered in headers.
#
# source://protocol-http//lib/protocol/http/error.rb#52
class Protocol::HTTP::InvalidTrailerError < ::Protocol::HTTP::Error
  include ::Protocol::HTTP::BadRequest

  # @return [InvalidTrailerError] a new instance of InvalidTrailerError
  #
  # source://protocol-http//lib/protocol/http/error.rb#56
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://protocol-http//lib/protocol/http/error.rb#61
  def key; end
end

# Provides a convenient interface for commonly supported HTTP methods.
#
#
# These methods are defined in this module using lower case names. They are for convenience only and you should not overload those methods.
#
# See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods> for more details.
#
# source://protocol-http//lib/protocol/http/methods.rb#25
class Protocol::HTTP::Methods
  # source://protocol-http//lib/protocol/http/methods.rb#78
  def connect(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def delete(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def get(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def head(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def options(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def patch(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def post(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def put(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def trace(*arguments, **options); end

  class << self
    # Enumerate all HTTP methods.
    #
    # source://protocol-http//lib/protocol/http/methods.rb#69
    def each; end

    # Check if the given name is a valid HTTP method, according to this module.
    #
    # Note that this method only knows about the methods defined in this module, however there are many other methods defined in different specifications.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/methods.rb#58
    def valid?(name); end
  end
end

# The CONNECT method establishes a tunnel to the server identified by the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#42
Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

# The DELETE method deletes the specified resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#39
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

# The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
#
# source://protocol-http//lib/protocol/http/methods.rb#27
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

# The HEAD method asks for a response identical to a GET request, but without the response body.
#
# source://protocol-http//lib/protocol/http/methods.rb#30
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

# The OPTIONS method describes the communication options for the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#45
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

# The PATCH method applies partial modifications to a resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#51
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

# The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.
#
# source://protocol-http//lib/protocol/http/methods.rb#33
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

# The PUT method replaces all current representations of the target resource with the request payload.
#
# source://protocol-http//lib/protocol/http/methods.rb#36
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

# The TRACE method performs a message loop-back test along the path to the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#48
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

# The middleware interface provides a convenient wrapper for implementing HTTP middleware.
#
# A middleware instance generally needs to respond to two methods:
#
# - `call(request)` -> `response`
# - `close()`
#
# The call method is called for each request. The close method is called when the server is shutting down.
#
# You do not need to use the Middleware class to implement middleware. You can implement the interface directly.
#
# source://protocol-http//lib/protocol/http/middleware.rb#23
class Protocol::HTTP::Middleware < ::Protocol::HTTP::Methods
  # Initialize the middleware with the given delegate.
  #
  # @return [Middleware] a new instance of Middleware
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#39
  def initialize(delegate); end

  # Call the middleware with the given request. Invokes the call method on the delegate.
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#52
  def call(request); end

  # Close the middleware. Invokes the close method on the delegate.
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#47
  def close; end

  # Returns the value of attribute delegate.
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#44
  def delegate; end

  class << self
    # Build a middleware application using the given block.
    #
    # source://protocol-http//lib/protocol/http/middleware/builder.rb#63
    def build(*arguments, &block); end

    # Convert a block to a middleware delegate.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#28
    def for(&block); end

    # Load a middleware application from the given path.
    #
    # source://protocol-http//lib/protocol/http/middleware/builder.rb#77
    def load(path, *arguments, &block); end
  end
end

# A convenient interface for constructing middleware stacks.
#
# source://protocol-http//lib/protocol/http/middleware/builder.rb#12
class Protocol::HTTP::Middleware::Builder
  # Initialize the builder with the given default application.
  #
  # @return [Builder] a new instance of Builder
  #
  # source://protocol-http//lib/protocol/http/middleware/builder.rb#16
  def initialize(default_app = T.unsafe(nil)); end

  # Build the middleware application using the given block.
  #
  # source://protocol-http//lib/protocol/http/middleware/builder.rb#25
  def build(&block); end

  # Specify the (default) middleware application to use.
  #
  # source://protocol-http//lib/protocol/http/middleware/builder.rb#50
  def run(app); end

  # Convert the builder to an application by chaining the middleware together.
  #
  # source://protocol-http//lib/protocol/http/middleware/builder.rb#57
  def to_app; end

  # Use the given middleware with the given arguments and options.
  #
  # source://protocol-http//lib/protocol/http/middleware/builder.rb#43
  def use(middleware, *arguments, **options, &block); end
end

# source://protocol-http//lib/protocol/http/middleware/builder.rb#93
Protocol::HTTP::Middleware::Builder::TOPLEVEL_BINDING = T.let(T.unsafe(nil), Proc)

# A simple middleware that always returns "Hello World!".
#
# source://protocol-http//lib/protocol/http/middleware.rb#87
module Protocol::HTTP::Middleware::HelloWorld
  class << self
    # Call the middleware with the given request.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#96
    def call(request); end

    # Close the middleware - idempotent no-op.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#89
    def close; end
  end
end

# A simple middleware that always returns a 404 response.
#
# source://protocol-http//lib/protocol/http/middleware.rb#72
module Protocol::HTTP::Middleware::NotFound
  class << self
    # Call the middleware with the given request, always returning a 404 response. This middleware is useful as a default.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#81
    def call(request); end

    # Close the middleware - idempotent no-op.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#74
    def close; end
  end
end

# A simple middleware that always returns a 200 response.
#
# source://protocol-http//lib/protocol/http/middleware.rb#57
module Protocol::HTTP::Middleware::Okay
  class << self
    # Call the middleware with the given request, always returning a 200 response.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#66
    def call(request); end

    # Close the middleware - idempotent no-op.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#59
    def close; end
  end
end

# Provide a well defined, cached representation of a peer (address).
#
# source://protocol-http//lib/protocol/http/peer.rb#9
class Protocol::HTTP::Peer
  # Initialize the peer with the given address.
  #
  # @return [Peer] a new instance of Peer
  #
  # source://protocol-http//lib/protocol/http/peer.rb#22
  def initialize(address); end

  # Returns the value of attribute address.
  #
  # source://protocol-http//lib/protocol/http/peer.rb#31
  def address; end

  # Returns the value of attribute ip_address.
  #
  # source://protocol-http//lib/protocol/http/peer.rb#34
  def ip_address; end

  # Returns the value of attribute address.
  #
  # source://protocol-http//lib/protocol/http/peer.rb#36
  def remote_address; end

  class << self
    # Create a new peer object for the given IO object, using the remote address if available.
    #
    # source://protocol-http//lib/protocol/http/peer.rb#13
    def for(io); end
  end
end

# source://protocol-http//lib/protocol/http/quoted_string.rb#11
Protocol::HTTP::QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

# https://tools.ietf.org/html/rfc7231#section-5.3.1
#
# source://protocol-http//lib/protocol/http/quoted_string.rb#14
Protocol::HTTP::QVALUE = T.let(T.unsafe(nil), Regexp)

# Handling of HTTP quoted strings.
#
# source://protocol-http//lib/protocol/http/quoted_string.rb#17
module Protocol::HTTP::QuotedString
  class << self
    # Quote a string for HTTP header values if required.
    #
    # source://protocol-http//lib/protocol/http/quoted_string.rb#37
    def quote(value, force = T.unsafe(nil)); end

    # Unquote a "quoted-string" value according to <https://tools.ietf.org/html/rfc7230#section-3.2.6>. It should already match the QUOTED_STRING pattern above by the parser.
    #
    # source://protocol-http//lib/protocol/http/quoted_string.rb#19
    def unquote(value, normalize_whitespace = T.unsafe(nil)); end
  end
end

# source://protocol-http//lib/protocol/http/quoted_string.rb#32
Protocol::HTTP::QuotedString::QUOTES_REQUIRED = T.let(T.unsafe(nil), Regexp)

# Represents an HTTP request which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Request.new("http", "example.com", "GET", "/index.html", "HTTP/1.1", Protocol::HTTP::Headers[["accept", "text/html"]])
#
# # Short form:
# Protocol::HTTP::Request["GET", "/index.html", {"accept" => "text/html"}]
# ~~~
#
# source://protocol-http//lib/protocol/http/request.rb#25
class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # Initialize the request.
  #
  # @return [Request] a new instance of Request
  #
  # source://protocol-http//lib/protocol/http/request.rb#39
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil), interim_response = T.unsafe(nil)); end

  # Convert the request to a hash, suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/request.rb#143
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute authority.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def authority; end

  # Sets the attribute authority
  #
  # @param value the value to set the attribute authority to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def authority=(_arg0); end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/request.rb#70
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#70
  def body=(_arg0); end

  # Send the request to the given connection.
  #
  # source://protocol-http//lib/protocol/http/request.rb#86
  def call(connection); end

  # Whether this is a CONNECT request: typically used to establish a tunnel.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#117
  def connect?; end

  # Whether this is a HEAD request: no body is expected in the response.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#112
  def head?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/request.rb#67
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#67
  def headers=(_arg0); end

  # Whether the request can be replayed without side-effects.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#136
  def idempotent?; end

  # Returns the value of attribute interim_response.
  #
  # source://protocol-http//lib/protocol/http/request.rb#76
  def interim_response; end

  # Sets the attribute interim_response
  #
  # @param value the value to set the attribute interim_response to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#76
  def interim_response=(_arg0); end

  # Returns the value of attribute method.
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def method=(_arg0); end

  # Register a callback to be called when an interim response is received.
  #
  # source://protocol-http//lib/protocol/http/request.rb#100
  def on_interim_response(&block); end

  # Returns the value of attribute path.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def path=(_arg0); end

  # A request that is generated by a server, may choose to include the peer (address) associated with the request. It should be implemented by a sub-class.
  #
  # source://protocol-http//lib/protocol/http/request.rb#81
  def peer; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/request.rb#73
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#73
  def protocol=(_arg0); end

  # Returns the value of attribute scheme.
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def scheme; end

  # Sets the attribute scheme
  #
  # @param value the value to set the attribute scheme to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def scheme=(_arg0); end

  # Send an interim response back to the origin of this request, if possible.
  #
  # source://protocol-http//lib/protocol/http/request.rb#91
  def send_interim_response(status, headers); end

  # Convert the request to JSON.
  #
  # source://protocol-http//lib/protocol/http/request.rb#159
  def to_json(*_arg0, **_arg1, &_arg2); end

  # Summarize the request as a string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#166
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/request.rb#64
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#64
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main request variables that you'd typically care about.
    #
    # source://protocol-http//lib/protocol/http/request.rb#127
    def [](method, path = T.unsafe(nil), _headers = T.unsafe(nil), _body = T.unsafe(nil), scheme: T.unsafe(nil), authority: T.unsafe(nil), headers: T.unsafe(nil), body: T.unsafe(nil), protocol: T.unsafe(nil), interim_response: T.unsafe(nil)); end
  end
end

# Represents an HTTP response which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Response.new("http/1.1", 200, Protocol::HTTP::Headers[["content-type", "text/html"]], Protocol::HTTP::Body::Buffered.wrap("Hello, World!"))
#
# # Short form:
# Protocol::HTTP::Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
# ~~~
#
# source://protocol-http//lib/protocol/http/response.rb#23
class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # Create a new response.
  #
  # @return [Response] a new instance of Response
  #
  # source://protocol-http//lib/protocol/http/response.rb#33
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # Convert the response to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/response.rb#158
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Whether the status is 400 (bad request).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#120
  def bad_request?; end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/response.rb#51
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#51
  def body=(_arg0); end

  # Whether the status is 100 (continue).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#69
  def continue?; end

  # Whether the status is considered a failure.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#115
  def failure?; end

  # Whether the status is considered final. Note that 101 is considered final.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#79
  def final?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/response.rb#48
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#48
  def headers=(_arg0); end

  # Whether the response is considered a hijack: the connection has been taken over by the application and the server should not send any more data.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#64
  def hijack?; end

  # Whether the status is considered informational.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#74
  def informational?; end

  # Whether the status is 500 (internal server error).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#125
  def internal_server_error?; end

  # Whether the status is 304 (not modified).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#105
  def not_modified?; end

  # Whether the status is 200 (ok).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#85
  def ok?; end

  # Whether the status is 206 (partial content).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#95
  def partial?; end

  # A response that is generated by a client, may choose to include the peer (address) associated with the response. It should be implemented by a sub-class.
  #
  # source://protocol-http//lib/protocol/http/response.rb#59
  def peer; end

  # Whether the status is 307 (temporary redirect) and should preserve the method of the request when following the redirect.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#110
  def preserve_method?; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/response.rb#54
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#54
  def protocol=(_arg0); end

  # Whether the status is considered a redirection.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#100
  def redirection?; end

  # Whether the status is 500 (internal server error).
  #
  # @deprecated Use {#internal_server_error?} instead.
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#130
  def server_failure?; end

  # Returns the value of attribute status.
  #
  # source://protocol-http//lib/protocol/http/response.rb#45
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#45
  def status=(_arg0); end

  # Whether the status is considered successful.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#90
  def success?; end

  # Implicit conversion to an array.
  #
  # source://protocol-http//lib/protocol/http/response.rb#185
  def to_ary; end

  # Convert the response to JSON.
  #
  # source://protocol-http//lib/protocol/http/response.rb#171
  def to_json(*_arg0, **_arg1, &_arg2); end

  # Summarise the response as a string.
  #
  # source://protocol-http//lib/protocol/http/response.rb#178
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/response.rb#42
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#42
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main response variables that you'd typically care about. It follows the same order as the `Rack` response tuple, but also includes the protocol.
    #
    # ~~~ ruby
    # 	Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
    # ~~~
    #
    # source://protocol-http//lib/protocol/http/response.rb#141
    def [](status, _headers = T.unsafe(nil), _body = T.unsafe(nil), headers: T.unsafe(nil), body: T.unsafe(nil), protocol: T.unsafe(nil)); end

    # Create a response for the given exception.
    #
    # source://protocol-http//lib/protocol/http/response.rb#151
    def for_exception(exception); end
  end
end

# According to https://tools.ietf.org/html/rfc7231#appendix-C
#
# source://protocol-http//lib/protocol/http/quoted_string.rb#9
Protocol::HTTP::TOKEN = T.let(T.unsafe(nil), Regexp)
