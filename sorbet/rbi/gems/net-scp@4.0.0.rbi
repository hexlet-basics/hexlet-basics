# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-scp` gem.
# Please instead update this file by running `bin/tapioca gem net-scp`.


# Net::SCP implements the SCP (Secure CoPy) client protocol, allowing Ruby
# programs to securely and programmatically transfer individual files or
# entire directory trees to and from remote servers. It provides support for
# multiple simultaneous SCP copies working in parallel over the same
# connection, as well as for synchronous, serial copies.
#
# Basic usage:
#
#   require 'net/scp'
#
#   Net::SCP.start("remote.host", "username", :password => "passwd") do |scp|
#     # synchronous (blocking) upload; call blocks until upload completes
#     scp.upload! "/local/path", "/remote/path"
#
#     # asynchronous upload; call returns immediately and requires SSH
#     # event loop to run
#     channel = scp.upload("/local/path", "/remote/path")
#     channel.wait
#   end
#
# Net::SCP also provides an open-uri tie-in, so you can use the Kernel#open
# method to open and read a remote file:
#
#   # if you just want to parse SCP URL's:
#   require 'uri/scp'
#   url = URI.parse("scp://user@remote.host/path/to/file")
#
#   # if you want to read from a URL voa SCP:
#   require 'uri/open-scp'
#   puts open("scp://user@remote.host/path/to/file").read
#
# Lastly, Net::SCP adds a method to the Net::SSH::Connection::Session class,
# allowing you to easily grab a Net::SCP reference from an existing Net::SSH
# session:
#
#   require 'net/ssh'
#   require 'net/scp'
#
#   Net::SSH.start("remote.host", "username", :password => "passwd") do |ssh|
#     ssh.scp.download! "/remote/path", "/local/path"
#   end
#
# == Progress Reporting
#
# By default, uploading and downloading proceed silently, without any
# outward indication of their progress. For long running uploads or downloads
# (and especially in interactive environments) it is desirable to report
# to the user the progress of the current operation.
#
# To receive progress reports for the current operation, just pass a block
# to #upload or #download (or one of their variants):
#
#   scp.upload!("/path/to/local", "/path/to/remote") do |ch, name, sent, total|
#     puts "#{name}: #{sent}/#{total}"
#   end
#
# Whenever a new chunk of data is recieved for or sent to a file, the callback
# will be invoked, indicating the name of the file (local for downloads,
# remote for uploads), the number of bytes that have been sent or received
# so far for the file, and the size of the file.
#
# --
# = Protocol Description
#
# Although this information has zero relevance to consumers of the Net::SCP
# library, I'm documenting it here so that anyone else looking for documentation
# of the SCP protocol won't be left high-and-dry like I was. The following is
# reversed engineered from the OpenSSH SCP implementation, and so may
# contain errors. You have been warned!
#
# The first step is to invoke the "scp" command on the server. It accepts
# the following parameters, which must be set correctly to avoid errors:
#
# * "-t" -- tells the remote scp process that data will be sent "to" it,
#   e.g., that data will be uploaded and it should initialize itself
#   accordingly.
# * "-f" -- tells the remote scp process that data should come "from" it,
#   e.g., that data will be downloaded and it should initialize itself
#   accordingly.
# * "-v" -- verbose mode; the remote scp process should chatter about what
#   it is doing via stderr.
# * "-p" -- preserve timestamps. 'T' directives (see below) should be/will
#   be sent to indicate the modification and access times of each file.
# * "-r" -- recursive transfers should be allowed. Without this, it is an
#   error to upload or download a directory.
#
# After those flags, the name of the remote file/directory should be passed
# as the sole non-switch argument to scp.
#
# Then the fun begins. If you're doing a download, enter the download_start_state.
# Otherwise, look for upload_start_state.
#
# == Net::SCP::Download#download_start_state
#
# This is the start state for downloads. It simply sends a 0-byte to the
# server. The next state is Net::SCP::Download#read_directive_state.
#
# == Net::SCP::Upload#upload_start_state
#
# Sets up the initial upload scaffolding and waits for a 0-byte from the
# server, and then switches to Net::SCP::Upload#upload_current_state.
#
# == Net::SCP::Download#read_directive_state
#
# Reads a directive line from the input. The following directives are
# recognized:
#
# * T%d %d %d %d -- a "times" packet. Indicates that the next file to be
#   downloaded must have mtime/usec/atime/usec attributes preserved.
# * D%o %d %s -- a directory change. The process is changing to a directory
#   with the given permissions/size/name, and the recipient should create
#   a directory with the same name and permissions. Subsequent files and
#   directories will be children of this directory, until a matching 'E'
#   directive.
# * C%o %d %s -- a file is being sent next. The file will have the given
#   permissions/size/name. Immediately following this line, +size+ bytes
#   will be sent, raw.
# * E -- terminator directive. Indicates the end of a directory, and subsequent
#   files and directories should be received by the parent of the current
#   directory.
# * \0 -- indicates a successful response from the other end.
# * \1 -- warning directive. Indicates a warning from the other end.  Text from
#   this warning will be reported if the SCP results in an error.
# * \2 -- error directive.  Indicates an error from the other end.  Text from
#   this error will be reported if the SCP results in an error.
#
# If a 'C' directive is received, we switch over to
# Net::SCP::Download#read_data_state. If an 'E' directive is received, and
# there is no parent directory, we switch over to Net::SCP#finish_state.
#
# Regardless of what the next state is, we send a 0-byte to the server
# before moving to the next state.
#
# == Net::SCP::Download#read_data_state
#
# Bytes are read to satisfy the size of the incoming file. When all pending
# data has been read, we wait for the server to send a 0-byte, and then we
# switch to the Net::SCP::Download#finish_read_state.
#
# == Net::SCP::Download#finish_read_state
#
# We sent a 0-byte to the server to indicate that the file was successfully
# received. If there is no parent directory, then we're downloading a single
# file and we switch to Net::SCP#finish_state. Otherwise we jump back to the
# Net::SCP::Download#read_directive state to see what we get to download next.
#
# == Net::SCP::Upload#upload_current_state
#
# If the current item is a file, send a file. Sending a file starts with a
# 'T' directive (if :preserve is true), then a wait for the server to respond,
# and then a 'C' directive, and then a wait for the server to respond, and
# then a jump to Net::SCP::Upload#send_data_state.
#
# If current item is a directory, send a 'D' directive, and wait for the
# server to respond with a 0-byte. Then jump to Net::SCP::Upload#next_item_state.
#
# == Net::SCP::Upload#send_data_state
#
# Reads and sends the next chunk of data to the server. The state machine
# remains in this state until all data has been sent, at which point we
# send a 0-byte to the server, and wait for the server to respond with a
# 0-byte of its own. Then we jump back to Net::SCP::Upload#next_item_state.
#
# == Net::SCP::Upload#next_item_state
#
# If there is nothing left to upload, and there is no parent directory,
# jump to Net::SCP#finish_state.
#
# If there is nothing left to upload from the current directory, send an
# 'E' directive and wait for the server to respond with a 0-byte. Then go
# to Net::SCP::Upload#next_item_state.
#
# Otherwise, set the current upload source and go to
# Net::SCP::Upload#upload_current_state.
#
# == Net::SCP#finish_state
#
# Tells the server that no more data is forthcoming from this end of the
# pipe (via Net::SSH::Connection::Channel#eof!) and leaves the pipe to drain.
# It will be terminated when the remote process closes with an exit status
# of zero.
# ++
#
# source://net-scp//lib/net/scp/errors.rb#1
class Net::SCP
  include ::Net::SSH::Loggable
  include ::Net::SCP::Download
  include ::Net::SCP::Upload

  # Creates a new Net::SCP session on top of the given Net::SSH +session+
  # object.
  #
  # @return [SCP] a new instance of SCP
  #
  # source://net-scp//lib/net/scp.rb#251
  def initialize(session); end

  # Inititiate a synchronous (non-blocking) download from +remote+ to +local+.
  # The following options are recognized:
  #
  # * :recursive - the +remote+ parameter refers to a remote directory, which
  #   should be downloaded to a new directory named +local+ on the local
  #   machine.
  # * :preserve - the atime and mtime of the file should be preserved.
  # * :verbose - the process should result in verbose output on the server
  #   end (useful for debugging).
  #
  # This method will return immediately, returning the Net::SSH::Connection::Channel
  # object that will support the download. To wait for the download to finish,
  # you can either call the #wait method on the channel, or otherwise run
  # the Net::SSH event loop until the channel's #active? method returns false.
  #
  #   channel = scp.download("/remote/path", "/local/path")
  #   channel.wait
  #
  # source://net-scp//lib/net/scp.rb#304
  def download(remote, local, options = T.unsafe(nil), &progress); end

  # Same as #download, but blocks until the download finishes. Identical to
  # calling #download and then calling the #wait method on the channel
  # object that is returned.
  #
  #   scp.download!("/remote/path", "/local/path")
  #
  # If +local+ is nil, and the download is not recursive (e.g., it is downloading
  # only a single file), the file will be downloaded to an in-memory buffer
  # and the resulting string returned.
  #
  #   data = download!("/remote/path")
  #
  # source://net-scp//lib/net/scp.rb#319
  def download!(remote, local = T.unsafe(nil), options = T.unsafe(nil), &progress); end

  # The underlying Net::SSH session that acts as transport for the SCP
  # packets.
  #
  # source://net-scp//lib/net/scp.rb#247
  def session; end

  # Inititiate a synchronous (non-blocking) upload from +local+ to +remote+.
  # The following options are recognized:
  #
  # * :recursive - the +local+ parameter refers to a local directory, which
  #   should be uploaded to a new directory named +remote+ on the remote
  #   server.
  # * :preserve - the atime and mtime of the file should be preserved.
  # * :verbose - the process should result in verbose output on the server
  #   end (useful for debugging).
  # * :chunk_size - the size of each "chunk" that should be sent. Defaults
  #   to 2048. Changing this value may improve throughput at the expense
  #   of decreasing interactivity.
  #
  # This method will return immediately, returning the Net::SSH::Connection::Channel
  # object that will support the upload. To wait for the upload to finish,
  # you can either call the #wait method on the channel, or otherwise run
  # the Net::SSH event loop until the channel's #active? method returns false.
  #
  #   channel = scp.upload("/local/path", "/remote/path")
  #   channel.wait
  #
  # source://net-scp//lib/net/scp.rb#276
  def upload(local, remote, options = T.unsafe(nil), &progress); end

  # Same as #upload, but blocks until the upload finishes. Identical to
  # calling #upload and then calling the #wait method on the channel object
  # that is returned. The return value is not defined.
  #
  # source://net-scp//lib/net/scp.rb#283
  def upload!(local, remote, options = T.unsafe(nil), &progress); end

  private

  # Causes the state machine to enter the "await response" state, where
  # things just pause until the server replies with a 0 (see
  # #await_response_state), at which point the state machine will pick up
  # at +next_state+ and continue processing.
  #
  # source://net-scp//lib/net/scp.rb#382
  def await_response(channel, next_state); end

  # The action invoked while the state machine remains in the "await
  # response" state. As long as there is no data ready to process, the
  # machine will remain in this state. As soon as the server replies with
  # an integer 0 as the only byte, the state machine is kicked into the
  # next state (see +await_response+). If the response is not a 0, an
  # exception is raised.
  #
  # @raise [Net::SCP::Error]
  #
  # source://net-scp//lib/net/scp.rb#395
  def await_response_state(channel); end

  # The action invoked when the state machine is in the "finish" state.
  # It just tells the server not to expect any more data from this end
  # of the pipe, and allows the pipe to drain until the server closes it.
  #
  # source://net-scp//lib/net/scp.rb#406
  def finish_state(channel); end

  # Invoked to report progress back to the client. If a callback was not
  # set, this does nothing.
  #
  # source://net-scp//lib/net/scp.rb#412
  def progress_callback(channel, name, sent, total); end

  # Constructs the scp command line needed to initiate and SCP session
  # for the given +mode+ (:upload or :download) and with the given options
  # (:verbose, :recursive, :preserve). Returns the command-line as a
  # string, ready to execute.
  #
  # source://net-scp//lib/net/scp.rb#331
  def scp_command(mode, options); end

  # Imported from ruby 1.9.2 shellwords.rb
  #
  # source://net-scp//lib/net/scp.rb#417
  def shellescape(path); end

  # Opens a new SSH channel and executes the necessary SCP command over
  # it (see #scp_command). It then sets up the necessary callbacks, and
  # sets up a state machine to use to process the upload or download.
  # (See Net::SCP::Upload and Net::SCP::Download).
  #
  # source://net-scp//lib/net/scp.rb#344
  def start_command(mode, local, remote, options = T.unsafe(nil), &callback); end

  class << self
    # Starts up a new SSH connection using the +host+ and +username+ parameters,
    # instantiates a new SCP session on top of it, and then begins a
    # download from +remote+ to +local+. If the +options+ hash includes an
    # :ssh key, the value for that will be passed to the SSH connection as
    # options (e.g., to set the password, etc.). All other options are passed
    # to the #download! method. If a block is given, it will be used to report
    # progress (see "Progress Reporting", under Net::SCP).
    #
    # source://net-scp//lib/net/scp.rb#238
    def download!(host, username, remote, local = T.unsafe(nil), options = T.unsafe(nil), &progress); end

    # Starts up a new SSH connection and instantiates a new SCP session on
    # top of it. If a block is given, the SCP session is yielded, and the
    # SSH session is closed automatically when the block terminates. If no
    # block is given, the SCP session is returned.
    #
    # source://net-scp//lib/net/scp.rb#201
    def start(host, username, options = T.unsafe(nil)); end

    # Starts up a new SSH connection using the +host+ and +username+ parameters,
    # instantiates a new SCP session on top of it, and then begins an
    # upload from +local+ to +remote+. If the +options+ hash includes an
    # :ssh key, the value for that will be passed to the SSH connection as
    # options (e.g., to set the password, etc.). All other options are passed
    # to the #upload! method. If a block is given, it will be used to report
    # progress (see "Progress Reporting", under Net::SCP).
    #
    # source://net-scp//lib/net/scp.rb#224
    def upload!(host, username, local, remote, options = T.unsafe(nil), &progress); end
  end
end

# This module implements the state machine for downloading information from
# a remote server. It exposes no public methods. See Net::SCP#download for
# a discussion of how to use Net::SCP to download data.
#
# source://net-scp//lib/net/scp/download.rb#8
module Net::SCP::Download
  private

  # This is the starting state for the download state machine. The
  # #start_command method puts the state machine into this state the first
  # time the channel is processed. This state does some basic error checking
  # and scaffolding and then sends a 0-byte to the remote server, indicating
  # readiness to proceed. Then, the state machine is placed into the
  # "read directive" state (see #read_directive_state).
  #
  # source://net-scp//lib/net/scp/download.rb#17
  def download_start_state(channel); end

  # Finishes off the read, sets the times for the file (if any), and then
  # jumps to either #finish_state (for single-file downloads) or
  # #read_directive_state (for recursive downloads). A 0-byte is sent to the
  # server to indicate that the file was recieved successfully.
  #
  # source://net-scp//lib/net/scp/download.rb#77
  def finish_read_state(channel); end

  # Parses the given +text+ to extract which SCP directive it contains. It
  # then returns a hash with at least one key, :type, which describes what
  # type of directive it is. The hash may also contain other, directive-specific
  # data.
  #
  # source://net-scp//lib/net/scp/download.rb#94
  def parse_directive(text); end

  # Reads data from the channel for as long as there is data remaining to
  # be read. As soon as there is no more data to read for the current file,
  # the state machine switches to #finish_read_state.
  #
  # source://net-scp//lib/net/scp/download.rb#64
  def read_data_state(channel); end

  # This state parses the next full line (up to a new-line) for the next
  # directive. (See the SCP protocol documentation in Net::SCP for the
  # possible directives).
  #
  # source://net-scp//lib/net/scp/download.rb#34
  def read_directive_state(channel); end

  # Sets the new directory as the current directory, creates the directory
  # if it does not exist, and then falls back into #read_directive_state.
  #
  # source://net-scp//lib/net/scp/download.rb#124
  def read_directory(channel, directive); end

  # Opens the given file locally, and switches to #read_data_state to do the
  # actual read.
  #
  # source://net-scp//lib/net/scp/download.rb#147
  def read_file(channel, directive); end
end

# source://net-scp//lib/net/scp/errors.rb#3
class Net::SCP::Error < ::RuntimeError; end

# This module implements the state machine for uploading information to
# a remote server. It exposes no public methods. See Net::SCP#upload for
# a discussion of how to use Net::SCP to upload data.
#
# source://net-scp//lib/net/scp/upload.rb#8
module Net::SCP::Upload
  private

  # Checks the work queue to see what needs to be done next. If there is
  # nothing to do, calls Net::SCP#finish_state. If we're at the end of a
  # directory, sends an 'E' directive and waits for the server to respond
  # before moving to #next_item_state. Otherwise, sets the next thing to
  # upload and moves to #upload_current_state.
  #
  # source://net-scp//lib/net/scp/upload.rb#92
  def next_item_state(channel); end

  # If the :preserve option is set, send a 'T' directive and wait for the
  # server to respond before proceeding to either #upload_file_state or
  # #upload_directory_state, depending on what is being uploaded.
  #
  # source://net-scp//lib/net/scp/upload.rb#126
  def preserve_attributes_if_requested(channel); end

  # If any data remains to be transferred from the current file, sends it.
  # Otherwise, sends a 0-byte and transfers to #next_item_state.
  #
  # source://net-scp//lib/net/scp/upload.rb#74
  def send_data_state(channel); end

  # Sets the given +path+ as the new current item to upload.
  #
  # source://net-scp//lib/net/scp/upload.rb#110
  def set_current(channel, path); end

  # Determines what the next thing to upload is, and branches. If the next
  # item is a file, goes to #upload_file_state. If it is a directory, goes
  # to #upload_directory_state.
  #
  # source://net-scp//lib/net/scp/upload.rb#31
  def upload_current_state(channel); end

  # After transferring attributes (if requested), sends a 'D' directive and
  # awaites the server's 0-byte response. Then goes to #next_item_state.
  #
  # source://net-scp//lib/net/scp/upload.rb#46
  def upload_directory_state(channel); end

  # After transferring attributes (if requested), sends a 'C' directive and
  # awaits the server's 0-byte response. Then goes to #send_data_state.
  #
  # source://net-scp//lib/net/scp/upload.rb#59
  def upload_file_state(channel); end

  # The start state for uploads. Simply sets up the upload scaffolding,
  # sets the current item to upload, and jumps to #upload_current_state.
  #
  # source://net-scp//lib/net/scp/upload.rb#17
  def upload_start_state(channel); end
end

# The default read chunk size, if an explicit chunk-size is not specified
# by the client.
#
# source://net-scp//lib/net/scp/upload.rb#13
Net::SCP::Upload::DEFAULT_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

module Net::SSH::Connection; end

# source://net-scp//lib/net/scp.rb#442
class Net::SSH::Connection::Session
  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#68
  def initialize(transport, options = T.unsafe(nil)); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#94
  def [](key); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#99
  def []=(key, value); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#152
  def busy?(include_invisible = T.unsafe(nil)); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#51
  def channel_open_handlers; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#44
  def channels; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#522
  def cleanup_channel(channel); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#121
  def close; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#114
  def closed?; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#255
  def ev_do_calculate_rw_wait(wait); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#270
  def ev_do_handle_events(readers, writers); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#289
  def ev_do_postprocess(was_events); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#248
  def ev_preprocess(&block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#379
  def exec(command, status: T.unsafe(nil), &block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#420
  def exec!(command, status: T.unsafe(nil), &block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#493
  def forward; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#105
  def host; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#481
  def listen_to(io, &callback); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#47
  def listeners; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#177
  def loop(wait = T.unsafe(nil), &block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#532
  def max_select_wait_time; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#517
  def on_global_request(type, &block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#507
  def on_open_channel(type, &block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#338
  def open_channel(type = T.unsafe(nil), *extra, &on_confirm); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#38
  def options; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#54
  def pending_requests; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#262
  def postprocess(readers, writers); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#237
  def preprocess(&block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#225
  def process(wait = T.unsafe(nil), &block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#41
  def properties; end

  # Provides a convenient way to initialize a SCP session given a Net::SSH
  # session. Returns the Net::SCP instance, ready to use.
  #
  # source://net-scp//lib/net/scp.rb#445
  def scp; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#311
  def send_global_request(type, *extra, &callback); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#443
  def send_message(message); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#136
  def shutdown!; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#487
  def stop_listening_to(io); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#35
  def transport; end

  private

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#682
  def channel_close(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#568
  def channel_closed(channel); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#667
  def channel_data(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#677
  def channel_eof(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#672
  def channel_extended_data(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#694
  def channel_failure(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#612
  def channel_open(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#645
  def channel_open_confirmation(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#651
  def channel_open_failure(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#662
  def channel_request(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#689
  def channel_success(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#657
  def channel_window_adjust(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#545
  def dispatch_incoming_packets(raise_disconnect_errors: T.unsafe(nil)); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#539
  def each_channel(&block); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#562
  def force_channel_cleanup_on_close; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#558
  def get_next_channel_id; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#579
  def global_request(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#699
  def io_select_wait(wait); end

  def loop_forever; end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#602
  def request_failure(packet); end

  # source://net-ssh/7.3.0/lib/net/ssh/connection/session.rb#595
  def request_success(packet); end
end
