# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `solid_cache` gem.
# Please instead update this file by running `bin/tapioca gem solid_cache`.


# See https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44824.pdf
#
# source://solid_cache//lib/solid_cache/engine.rb#6
module SolidCache
  # source://solid_cache//lib/solid_cache.rb#13
  def configuration; end

  # source://solid_cache//lib/solid_cache.rb#13
  def configuration=(val); end

  # source://solid_cache//lib/solid_cache.rb#12
  def executor; end

  # source://solid_cache//lib/solid_cache.rb#12
  def executor=(val); end

  class << self
    # source://solid_cache//lib/solid_cache.rb#13
    def configuration; end

    # source://solid_cache//lib/solid_cache.rb#13
    def configuration=(val); end

    # source://solid_cache//lib/solid_cache.rb#12
    def executor; end

    # source://solid_cache//lib/solid_cache.rb#12
    def executor=(val); end

    # source://railties/8.0.1/lib/rails/engine.rb#413
    def railtie_helpers_paths; end

    # source://railties/8.0.1/lib/rails/engine.rb#396
    def railtie_namespace; end

    # source://railties/8.0.1/lib/rails/engine.rb#417
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # source://railties/8.0.1/lib/rails/engine.rb#402
    def table_name_prefix; end

    # source://railties/8.0.1/lib/rails/engine.rb#409
    def use_relative_model_naming?; end
  end
end

# source://solid_cache//lib/solid_cache/configuration.rb#4
class SolidCache::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#7
  def initialize(store_options: T.unsafe(nil), database: T.unsafe(nil), databases: T.unsafe(nil), connects_to: T.unsafe(nil), executor: T.unsafe(nil), encrypt: T.unsafe(nil), encryption_context_properties: T.unsafe(nil), size_estimate_samples: T.unsafe(nil)); end

  # Returns the value of attribute connects_to.
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#5
  def connects_to; end

  # Returns the value of attribute encrypt.
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#5
  def encrypt; end

  # @return [Boolean]
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#25
  def encrypt?; end

  # Returns the value of attribute encryption_context_properties.
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#5
  def encryption_context_properties; end

  # Returns the value of attribute executor.
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#5
  def executor; end

  # source://solid_cache//lib/solid_cache/configuration.rb#21
  def shard_keys; end

  # @return [Boolean]
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#17
  def sharded?; end

  # Returns the value of attribute size_estimate_samples.
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#5
  def size_estimate_samples; end

  # Returns the value of attribute store_options.
  #
  # source://solid_cache//lib/solid_cache/configuration.rb#5
  def store_options; end

  private

  # source://solid_cache//lib/solid_cache/configuration.rb#48
  def default_encryption_context_properties; end

  # source://solid_cache//lib/solid_cache/configuration.rb#30
  def set_connects_to(database:, databases:, connects_to:); end
end

# source://solid_cache//lib/solid_cache/connections.rb#4
module SolidCache::Connections
  class << self
    # source://solid_cache//lib/solid_cache/connections.rb#5
    def from_config(options); end
  end
end

# source://solid_cache//lib/solid_cache/connections/sharded.rb#5
class SolidCache::Connections::Sharded
  # @return [Sharded] a new instance of Sharded
  #
  # source://solid_cache//lib/solid_cache/connections/sharded.rb#8
  def initialize(names); end

  # source://solid_cache//lib/solid_cache/connections/sharded.rb#27
  def assign(keys); end

  # Returns the value of attribute consistent_hash.
  #
  # source://solid_cache//lib/solid_cache/connections/sharded.rb#6
  def consistent_hash; end

  # source://solid_cache//lib/solid_cache/connections/sharded.rb#31
  def count; end

  # Returns the value of attribute names.
  #
  # source://solid_cache//lib/solid_cache/connections/sharded.rb#6
  def names; end

  # Returns the value of attribute nodes.
  #
  # source://solid_cache//lib/solid_cache/connections/sharded.rb#6
  def nodes; end

  # source://solid_cache//lib/solid_cache/connections/sharded.rb#19
  def with(name, &block); end

  # source://solid_cache//lib/solid_cache/connections/sharded.rb#23
  def with_connection_for(key, &block); end

  # source://solid_cache//lib/solid_cache/connections/sharded.rb#13
  def with_each(&block); end

  private

  # source://solid_cache//lib/solid_cache/connections/sharded.rb#36
  def shard_for(key); end
end

# source://solid_cache//lib/solid_cache/connections/single.rb#5
class SolidCache::Connections::Single
  # @return [Single] a new instance of Single
  #
  # source://solid_cache//lib/solid_cache/connections/single.rb#8
  def initialize(name); end

  # source://solid_cache//lib/solid_cache/connections/single.rb#26
  def assign(keys); end

  # source://solid_cache//lib/solid_cache/connections/single.rb#30
  def count; end

  # Returns the value of attribute name.
  #
  # source://solid_cache//lib/solid_cache/connections/single.rb#6
  def name; end

  # source://solid_cache//lib/solid_cache/connections/single.rb#34
  def names; end

  # source://solid_cache//lib/solid_cache/connections/single.rb#18
  def with(name, &block); end

  # source://solid_cache//lib/solid_cache/connections/single.rb#22
  def with_connection_for(key, &block); end

  # source://solid_cache//lib/solid_cache/connections/single.rb#12
  def with_each(&block); end
end

# source://solid_cache//lib/solid_cache/connections/unmanaged.rb#5
class SolidCache::Connections::Unmanaged
  # source://solid_cache//lib/solid_cache/connections/unmanaged.rb#20
  def assign(keys); end

  # source://solid_cache//lib/solid_cache/connections/unmanaged.rb#24
  def count; end

  # source://solid_cache//lib/solid_cache/connections/unmanaged.rb#28
  def names; end

  # source://solid_cache//lib/solid_cache/connections/unmanaged.rb#12
  def with(name); end

  # source://solid_cache//lib/solid_cache/connections/unmanaged.rb#16
  def with_connection_for(key); end

  # source://solid_cache//lib/solid_cache/connections/unmanaged.rb#6
  def with_each; end
end

# source://solid_cache//lib/solid_cache/engine.rb#7
class SolidCache::Engine < ::Rails::Engine
  class << self
    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end

class SolidCache::Entry < ::SolidCache::Record
  include ::SolidCache::Entry::GeneratedAttributeMethods
  include ::SolidCache::Entry::GeneratedAssociationMethods
  include ::SolidCache::Entry::Size
  include ::SolidCache::Entry::Expiration
  include ::SolidCache::Entry::Encryption
  extend ::SolidCache::Entry::Size::ClassMethods
  extend ::SolidCache::Entry::Expiration::ClassMethods

  class << self
    def clear_delete; end
    def clear_truncate; end
    def delete_by_key(*keys); end
    def id_range; end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def in_key_hash_range(*args, **_arg1); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def largest_byte_sizes(*args, **_arg1); end

    def lock_and_write(key, &block); end
    def read(key); end
    def read_multi(keys); end

    # source://activerecord/8.0.1/lib/active_record/scoping/named.rb#174
    def up_to_byte_size(*args, **_arg1); end

    def write(key, value); end
    def write_multi(payloads); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end

    def add_key_hash_and_byte_size(payloads); end
    def byte_size_for(payload); end
    def estimated_row_overhead; end
    def key_hash_for(key); end
    def key_hashes_for(keys); end
    def select_sql(keys); end
    def upsert_unique_by; end
    def without_query_cache(&block); end
  end
end

SolidCache::Entry::ESTIMATED_ENCRYPTION_OVERHEAD = T.let(T.unsafe(nil), Integer)
SolidCache::Entry::ESTIMATED_ROW_OVERHEAD = T.let(T.unsafe(nil), Integer)

module SolidCache::Entry::Encryption
  extend ::ActiveSupport::Concern
end

module SolidCache::Entry::Expiration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidCache::Entry::Expiration::ClassMethods
end

module SolidCache::Entry::Expiration::ClassMethods
  def expire(count, max_age:, max_entries:, max_size:); end

  private

  def cache_full?(max_entries:, max_size:); end
  def expiry_candidate_ids(count, max_age:, max_entries:, max_size:); end
end

module SolidCache::Entry::GeneratedAssociationMethods; end
module SolidCache::Entry::GeneratedAttributeMethods; end
SolidCache::Entry::KEY_HASH_ID_RANGE = T.let(T.unsafe(nil), Range)

module SolidCache::Entry::Size
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidCache::Entry::Size::ClassMethods
end

module SolidCache::Entry::Size::ClassMethods
  def estimated_size(samples: T.unsafe(nil)); end
end

class SolidCache::Entry::Size::Estimate
  def initialize(samples:); end

  def exact?; end
  def max_records; end
  def samples; end
  def size; end

  private

  def key_hash_range; end
  def non_outlier_estimated_size; end
  def outliers_count; end
  def outliers_cutoff; end
  def outliers_size; end
  def outliers_size_count_and_cutoff; end
  def sample_range; end
  def sample_range_size; end
  def sampled_fraction; end
  def sampled_non_outlier_size; end
end

class SolidCache::Entry::Size::MovingAverageEstimate
  def initialize(samples:); end

  def exact?(*_arg0, **_arg1, &_arg2); end
  def samples; end
  def size; end

  private

  def estimate; end
  def latest_value; end
  def latest_values; end
  def previous_values; end
  def retained_estimates; end
  def retained_estimates_for_target_fraction; end
  def write_values(values); end
end

SolidCache::Entry::Size::MovingAverageEstimate::ESTIMATES_KEY = T.let(T.unsafe(nil), String)
SolidCache::Entry::Size::MovingAverageEstimate::MAX_RETAINED_ESTIMATES = T.let(T.unsafe(nil), Integer)
SolidCache::Entry::Size::MovingAverageEstimate::TARGET_SAMPLED_FRACTION = T.let(T.unsafe(nil), Float)

class SolidCache::ExpiryJob < ::ActiveJob::Base
  def perform(count, shard: T.unsafe(nil), max_age: T.unsafe(nil), max_entries: T.unsafe(nil), max_size: T.unsafe(nil)); end
end

# source://solid_cache//lib/solid_cache/maglev_hash.rb#6
class SolidCache::MaglevHash
  # @raise [ArgumentError]
  # @return [MaglevHash] a new instance of MaglevHash
  #
  # source://solid_cache//lib/solid_cache/maglev_hash.rb#12
  def initialize(nodes); end

  # source://solid_cache//lib/solid_cache/maglev_hash.rb#20
  def node(key); end

  # Returns the value of attribute nodes.
  #
  # source://solid_cache//lib/solid_cache/maglev_hash.rb#7
  def nodes; end

  private

  # source://solid_cache//lib/solid_cache/maglev_hash.rb#27
  def build_lookup; end

  # source://solid_cache//lib/solid_cache/maglev_hash.rb#43
  def build_preferences(node); end

  # Returns the value of attribute lookup.
  #
  # source://solid_cache//lib/solid_cache/maglev_hash.rb#25
  def lookup; end

  # source://solid_cache//lib/solid_cache/maglev_hash.rb#50
  def md5(*args); end

  # Returns the value of attribute node_count.
  #
  # source://solid_cache//lib/solid_cache/maglev_hash.rb#25
  def node_count; end

  # source://solid_cache//lib/solid_cache/maglev_hash.rb#54
  def quick_hash(key); end
end

# source://solid_cache//lib/solid_cache/maglev_hash.rb#58
class SolidCache::MaglevHash::Preferences
  # @return [Preferences] a new instance of Preferences
  #
  # source://solid_cache//lib/solid_cache/maglev_hash.rb#59
  def initialize(offset, skip); end

  # source://solid_cache//lib/solid_cache/maglev_hash.rb#64
  def preferred_free_slot(lookup); end

  private

  # source://solid_cache//lib/solid_cache/maglev_hash.rb#74
  def next_slot; end

  # Returns the value of attribute preferred_slots.
  #
  # source://solid_cache//lib/solid_cache/maglev_hash.rb#72
  def preferred_slots; end

  # Returns the value of attribute rank.
  #
  # source://solid_cache//lib/solid_cache/maglev_hash.rb#72
  def rank; end
end

# Must be prime
#
# source://solid_cache//lib/solid_cache/maglev_hash.rb#10
SolidCache::MaglevHash::TABLE_SIZE = T.let(T.unsafe(nil), Integer)

class SolidCache::Record < ::ActiveRecord::Base
  include ::SolidCache::Record::GeneratedAttributeMethods
  include ::SolidCache::Record::GeneratedAssociationMethods

  class << self
    def disable_instrumentation(&block); end
    def each_shard(&block); end
    def with_shard(shard, &block); end

    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr__validators; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr__validators=(new_value); end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr_defined_enums; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr_defined_enums=(new_value); end
  end
end

module SolidCache::Record::GeneratedAssociationMethods; end
module SolidCache::Record::GeneratedAttributeMethods; end
SolidCache::Record::NULL_INSTRUMENTER = T.let(T.unsafe(nil), ActiveSupport::Notifications::Instrumenter)

# source://solid_cache//lib/solid_cache/store.rb#4
class SolidCache::Store < ::ActiveSupport::Cache::Store
  include ::ActiveSupport::Cache::Strategy::LocalCache
  include ::SolidCache::Store::Stats
  include ::SolidCache::Store::Failsafe
  include ::SolidCache::Store::Expiry
  include ::SolidCache::Store::Execution
  include ::SolidCache::Store::Entries
  include ::SolidCache::Store::Connections
  include ::SolidCache::Store::Api

  # @return [Store] a new instance of Store
  #
  # source://solid_cache//lib/solid_cache/store.rb#8
  def initialize(options = T.unsafe(nil)); end

  # source://solid_cache//lib/solid_cache/store.rb#16
  def setup!; end

  class << self
    # @return [Boolean]
    #
    # source://solid_cache//lib/solid_cache/store.rb#12
    def supports_cache_versioning?; end
  end
end

# source://solid_cache//lib/solid_cache/store/api.rb#5
module SolidCache::Store::Api
  # source://solid_cache//lib/solid_cache/store/api.rb#11
  def initialize(options = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://solid_cache//lib/solid_cache/store/api.rb#35
  def cleanup(options = T.unsafe(nil)); end

  # source://solid_cache//lib/solid_cache/store/api.rb#39
  def clear(options = T.unsafe(nil)); end

  # source://solid_cache//lib/solid_cache/store/api.rb#26
  def decrement(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://solid_cache//lib/solid_cache/store/api.rb#17
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns the value of attribute max_key_bytesize.
  #
  # source://solid_cache//lib/solid_cache/store/api.rb#9
  def max_key_bytesize; end

  private

  # source://solid_cache//lib/solid_cache/store/api.rb#154
  def adjust(name, amount, options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#164
  def adjusted_entry(value, amount, options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#118
  def delete_entry(key, **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#122
  def delete_multi_entries(entries, **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#136
  def deserialize_entry(payload, **_arg1); end

  # source://solid_cache//lib/solid_cache/store/api.rb#140
  def normalize_key(key, options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#44
  def read_entry(key, **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#79
  def read_multi_entries(names, **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#75
  def read_serialized_entries(keys); end

  # source://solid_cache//lib/solid_cache/store/api.rb#48
  def read_serialized_entry(key, **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#130
  def serialize_entries(entries, **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#126
  def serialize_entry(entry, raw: T.unsafe(nil), **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#144
  def truncate_key(key); end

  # source://solid_cache//lib/solid_cache/store/api.rb#52
  def write_entry(key, entry, raw: T.unsafe(nil), unless_exist: T.unsafe(nil), **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#106
  def write_multi_entries(entries, expires_in: T.unsafe(nil), **options); end

  # source://solid_cache//lib/solid_cache/store/api.rb#71
  def write_serialized_entry(key, payload, raw: T.unsafe(nil), unless_exist: T.unsafe(nil), expires_in: T.unsafe(nil), race_condition_ttl: T.unsafe(nil), returning: T.unsafe(nil), **options); end
end

# source://solid_cache//lib/solid_cache/store/api.rb#6
SolidCache::Store::Api::DEFAULT_MAX_KEY_BYTESIZE = T.let(T.unsafe(nil), Integer)

# source://solid_cache//lib/solid_cache/store/api.rb#7
SolidCache::Store::Api::SQL_WILDCARD_CHARS = T.let(T.unsafe(nil), Array)

# source://solid_cache//lib/solid_cache/store/connections.rb#5
module SolidCache::Store::Connections
  # source://solid_cache//lib/solid_cache/store/connections.rb#8
  def initialize(options = T.unsafe(nil)); end

  # source://solid_cache//lib/solid_cache/store/connections.rb#53
  def connection_names; end

  # source://solid_cache//lib/solid_cache/store/connections.rb#57
  def connections; end

  # source://solid_cache//lib/solid_cache/store/connections.rb#49
  def group_by_connection(keys); end

  # Returns the value of attribute shard_options.
  #
  # source://solid_cache//lib/solid_cache/store/connections.rb#6
  def shard_options; end

  # source://solid_cache//lib/solid_cache/store/connections.rb#43
  def with_connection(name, async: T.unsafe(nil), &block); end

  # source://solid_cache//lib/solid_cache/store/connections.rb#37
  def with_connection_for(key, async: T.unsafe(nil), &block); end

  # source://solid_cache//lib/solid_cache/store/connections.rb#29
  def with_each_connection(async: T.unsafe(nil), &block); end

  private

  # source://solid_cache//lib/solid_cache/store/connections.rb#66
  def reading_key(key, failsafe:, failsafe_returning: T.unsafe(nil), &block); end

  # source://solid_cache//lib/solid_cache/store/connections.rb#72
  def reading_keys(keys, failsafe:, failsafe_returning: T.unsafe(nil)); end

  # source://solid_cache//lib/solid_cache/store/connections.rb#62
  def setup!; end

  # source://solid_cache//lib/solid_cache/store/connections.rb#99
  def writing_all(failsafe:, failsafe_returning: T.unsafe(nil), &block); end

  # source://solid_cache//lib/solid_cache/store/connections.rb#83
  def writing_key(key, failsafe:, failsafe_returning: T.unsafe(nil), &block); end

  # source://solid_cache//lib/solid_cache/store/connections.rb#89
  def writing_keys(entries, failsafe:, failsafe_returning: T.unsafe(nil)); end
end

# source://solid_cache//lib/solid_cache/store/entries.rb#5
module SolidCache::Store::Entries
  # source://solid_cache//lib/solid_cache/store/entries.rb#8
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute clear_with.
  #
  # source://solid_cache//lib/solid_cache/store/entries.rb#6
  def clear_with; end

  private

  # source://solid_cache//lib/solid_cache/store/entries.rb#20
  def entry_clear; end

  # source://solid_cache//lib/solid_cache/store/entries.rb#66
  def entry_delete(key); end

  # source://solid_cache//lib/solid_cache/store/entries.rb#72
  def entry_delete_multi(entries); end

  # source://solid_cache//lib/solid_cache/store/entries.rb#30
  def entry_lock_and_write(key, &block); end

  # source://solid_cache//lib/solid_cache/store/entries.rb#38
  def entry_read(key); end

  # source://solid_cache//lib/solid_cache/store/entries.rb#44
  def entry_read_multi(keys); end

  # source://solid_cache//lib/solid_cache/store/entries.rb#50
  def entry_write(key, payload); end

  # source://solid_cache//lib/solid_cache/store/entries.rb#58
  def entry_write_multi(entries); end
end

# source://solid_cache//lib/solid_cache/store/execution.rb#5
module SolidCache::Store::Execution
  # source://solid_cache//lib/solid_cache/store/execution.rb#6
  def initialize(options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://solid_cache//lib/solid_cache/store/execution.rb#43
  def active_record_instrumentation?; end

  # source://solid_cache//lib/solid_cache/store/execution.rb#13
  def async(&block); end

  # source://solid_cache//lib/solid_cache/store/execution.rb#27
  def execute(async, &block); end

  # source://solid_cache//lib/solid_cache/store/execution.rb#47
  def setup_instrumentation(&block); end

  # source://solid_cache//lib/solid_cache/store/execution.rb#35
  def wrap_in_rails_executor(&block); end
end

# source://solid_cache//lib/solid_cache/store/expiry.rb#7
module SolidCache::Store::Expiry
  # @raise [ArgumentError]
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#14
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute expires_per_write.
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#12
  def expires_per_write; end

  # Returns the value of attribute expiry_batch_size.
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#12
  def expiry_batch_size; end

  # Returns the value of attribute expiry_method.
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#12
  def expiry_method; end

  # Returns the value of attribute expiry_queue.
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#12
  def expiry_queue; end

  # Returns the value of attribute max_age.
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#12
  def max_age; end

  # Returns the value of attribute max_entries.
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#12
  def max_entries; end

  # Returns the value of attribute max_size.
  #
  # source://solid_cache//lib/solid_cache/store/expiry.rb#12
  def max_size; end

  # source://solid_cache//lib/solid_cache/store/expiry.rb#27
  def track_writes(count); end

  private

  # source://solid_cache//lib/solid_cache/store/expiry.rb#39
  def expire_later; end

  # source://solid_cache//lib/solid_cache/store/expiry.rb#32
  def expiry_batches(count); end
end

# For every write that we do, we attempt to delete EXPIRY_MULTIPLIER times as many records.
# This ensures there is downward pressure on the cache size while there is valid data to delete
#
# source://solid_cache//lib/solid_cache/store/expiry.rb#10
SolidCache::Store::Expiry::EXPIRY_MULTIPLIER = T.let(T.unsafe(nil), Integer)

# source://solid_cache//lib/solid_cache/store/failsafe.rb#5
module SolidCache::Store::Failsafe
  # source://solid_cache//lib/solid_cache/store/failsafe.rb#22
  def initialize(options = T.unsafe(nil)); end

  private

  # Returns the value of attribute error_handler.
  #
  # source://solid_cache//lib/solid_cache/store/failsafe.rb#29
  def error_handler; end

  # source://solid_cache//lib/solid_cache/store/failsafe.rb#31
  def failsafe(method, returning: T.unsafe(nil)); end
end

# source://solid_cache//lib/solid_cache/store/failsafe.rb#16
SolidCache::Store::Failsafe::DEFAULT_ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

# source://solid_cache//lib/solid_cache/store/failsafe.rb#6
SolidCache::Store::Failsafe::TRANSIENT_ACTIVE_RECORD_ERRORS = T.let(T.unsafe(nil), Array)

# source://solid_cache//lib/solid_cache/store/stats.rb#5
module SolidCache::Store::Stats
  # source://solid_cache//lib/solid_cache/store/stats.rb#6
  def initialize(options = T.unsafe(nil)); end

  # source://solid_cache//lib/solid_cache/store/stats.rb#10
  def stats; end

  private

  # source://solid_cache//lib/solid_cache/store/stats.rb#22
  def connection_stats; end

  # source://solid_cache//lib/solid_cache/store/stats.rb#18
  def connections_stats; end
end

# source://solid_cache//lib/solid_cache/version.rb#4
SolidCache::VERSION = T.let(T.unsafe(nil), String)
