# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `io-endpoint` gem.
# Please instead update this file by running `bin/tapioca gem io-endpoint`.


# source://io-endpoint//lib/io/endpoint/version.rb#7
class IO
  include ::Enumerable
  include ::File::Constants
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def &(_arg0); end
  def <=>(_arg0); end
  def ^(_arg0); end
  def and!(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def each(*_arg0); end
  def each_byte(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def get_values(_arg0, _arg1); end
  def hexdump(*_arg0); end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def not!; end
  def null?; end
  def or!(_arg0); end
  def pread(*_arg0); end
  def private?; end
  def pwrite(*_arg0); end
  def read(*_arg0); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def set_values(_arg0, _arg1, _arg2); end
  def shared?; end
  def size; end
  def slice(*_arg0); end
  def to_s; end
  def transfer; end
  def valid?; end
  def values(*_arg0); end
  def write(*_arg0); end
  def xor!(_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def initialize_copy(_arg0); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
    def size_of(_arg0); end
    def string(_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::MaskError < ::ArgumentError; end
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)
IO::Buffer::SHARED = T.let(T.unsafe(nil), Integer)
class IO::ConsoleMode; end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

# Represents a collection of endpoint classes for network I/O operations.
#
# source://io-endpoint//lib/io/endpoint/version.rb#9
module IO::Endpoint
  class << self
    # Create a composite endpoint from multiple endpoints.
    #
    # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#100
    def composite(*endpoints, **options); end

    # Get the current file descriptor limit for the process.
    #
    # source://io-endpoint//lib/io/endpoint.rb#14
    def file_descriptor_limit; end

    # Create a socket endpoint from an existing socket.
    #
    # source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#64
    def socket(socket, **options); end

    # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#253
    def ssl(*arguments, ssl_context: T.unsafe(nil), hostname: T.unsafe(nil), **options); end

    # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#102
    def tcp(*arguments, **options); end

    # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#112
    def udp(*arguments, **options); end

    # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#156
    def unix(path = T.unsafe(nil), type = T.unsafe(nil), **options); end
  end
end

# source://io-endpoint//lib/io/endpoint/generic.rb#11
IO::Endpoint::Address = Addrinfo

# Represents an endpoint for a specific network address.
#
# source://io-endpoint//lib/io/endpoint/address_endpoint.rb#13
class IO::Endpoint::AddressEndpoint < ::IO::Endpoint::Generic
  # Initialize a new address endpoint.
  #
  # @return [AddressEndpoint] a new instance of AddressEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/address_endpoint.rb#17
  def initialize(address, **options); end

  # Returns the value of attribute address.
  #
  # source://io-endpoint//lib/io/endpoint/address_endpoint.rb#45
  def address; end

  # Bind a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # source://io-endpoint//lib/io/endpoint/address_endpoint.rb#51
  def bind(wrapper = T.unsafe(nil), &block); end

  # Connects a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # source://io-endpoint//lib/io/endpoint/address_endpoint.rb#57
  def connect(wrapper = T.unsafe(nil), &block); end

  # Get a detailed string representation of the endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/address_endpoint.rb#40
  def inspect; end

  # Get a string representation of the endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/address_endpoint.rb#25
  def to_s; end
end

# Represents an endpoint that has been bound to one or more sockets.
#
# source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#12
class IO::Endpoint::BoundEndpoint < ::IO::Endpoint::Generic
  # Initialize a new bound endpoint.
  #
  # @return [BoundEndpoint] a new instance of BoundEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#32
  def initialize(endpoint, sockets, **options); end

  # Bind the endpoint using the given wrapper.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#87
  def bind(wrapper = T.unsafe(nil), &block); end

  # Close all bound sockets.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#65
  def close; end

  # Returns the value of attribute endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#40
  def endpoint; end

  # Get a detailed string representation of the bound endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#78
  def inspect; end

  # A endpoint for the local end of the bound socket.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#46
  def local_address_endpoint(**options); end

  # A endpoint for the remote end of the bound socket.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#56
  def remote_address_endpoint(**options); end

  # Returns the value of attribute sockets.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#42
  def sockets; end

  # Get a string representation of the bound endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#72
  def to_s; end

  class << self
    # Create a bound endpoint from an existing endpoint.
    #
    # @option backlog
    # @option close_on_exec
    # @param backlog [Hash] a customizable set of options
    # @param close_on_exec [Hash] a customizable set of options
    #
    # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#18
    def bound(endpoint, backlog: T.unsafe(nil), close_on_exec: T.unsafe(nil)); end
  end
end

# A composite endpoint is a collection of endpoints that are used in order.
#
# source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#10
class IO::Endpoint::CompositeEndpoint < ::IO::Endpoint::Generic
  # Initialize a new composite endpoint.
  #
  # @return [CompositeEndpoint] a new instance of CompositeEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#14
  def initialize(endpoints, **options); end

  # Bind all endpoints in the composite.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#85
  def bind(wrapper = T.unsafe(nil), &block); end

  # Connect to the first endpoint that succeeds.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#67
  def connect(wrapper = T.unsafe(nil), &block); end

  # Enumerate all endpoints in the composite endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#55
  def each(&block); end

  # Returns the value of attribute endpoints.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#45
  def endpoints; end

  # Get a detailed string representation of the composite endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#33
  def inspect; end

  # The number of endpoints in the composite endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#48
  def size; end

  # Get a string representation of the composite endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#27
  def to_s; end

  # Create a new composite endpoint with merged options.
  #
  # source://io-endpoint//lib/io/endpoint/composite_endpoint.rb#40
  def with(**options); end
end

# Represents an endpoint that has been connected to a socket.
#
# source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#14
class IO::Endpoint::ConnectedEndpoint < ::IO::Endpoint::Generic
  # Initialize a new connected endpoint.
  #
  # @return [ConnectedEndpoint] a new instance of ConnectedEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#31
  def initialize(endpoint, socket, **options); end

  # Close the connected socket.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#69
  def close; end

  # Connect using the already connected socket.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#60
  def connect(wrapper = T.unsafe(nil), &block); end

  # Returns the value of attribute endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#39
  def endpoint; end

  # Get a detailed string representation of the connected endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#84
  def inspect; end

  # A endpoint for the local end of the bound socket.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#45
  def local_address_endpoint(**options); end

  # A endpoint for the remote end of the bound socket.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#51
  def remote_address_endpoint(**options); end

  # Returns the value of attribute socket.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#41
  def socket; end

  # Get a string representation of the connected endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#78
  def to_s; end

  class << self
    # Create a connected endpoint from an existing endpoint.
    #
    # @option close_on_exec
    # @param close_on_exec [Hash] a customizable set of options
    #
    # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#19
    def connected(endpoint, close_on_exec: T.unsafe(nil)); end
  end
end

# Endpoints represent a way of connecting or binding to an address.
#
# source://io-endpoint//lib/io/endpoint/generic.rb#14
class IO::Endpoint::Generic
  # Initialize a new generic endpoint.
  #
  # @return [Generic] a new instance of Generic
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#17
  def initialize(**options); end

  # Bind and accept connections on the given address.
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#87
  def accept(wrapper = T.unsafe(nil), &block); end

  # Bind a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # @raise [NotImplementedError]
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#72
  def bind(wrapper = T.unsafe(nil), &block); end

  # Create a bound endpoint from this endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/bound_endpoint.rb#104
  def bound(**options); end

  # Connects a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # @raise [NotImplementedError]
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#79
  def connect(wrapper = T.unsafe(nil), &block); end

  # Create a connected endpoint from this endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/connected_endpoint.rb#93
  def connected(**options); end

  # Enumerate all discrete paths as endpoints.
  #
  # @yield [_self]
  # @yieldparam _self [IO::Endpoint::Generic] the object that the method was called on
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#96
  def each; end

  # source://io-endpoint//lib/io/endpoint/generic.rb#35
  def hostname; end

  # Controls SO_LINGER. The amount of time the socket will stay in the `TIME_WAIT` state after being closed.
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#53
  def linger; end

  # source://io-endpoint//lib/io/endpoint/generic.rb#63
  def local_address; end

  # Returns the value of attribute options.
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#32
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#32
  def options=(_arg0); end

  # If `SO_REUSEADDR` is enabled on a socket prior to binding it, the socket can be successfully bound unless there is a conflict with another socket bound to exactly the same combination of source address and port. Additionally, when set, binding a socket to the address of an existing socket in `TIME_WAIT` is not an error.
  #
  # @return [Boolean]
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#47
  def reuse_address?; end

  # If `SO_REUSEPORT` is enabled on a socket, the socket can be successfully bound even if there are existing sockets bound to the same address, as long as all prior bound sockets also had `SO_REUSEPORT` set before they were bound.
  #
  # @return [Boolean]
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#41
  def reuse_port?; end

  # source://io-endpoint//lib/io/endpoint/generic.rb#58
  def timeout; end

  # Create a new endpoint with merged options.
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#24
  def with(**options); end

  # The default wrapper to use for binding, connecting, and accepting connections.
  #
  # source://io-endpoint//lib/io/endpoint/generic.rb#120
  def wrapper; end

  class << self
    # Create an Endpoint instance by URI scheme. The host and port of the URI will be passed to the Endpoint factory method, along with any options.
    #
    # You should not use untrusted input as it may execute arbitrary code.
    #
    # @see Endpoint.ssl ssl - invoked when parsing a URL with the ssl scheme "ssl://127.0.0.1"
    # @see Endpoint.tcp tcp - invoked when parsing a URL with the tcp scheme: "tcp://127.0.0.1"
    # @see Endpoint.udp udp - invoked when parsing a URL with the udp scheme: "udp://127.0.0.1"
    # @see Endpoint.unix unix - invoked when parsing a URL with the unix scheme: "unix://127.0.0.1"
    #
    # source://io-endpoint//lib/io/endpoint/generic.rb#113
    def parse(string, **options); end
  end
end

# Represents an endpoint for a hostname and service that resolves to multiple addresses.
#
# source://io-endpoint//lib/io/endpoint/host_endpoint.rb#10
class IO::Endpoint::HostEndpoint < ::IO::Endpoint::Generic
  # Initialize a new host endpoint.
  #
  # @return [HostEndpoint] a new instance of HostEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#14
  def initialize(specification, **options); end

  # Invokes the given block for every address which can be bound to.
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#81
  def bind(wrapper = T.unsafe(nil), &block); end

  # Try to connect to the given host by connecting to each address in sequence until a connection is made.
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#54
  def connect(wrapper = T.unsafe(nil), &block); end

  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#89
  def each; end

  # Get the hostname from the specification.
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#39
  def hostname; end

  # Get a detailed string representation of the host endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#28
  def inspect; end

  # Get the service from the specification.
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#45
  def service; end

  # Returns the value of attribute specification.
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#35
  def specification; end

  # Get a string representation of the host endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/host_endpoint.rb#22
  def to_s; end
end

# Represents an SSL/TLS endpoint that wraps another endpoint.
#
# source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#101
class IO::Endpoint::SSLEndpoint < ::IO::Endpoint::Generic
  # Initialize a new SSL endpoint.
  #
  # @option ssl_context
  # @param ssl_context [Hash] a customizable set of options
  # @return [SSLEndpoint] a new instance of SSLEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#106
  def initialize(endpoint, **options); end

  # Get the address from the underlying endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#132
  def address; end

  # Connect to the underlying endpoint and establish a SSL connection.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#196
  def bind(*arguments, **options, &block); end

  # Build an SSL context with configured parameters.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#156
  def build_context(context = T.unsafe(nil)); end

  # Connect to the underlying endpoint and establish a SSL connection.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#212
  def connect(&block); end

  # Get or build the SSL context.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#169
  def context; end

  # Enumerate all endpoints by wrapping each underlying endpoint with SSL.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#238
  def each; end

  # Returns the value of attribute endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#143
  def endpoint; end

  # Get the hostname for SSL verification.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#138
  def hostname; end

  # Get a detailed string representation of the SSL endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#126
  def inspect; end

  # Create an SSL server socket from an IO object.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#176
  def make_server(io); end

  # Create an SSL client socket from an IO object.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#185
  def make_socket(io); end

  # Returns the value of attribute options.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#145
  def options; end

  # Get SSL parameters from options.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#149
  def params; end

  # Get a string representation of the SSL endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#120
  def to_s; end
end

# This class doesn't exert ownership over the specified socket, wraps a native ::IO.
#
# source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#10
class IO::Endpoint::SocketEndpoint < ::IO::Endpoint::Generic
  # Initialize a new socket endpoint.
  #
  # @return [SocketEndpoint] a new instance of SocketEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#14
  def initialize(socket, **options); end

  # Bind using the wrapped socket.
  #
  # source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#39
  def bind(&block); end

  # Connect using the wrapped socket.
  #
  # source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#51
  def connect(&block); end

  # Get a detailed string representation of the socket endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#28
  def inspect; end

  # Returns the value of attribute socket.
  #
  # source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#33
  def socket; end

  # Get a string representation of the socket endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/socket_endpoint.rb#22
  def to_s; end
end

# This class doesn't exert ownership over the specified unix socket and ensures exclusive access by using `flock` where possible.
#
# source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#15
class IO::Endpoint::UNIXEndpoint < ::IO::Endpoint::AddressEndpoint
  # Initialize a new UNIX domain socket endpoint.
  #
  # @return [UNIXEndpoint] a new instance of UNIXEndpoint
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#31
  def initialize(path, type = T.unsafe(nil), **options); end

  # Bind the UNIX socket, handling stale socket files.
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#93
  def bind(*_arg0, **_arg1, &_arg2); end

  # Check if the socket is currently bound and accepting connections.
  #
  # @return [Boolean]
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#78
  def bound?; end

  # Get a detailed string representation of the UNIX endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#52
  def inspect; end

  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#63
  def path; end

  # Check if a symlink is used for this endpoint.
  #
  # A symlink is created when the original path exceeds the system's maximum UNIX socket path length and a shorter temporary path is used for the actual socket.
  #
  # @return [Boolean]
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#72
  def symlink?; end

  # Get a string representation of the UNIX endpoint.
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#46
  def to_s; end

  private

  # Create a symlink to the actual socket path if required.
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#119
  def create_symlink_if_required!; end

  # Read a symlink, returning nil if the file does not exist.
  #
  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#111
  def read_link(path); end

  # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#140
  def unlink_stale_paths!; end

  class << self
    # Compute a stable temporary UNIX socket path for an overlong path.
    #
    # source://io-endpoint//lib/io/endpoint/unix_endpoint.rb#19
    def short_path_for(path); end
  end
end

# source://io-endpoint//lib/io/endpoint/version.rb#10
IO::Endpoint::VERSION = T.let(T.unsafe(nil), String)

# Represents a wrapper for socket operations that provides scheduling and configuration.
#
# source://io-endpoint//lib/io/endpoint/wrapper.rb#10
class IO::Endpoint::Wrapper
  include ::Socket::Constants

  # Bind to a local address and accept connections in a loop.
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#203
  def accept(server, timeout: T.unsafe(nil), linger: T.unsafe(nil), **options, &block); end

  # Legacy method for compatibility with older code.
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#36
  def async(&block); end

  # Bind to a local address.
  #
  # @example
  #   socket = Async::IO::Socket.bind(Async::IO::Address.tcp("0.0.0.0", 9090))
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#144
  def bind(local_address, protocol: T.unsafe(nil), reuse_address: T.unsafe(nil), reuse_port: T.unsafe(nil), linger: T.unsafe(nil), bound_timeout: T.unsafe(nil), backlog: T.unsafe(nil), **options, &block); end

  # Establish a connection to a given `remote_address`.
  #
  # @example
  #   socket = Async::IO::Socket.connect(Async::IO::Address.tcp("8.8.8.8", 53))
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#82
  def connect(remote_address, local_address: T.unsafe(nil), linger: T.unsafe(nil), timeout: T.unsafe(nil), buffered: T.unsafe(nil), **options); end

  # Schedule a block to run asynchronously.
  # Uses Thread for scheduling.
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#18
  def schedule(&block); end

  # Set whether a socket should be buffered.
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#52
  def set_buffered(socket, buffered); end

  # Set the timeout for an IO object.
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#43
  def set_timeout(io, timeout); end

  # Accept a connection from a bound socket.
  # This is an extension point for subclasses to provide additional functionality.
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#198
  def socket_accept(server); end

  # Connect a socket to a remote address.
  # This is an extension point for subclasses to provide additional functionality.
  #
  # source://io-endpoint//lib/io/endpoint/wrapper.rb#72
  def socket_connect(socket, remote_address); end

  class << self
    # Get the default wrapper instance.
    #
    # source://io-endpoint//lib/io/endpoint/wrapper.rb#240
    def default; end
  end
end

# source://io-endpoint//lib/io/endpoint/wrapper.rb#236
IO::Endpoint::Wrapper::DEFAULT = T.let(T.unsafe(nil), IO::Endpoint::Wrapper)

# source://io-endpoint//lib/io/endpoint/wrapper.rb#133
IO::Endpoint::Wrapper::ServerSocket = Socket

IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::Constructive < ::OpenSSL::ASN1::ASN1Data
  include ::Enumerable
end

class OpenSSL::Config
  include ::Enumerable
end

class OpenSSL::Provider; end
class OpenSSL::Provider::ProviderError < ::OpenSSL::OpenSSLError; end

class OpenSSL::SSL::SSLErrorWaitReadable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitReadable
end

class OpenSSL::SSL::SSLErrorWaitWritable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitWritable
end

# Represents an SSL socket with additional methods for compatibility.
#
# source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#16
class OpenSSL::SSL::SSLSocket
  include ::Enumerable

  # Start the SSL handshake (alias for accept).
  #
  # source://io-endpoint//lib/io/endpoint/ssl_endpoint.rb#19
  def start; end
end

module OpenSSL::Timestamp; end
class OpenSSL::Timestamp::Factory; end
class OpenSSL::Timestamp::Request; end
class OpenSSL::Timestamp::Response; end
class OpenSSL::Timestamp::TimestampError < ::OpenSSL::OpenSSLError; end
class OpenSSL::Timestamp::TokenInfo; end
