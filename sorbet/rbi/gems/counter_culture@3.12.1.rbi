# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `counter_culture` gem.
# Please instead update this file by running `bin/tapioca gem counter_culture`.


# source://counter_culture//lib/counter_culture/version.rb#1
module CounterCulture
  # source://counter_culture//lib/counter_culture.rb#12
  def batch_size; end

  # source://counter_culture//lib/counter_culture.rb#12
  def batch_size=(val); end

  class << self
    # source://counter_culture//lib/counter_culture.rb#20
    def aggregate_counter_updates; end

    # source://counter_culture//lib/counter_culture.rb#12
    def batch_size; end

    # source://counter_culture//lib/counter_culture.rb#12
    def batch_size=(val); end

    # @yield [_self]
    # @yieldparam _self [CounterCulture] the object that the method was called on
    #
    # source://counter_culture//lib/counter_culture.rb#15
    def config; end

    # source://counter_culture//lib/counter_culture/configuration.rb#2
    def configuration; end

    # @yield [configuration]
    #
    # source://counter_culture//lib/counter_culture/configuration.rb#6
    def configure; end

    # source://counter_culture//lib/counter_culture/configuration.rb#10
    def reset_configuration; end

    # @return [Boolean]
    #
    # source://counter_culture//lib/counter_culture/configuration.rb#14
    def supports_composite_keys?; end
  end
end

# source://counter_culture//lib/counter_culture/configuration.rb#18
class CounterCulture::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://counter_culture//lib/counter_culture/configuration.rb#21
  def initialize; end

  # Returns the value of attribute use_read_replica.
  #
  # source://counter_culture//lib/counter_culture/configuration.rb#19
  def use_read_replica; end

  # source://counter_culture//lib/counter_culture/configuration.rb#25
  def use_read_replica=(value); end

  private

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/configuration.rb#34
  def rails_supports_read_replica?; end
end

# source://counter_culture//lib/counter_culture/counter.rb#4
class CounterCulture::Counter
  # @return [Counter] a new instance of Counter
  #
  # source://counter_culture//lib/counter_culture/counter.rb#10
  def initialize(model, relation, options); end

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/counter.rb#302
  def attribute_changed?(obj, attr); end

  # increments or decrements a counter cache
  #
  # options:
  #   :increment => true to increment, false to decrement
  #   :relation => which relation to increment the count on,
  #   :counter_cache_name => the column name of the counter cache
  #   :counter_column => overrides :counter_cache_name
  #   :delta_column => override the default count delta (1) with the value of this column in the counted record
  #   :was => whether to get the current value or the old value of the
  #      first part of the relation
  #   :with_papertrail => update the column via Papertrail touch_with_version method
  #
  # source://counter_culture//lib/counter_culture/counter.rb#46
  def change_counter_cache(obj, options); end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def column_names; end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def counter_cache_name; end

  # Gets the name of the counter cache for a specific object
  #
  # obj: object to calculate the counter cache name for
  # cache_name_finder: object used to calculate the cache name
  #
  # source://counter_culture//lib/counter_culture/counter.rb#186
  def counter_cache_name_for(obj); end

  # Gets the delta magnitude of the counter cache for a specific object
  #
  # obj: object to calculate the counter cache name for
  #
  # source://counter_culture//lib/counter_culture/counter.rb#174
  def counter_delta_magnitude_for(obj); end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def delta_column; end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def delta_magnitude; end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def execute_after_commit; end

  # source://counter_culture//lib/counter_culture/counter.rb#382
  def execute_now_or_after_commit(obj, &block); end

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/counter.rb#294
  def first_level_relation_changed?(instance); end

  # gets the foreign key name of the relation. will look at the first
  # level only -- i.e., if passed an array will consider only its
  # first element
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  #
  # source://counter_culture//lib/counter_culture/counter.rb#355
  def first_level_relation_foreign_key; end

  # source://counter_culture//lib/counter_culture/counter.rb#360
  def first_level_relation_foreign_type; end

  # gets the value of the foreign key on the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  # was: whether to get the current or past value from ActiveRecord;
  #   pass true to get the past value, false or nothing to get the
  #   current value
  #
  # source://counter_culture//lib/counter_culture/counter.rb#209
  def foreign_key_value(obj, relation, was = T.unsafe(nil)); end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def foreign_key_values; end

  # the string to pass to order() in order to sort by primary key
  #
  # source://counter_culture//lib/counter_culture/counter.rb#198
  def full_primary_key(klass); end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def model; end

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/counter.rb#310
  def polymorphic?; end

  # source://counter_culture//lib/counter_culture/counter.rb#366
  def previous_model(obj); end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def relation; end

  # gets the foreign key name of the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  #
  # source://counter_culture//lib/counter_culture/counter.rb#322
  def relation_foreign_key(relation); end

  # gets the class of the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  # source [optional]: the source object,
  #   only needed for polymorphic associations,
  #   probably only works with a single relation (symbol, or array of 1 symbol)
  # was: boolean
  #   we're actually looking for the old value -- only can change for polymorphic relations
  #
  # source://counter_culture//lib/counter_culture/counter.rb#276
  def relation_klass(relation, source: T.unsafe(nil), was: T.unsafe(nil)); end

  # gets the primary key name of the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  # source[optional]: the model instance that the relationship is linked from,
  #   only needed for polymorphic associations,
  #   probably only works with a single relation (symbol, or array of 1 symbol)
  # was: boolean
  #   we're actually looking for the old value -- only can change for polymorphic relations
  #
  # source://counter_culture//lib/counter_culture/counter.rb#335
  def relation_primary_key(relation, source: T.unsafe(nil), was: T.unsafe(nil)); end

  # gets the reflect object on the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  #
  # source://counter_culture//lib/counter_culture/counter.rb#263
  def relation_reflect(relation); end

  # gets the reflect object on the given relation and the model that defines this reflect
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  #
  # source://counter_culture//lib/counter_culture/counter.rb#237
  def relation_reflect_and_model(relation); end

  # source://counter_culture//lib/counter_culture/counter.rb#8
  def touch; end

  private

  # update associated object counter attribute
  #
  # source://counter_culture//lib/counter_culture/counter.rb#405
  def assign_to_associated_object(obj, relation, change_counter_column, operator, delta_magnitude); end

  # source://counter_culture//lib/counter_culture/counter.rb#435
  def association_object_clear_change(association_object, change_counter_column); end

  # source://counter_culture//lib/counter_culture/counter.rb#418
  def association_object_for_assign(obj, association_name); end

  # source://counter_culture//lib/counter_culture/counter.rb#443
  def association_object_new_counter(association_object, change_counter_column, operator, delta_magnitude); end

  # source://counter_culture//lib/counter_culture/counter.rb#394
  def attribute_was(obj, attr); end

  # source://counter_culture//lib/counter_culture/counter.rb#447
  def primary_key_conditions(primary_key, fk_value); end

  # source://counter_culture//lib/counter_culture/counter.rb#475
  def remember_counter_update(klass, id, column, delta, column_type); end

  # source://counter_culture//lib/counter_culture/counter.rb#483
  def remember_timestamp_update(klass, id, column); end

  class << self
    # Builds an Arel expression for counter updates: COALESCE(col, 0) +/- delta
    # This is a class method so it can be called from CounterCulture.aggregate_counter_updates
    #
    # source://counter_culture//lib/counter_culture/counter.rb#455
    def build_arel_counter_expr(klass, column, delta, column_type); end
  end
end

# source://counter_culture//lib/counter_culture/counter.rb#6
CounterCulture::Counter::ACTIVE_RECORD_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://counter_culture//lib/counter_culture/counter.rb#5
CounterCulture::Counter::CONFIG_OPTIONS = T.let(T.unsafe(nil), Array)

# source://counter_culture//lib/counter_culture/extensions.rb#2
module CounterCulture::Extensions
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::CounterCulture::Extensions::ClassMethods

  private

  # called by after_create callback
  #
  # source://counter_culture//lib/counter_culture/extensions.rb#108
  def _update_counts_after_create; end

  # called by after_destroy callback
  #
  # source://counter_culture//lib/counter_culture/extensions.rb#116
  def _update_counts_after_destroy; end

  # called by after_update callback
  #
  # source://counter_culture//lib/counter_culture/extensions.rb#126
  def _update_counts_after_update; end

  # check if record is soft-deleted
  #
  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/extensions.rb#146
  def destroyed_for_counter_culture?; end
end

# source://counter_culture//lib/counter_culture/extensions.rb#5
module CounterCulture::Extensions::ClassMethods
  # this holds all configuration data
  #
  # source://counter_culture//lib/counter_culture/extensions.rb#7
  def after_commit_counter_cache; end

  # called to configure counter caches
  #
  # source://counter_culture//lib/counter_culture/extensions.rb#16
  def counter_culture(relation, options = T.unsafe(nil)); end

  # checks all of the declared counter caches on this class for correctnes based
  # on original data; if the counter cache is incorrect, sets it to the correct
  # count
  #
  # options:
  #   { :exclude => list of relations to skip when fixing counts,
  #     :only => only these relations will have their counts fixed,
  #     :column_name => only this column will have its count fixed
  #     :polymorphic_classes => specify the class(es) to update in polymorphic associations }
  # returns: a list of fixed record as an array of hashes of the form:
  #   { :entity => which model the count was fixed on,
  #     :id => the id of the model that had the incorrect count,
  #     :what => which column contained the incorrect count,
  #     :wrong => the previously saved, incorrect count,
  #     :right => the newly fixed, correct count }
  #
  # source://counter_culture//lib/counter_culture/extensions.rb#75
  def counter_culture_fix_counts(options = T.unsafe(nil)); end

  # source://counter_culture//lib/counter_culture/extensions.rb#95
  def skip_counter_culture_updates; end
end

# source://counter_culture//lib/counter_culture/reconciler.rb#7
class CounterCulture::Reconciler
  # @return [Reconciler] a new instance of Reconciler
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#15
  def initialize(counter, options = T.unsafe(nil)); end

  # Returns the value of attribute changes.
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#10
  def changes; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#13
  def column_names(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute counter.
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#10
  def counter; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#13
  def counter_cache_name(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#13
  def delta_column(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#13
  def delta_magnitude(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#13
  def execute_after_commit(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#13
  def foreign_key_values(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#12
  def full_primary_key(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#12
  def model(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#10
  def options; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#12
  def polymorphic?(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#22
  def reconcile!; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#12
  def relation(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#12
  def relation_reflect(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#13
  def touch(*_arg0, **_arg1, &_arg2); end

  private

  # source://counter_culture//lib/counter_culture/reconciler.rb#55
  def associated_model_class; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#42
  def associated_model_classes; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#50
  def polymorphic_associated_model_classes; end
end

# source://counter_culture//lib/counter_culture/reconciler.rb#8
CounterCulture::Reconciler::ACTIVE_RECORD_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://counter_culture//lib/counter_culture/reconciler.rb#59
class CounterCulture::Reconciler::Reconciliation
  # @return [Reconciliation] a new instance of Reconciliation
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#65
  def initialize(counter, changes_holder, options, relation_class); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#63
  def column_names(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute counter.
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#60
  def counter; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#63
  def counter_cache_name(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#63
  def delta_column(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#63
  def delta_magnitude(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#63
  def execute_after_commit(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#63
  def foreign_key_values(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#62
  def full_primary_key(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#62
  def model(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#60
  def options; end

  # @raise [ArgumentError]
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#72
  def perform; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#62
  def polymorphic?(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#62
  def relation(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute relation_class.
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#60
  def relation_class; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#62
  def relation_reflect(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#62
  def relation_reflect_and_model(*_arg0, **_arg1, &_arg2); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#63
  def touch(*_arg0, **_arg1, &_arg2); end

  private

  # source://counter_culture//lib/counter_culture/reconciler.rb#233
  def association_primary_key_select; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#211
  def count_select; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#250
  def join_clauses(where); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#183
  def log(message); end

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#195
  def log?; end

  # source://counter_culture//lib/counter_culture/reconciler.rb#189
  def log_without_newline(message); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#349
  def parameterize(string); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#228
  def primary_key_select; end

  # This is only needed in relatively unusal cases, for example if you are
  # using Postgres with schema-namespaced tables. But then it's required,
  # and otherwise it's just a no-op, so why not do it?
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#343
  def quote_table_name(table_name); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#239
  def self_table_name; end

  # keep track of what we fixed, e.g. for a notification email
  #
  # source://counter_culture//lib/counter_culture/reconciler.rb#200
  def track_change(record, column_name, count); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#150
  def update_count_for_batch(column_name, records); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#357
  def with_reading_db_connection(&block); end

  # source://counter_culture//lib/counter_culture/reconciler.rb#367
  def with_writing_db_connection(&block); end
end

# source://counter_culture//lib/counter_culture/skip_updates.rb#2
module CounterCulture::SkipUpdates
  private

  # called by after_create callback
  #
  # source://counter_culture//lib/counter_culture/skip_updates.rb#6
  def _update_counts_after_create; end

  # called by after_destroy callback
  #
  # source://counter_culture//lib/counter_culture/skip_updates.rb#13
  def _update_counts_after_destroy; end

  # called by after_update callback
  #
  # source://counter_culture//lib/counter_culture/skip_updates.rb#20
  def _update_counts_after_update; end
end

# source://counter_culture//lib/counter_culture/version.rb#2
CounterCulture::VERSION = T.let(T.unsafe(nil), String)

# source://counter_culture//lib/counter_culture/with_connection.rb#2
class CounterCulture::WithConnection
  # @return [WithConnection] a new instance of WithConnection
  #
  # source://counter_culture//lib/counter_culture/with_connection.rb#3
  def initialize(recipient); end

  # source://counter_culture//lib/counter_culture/with_connection.rb#9
  def call(reading: T.unsafe(nil)); end

  # Returns the value of attribute recipient.
  #
  # source://counter_culture//lib/counter_culture/with_connection.rb#7
  def recipient; end

  private

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/with_connection.rb#43
  def rails_7_1?; end

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/with_connection.rb#35
  def rails_7_1_or_greater?; end

  # @return [Boolean]
  #
  # source://counter_culture//lib/counter_culture/with_connection.rb#39
  def rails_7_2_or_greater?; end

  # source://counter_culture//lib/counter_culture/with_connection.rb#25
  def yield_with_connection; end
end
