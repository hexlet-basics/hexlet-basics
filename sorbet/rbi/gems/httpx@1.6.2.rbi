# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `httpx` gem.
# Please instead update this file by running `bin/tapioca gem httpx`.


# source://httpx//lib/httpx/adapters/faraday.rb#7
module Faraday; end

# source://httpx//lib/httpx/adapters/faraday.rb#8
class Faraday::Adapter; end

# source://httpx//lib/httpx/adapters/faraday.rb#9
class Faraday::Adapter::HTTPX < ::Faraday::Adapter
  include ::Faraday::Adapter::HTTPX::RequestMixin

  # @return [HTTPX] a new instance of HTTPX
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#10
  def initialize(app = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://httpx//lib/httpx/adapters/faraday.rb#257
  def call(env); end

  private

  # source://httpx//lib/httpx/adapters/faraday.rb#283
  def connect_and_request(env); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#296
  def parallel?(env); end

  class << self
    # source://httpx//lib/httpx/adapters/faraday.rb#252
    def setup_parallel_manager(options = T.unsafe(nil)); end
  end
end

# source://httpx//lib/httpx/adapters/faraday.rb#128
module Faraday::Adapter::HTTPX::OnDataPlugin; end

# source://httpx//lib/httpx/adapters/faraday.rb#129
module Faraday::Adapter::HTTPX::OnDataPlugin::RequestMethods
  # source://httpx//lib/httpx/adapters/faraday.rb#132
  def response=(response); end

  # Sets the attribute response_on_data
  #
  # @param value the value to set the attribute response_on_data to.
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#130
  def response_on_data=(_arg0); end
end

# source://httpx//lib/httpx/adapters/faraday.rb#143
module Faraday::Adapter::HTTPX::OnDataPlugin::ResponseBodyMethods
  # Sets the attribute on_data
  #
  # @param value the value to set the attribute on_data to.
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#144
  def on_data=(_arg0); end

  # source://httpx//lib/httpx/adapters/faraday.rb#146
  def write(chunk); end
end

# source://httpx//lib/httpx/adapters/faraday.rb#166
class Faraday::Adapter::HTTPX::ParallelManager
  include ::Faraday::Adapter::HTTPX::RequestMixin

  # @return [ParallelManager] a new instance of ParallelManager
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#198
  def initialize(options); end

  # source://httpx//lib/httpx/adapters/faraday.rb#203
  def enqueue(request); end

  # source://httpx//lib/httpx/adapters/faraday.rb#209
  def run; end

  private

  # from Faraday::Adapter#connection
  #
  # @yield [conn]
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#235
  def connection(env); end

  # from Faraday::Adapter#request_timeout
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#243
  def request_timeout(type, options); end
end

# source://httpx//lib/httpx/adapters/faraday.rb#167
class Faraday::Adapter::HTTPX::ParallelManager::ResponseHandler < ::SimpleDelegator
  # @return [ResponseHandler] a new instance of ResponseHandler
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#170
  def initialize(env); end

  # Returns the value of attribute env.
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#168
  def env; end

  # source://httpx//lib/httpx/adapters/faraday.rb#186
  def on_complete(&blk); end

  # source://httpx//lib/httpx/adapters/faraday.rb#175
  def on_response(&blk); end
end

# source://httpx//lib/httpx/adapters/faraday.rb#154
module Faraday::Adapter::HTTPX::ReasonPlugin
  class << self
    # source://httpx//lib/httpx/adapters/faraday.rb#155
    def load_dependencies(*_arg0); end
  end
end

# source://httpx//lib/httpx/adapters/faraday.rb#159
module Faraday::Adapter::HTTPX::ReasonPlugin::ResponseMethods
  # source://httpx//lib/httpx/adapters/faraday.rb#160
  def reason; end
end

# source://httpx//lib/httpx/adapters/faraday.rb#15
module Faraday::Adapter::HTTPX::RequestMixin
  # source://httpx//lib/httpx/adapters/faraday.rb#16
  def build_connection(env); end

  # source://httpx//lib/httpx/adapters/faraday.rb#42
  def close; end

  private

  # source://httpx//lib/httpx/adapters/faraday.rb#66
  def build_request(env); end

  # source://httpx//lib/httpx/adapters/faraday.rb#49
  def connect(env, &blk); end

  # source://httpx//lib/httpx/adapters/faraday.rb#77
  def options_from_env(env); end

  # :nocov:
  #
  # source://httpx//lib/httpx/adapters/faraday.rb#99
  def ssl_options_from_env(env); end
end

# Top-Level Namespace
#
# source://httpx//lib/httpx/version.rb#3
module HTTPX
  extend ::HTTPX::Chainable
end

# source://httpx//lib/httpx/altsvc.rb#6
module HTTPX::AltSvc
  private

  # source://httpx//lib/httpx/altsvc.rb#64
  def cached_altsvc(origin); end

  # source://httpx//lib/httpx/altsvc.rb#71
  def cached_altsvc_set(origin, entry); end

  # source://httpx//lib/httpx/altsvc.rb#91
  def emit(request, response); end

  # source://httpx//lib/httpx/altsvc.rb#82
  def lookup(origin, ttl); end

  # source://httpx//lib/httpx/altsvc.rb#120
  def parse(altsvc); end

  # source://httpx//lib/httpx/altsvc.rb#153
  def parse_altsvc_origin(alt_proto, alt_origin); end

  # source://httpx//lib/httpx/altsvc.rb#144
  def parse_altsvc_scheme(alt_proto); end

  class << self
    # source://httpx//lib/httpx/altsvc.rb#64
    def cached_altsvc(origin); end

    # source://httpx//lib/httpx/altsvc.rb#71
    def cached_altsvc_set(origin, entry); end

    # source://httpx//lib/httpx/altsvc.rb#91
    def emit(request, response); end

    # source://httpx//lib/httpx/altsvc.rb#82
    def lookup(origin, ttl); end

    # source://httpx//lib/httpx/altsvc.rb#120
    def parse(altsvc); end

    # source://httpx//lib/httpx/altsvc.rb#153
    def parse_altsvc_origin(alt_proto, alt_origin); end

    # source://httpx//lib/httpx/altsvc.rb#144
    def parse_altsvc_scheme(alt_proto); end
  end
end

# makes connections able to accept requests destined to primary service.
#
# source://httpx//lib/httpx/altsvc.rb#8
module HTTPX::AltSvc::ConnectionMixin
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#17
  def match?(uri, options); end

  # source://httpx//lib/httpx/altsvc.rb#11
  def send(request); end

  private

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#43
  def altsvc_match?(uri, other_uri); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#35
  def match_altsvc_options?(uri, options); end

  # checks if this is connection is an alternative service of
  # +uri+
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#27
  def match_altsvcs?(uri); end
end

# source://httpx//lib/httpx/extensions.rb#6
module HTTPX::ArrayExtensions; end

# source://httpx//lib/httpx/extensions.rb#7
module HTTPX::ArrayExtensions::FilterMap; end

# source://httpx//lib/httpx/extensions.rb#21
module HTTPX::ArrayExtensions::Intersect; end

# Internal class to abstract a string buffer, by wrapping a string and providing the
# minimum possible API and functionality required.
#
#     buffer = Buffer.new(640)
#     buffer.full? #=> false
#     buffer << "aa"
#     buffer.capacity #=> 638
#
# source://httpx//lib/httpx/buffer.rb#14
class HTTPX::Buffer
  extend ::Forwardable

  # @return [Buffer] a new instance of Buffer
  #
  # source://httpx//lib/httpx/buffer.rb#32
  def initialize(limit); end

  # source://httpx//lib/httpx/buffer.rb#37
  def <<(chunk); end

  # source://httpx//lib/httpx/buffer.rb#23
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#53
  def capacity; end

  # source://httpx//lib/httpx/buffer.rb#25
  def clear(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#21
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/buffer.rb#49
  def full?; end

  # Returns the value of attribute limit.
  #
  # source://httpx//lib/httpx/buffer.rb#29
  def limit; end

  # source://httpx//lib/httpx/buffer.rb#27
  def replace(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#57
  def shift!(fin); end

  # source://httpx//lib/httpx/buffer.rb#17
  def to_s(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#19
  def to_str(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/callbacks.rb#4
module HTTPX::Callbacks
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/callbacks.rb#22
  def callbacks_for?(type); end

  # source://httpx//lib/httpx/callbacks.rb#17
  def emit(type, *args); end

  # source://httpx//lib/httpx/callbacks.rb#5
  def on(type, &action); end

  # source://httpx//lib/httpx/callbacks.rb#10
  def once(type, &block); end

  protected

  # source://httpx//lib/httpx/callbacks.rb#28
  def callbacks(type = T.unsafe(nil)); end
end

# Session mixin, implements most of the APIs that the users call.
# delegates to a default session when extended.
#
# source://httpx//lib/httpx/chainable.rb#6
module HTTPX::Chainable
  # source://httpx//lib/httpx/chainable.rb#20
  def accept(type); end

  # source://httpx//lib/httpx/chainable.rb#8
  def connect(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#8
  def delete(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#8
  def get(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#8
  def head(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#8
  def options(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#8
  def patch(*uri, **options); end

  # returns a new instance loaded with the +pl+ plugin and +options+.
  #
  # source://httpx//lib/httpx/chainable.rb#30
  def plugin(pl, options = T.unsafe(nil), &blk); end

  # source://httpx//lib/httpx/chainable.rb#8
  def post(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#8
  def put(*uri, **options); end

  # delegates to the default session (see HTTPX::Session#request).
  #
  # source://httpx//lib/httpx/chainable.rb#16
  def request(*args, **options); end

  # source://httpx//lib/httpx/chainable.rb#8
  def trace(*uri, **options); end

  # returns a new instance loaded with +options+.
  #
  # source://httpx//lib/httpx/chainable.rb#38
  def with(options, &blk); end

  # delegates to the default session (see HTTPX::Session#wrap).
  #
  # source://httpx//lib/httpx/chainable.rb#25
  def wrap(&blk); end

  private

  # returns a default instance of HTTPX::Session.
  #
  # source://httpx//lib/httpx/chainable.rb#50
  def branch(options, &blk); end

  # returns default instance of HTTPX::Options.
  #
  # source://httpx//lib/httpx/chainable.rb#45
  def default_options; end

  # source://httpx//lib/httpx/chainable.rb#56
  def method_missing(meth, *args, **options, &blk); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/chainable.rb#84
  def respond_to_missing?(meth, *_arg1); end
end

# Error raised when there was a timeout establishing the connection to a server.
# This may be raised due to timeouts during TCP and TLS (when applicable) connection
# establishment.
#
# source://httpx//lib/httpx/errors.rb#38
class HTTPX::ConnectTimeoutError < ::HTTPX::TimeoutError; end

# The Connection can be watched for IO events.
#
# It contains the +io+ object to read/write from, and knows what to do when it can.
#
# It defers connecting until absolutely necessary. Connection should be triggered from
# the IO selector (until then, any request will be queued).
#
# A connection boots up its parser after connection is established. All pending requests
# will be redirected there after connection.
#
# A connection can be prevented from closing by the parser, that is, if there are pending
# requests. This will signal that the connection was prematurely closed, due to a possible
# number of conditions:
#
# * Remote peer closed the connection ("Connection: close");
# * Remote peer doesn't support pipelining;
#
# A connection may also route requests for a different host for which the +io+ was connected
# to, provided that the IP is the same and the port and scheme as well. This will allow to
# share the same socket to send HTTP/2 requests to different hosts.
#
# source://httpx//lib/httpx/connection.rb#30
class HTTPX::Connection
  include ::HTTPX::Loggable
  include ::HTTPX::Callbacks
  extend ::Forwardable

  # @return [Connection] a new instance of Connection
  #
  # source://httpx//lib/httpx/connection.rb#49
  def initialize(uri, options); end

  # source://httpx//lib/httpx/connection.rb#121
  def addresses; end

  # this is a semi-private method, to be used by the resolver
  # to initiate the io object.
  #
  # source://httpx//lib/httpx/connection.rb#113
  def addresses=(addrs); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#125
  def addresses?; end

  # source://httpx//lib/httpx/connection.rb#242
  def call; end

  # source://httpx//lib/httpx/connection.rb#266
  def close; end

  # source://httpx//lib/httpx/connection.rb#37
  def closed?(*args, **_arg1, &block); end

  # coalescable connections need to be mergeable!
  # but internally, #mergeable? is called before #coalescable?
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#163
  def coalescable?(connection); end

  # coalesces +self+ into +connection+.
  #
  # source://httpx//lib/httpx/connection.rb#154
  def coalesce!(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#209
  def connecting?; end

  # source://httpx//lib/httpx/connection.rb#174
  def create_idle(options = T.unsafe(nil)); end

  # Sets the attribute current_selector
  #
  # @param value the value to set the attribute current_selector to.
  #
  # source://httpx//lib/httpx/connection.rb#43
  def current_selector=(_arg0); end

  # Returns the value of attribute current_session.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def current_session; end

  # Sets the attribute current_session
  #
  # @param value the value to set the attribute current_session to.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def current_session=(_arg0); end

  # source://httpx//lib/httpx/connection.rb#344
  def deactivate; end

  # source://httpx//lib/httpx/connection.rb#378
  def disconnect; end

  # source://httpx//lib/httpx/connection.rb#39
  def empty?(*args, **_arg1, &block); end

  # Returns the value of attribute family.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def family; end

  # Sets the attribute family
  #
  # @param value the value to set the attribute family to.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def family=(_arg0); end

  # bypasses the state machine to force closing of connections still connecting.
  # **only** used for Happy Eyeballs v2.
  #
  # source://httpx//lib/httpx/connection.rb#286
  def force_reset(cloned = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#370
  def handle_connect_error(error); end

  # source://httpx//lib/httpx/connection.rb#352
  def handle_socket_timeout(interval); end

  # source://httpx//lib/httpx/connection.rb#333
  def idling; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#213
  def inflight?; end

  # :nocov:
  #
  # source://httpx//lib/httpx/connection.rb#386
  def inspect; end

  # source://httpx//lib/httpx/connection.rb#222
  def interests; end

  # Returns the value of attribute io.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def io; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#203
  def io_connected?; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#129
  def match?(uri, options); end

  # source://httpx//lib/httpx/connection.rb#178
  def merge(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#142
  def mergeable?(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#348
  def open?; end

  # Returns the value of attribute options.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def options; end

  # Returns the value of attribute origin.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def origin; end

  # Returns the value of attribute origins.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def origins; end

  # source://httpx//lib/httpx/connection.rb#107
  def peer; end

  # Returns the value of attribute pending.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def pending; end

  # source://httpx//lib/httpx/connection.rb#191
  def purge_pending(&block); end

  # source://httpx//lib/httpx/connection.rb#292
  def reset; end

  # source://httpx//lib/httpx/connection.rb#300
  def send(request); end

  # source://httpx//lib/httpx/connection.rb#358
  def sibling=(connection); end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def state; end

  # source://httpx//lib/httpx/connection.rb#272
  def terminate; end

  # source://httpx//lib/httpx/connection.rb#323
  def timeout; end

  # source://httpx//lib/httpx/connection.rb#238
  def to_io; end

  # Returns the value of attribute type.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def type; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#340
  def used?; end

  protected

  # Returns the value of attribute sibling.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def sibling; end

  # Returns the value of attribute ssl_session.
  #
  # source://httpx//lib/httpx/connection.rb#41
  def ssl_session; end

  private

  # returns an HTTPX::Connection for the negotiated Alternative Service (or none).
  #
  # source://httpx//lib/httpx/connection.rb#787
  def build_altsvc_connection(alt_origin, origin, alt_params); end

  # source://httpx//lib/httpx/connection.rb#558
  def build_parser(protocol = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#814
  def build_socket(addrs = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#751
  def close_sibling; end

  # source://httpx//lib/httpx/connection.rb#397
  def connect; end

  # source://httpx//lib/httpx/connection.rb#401
  def consume; end

  # source://httpx//lib/httpx/connection.rb#856
  def handle_error(error, request = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#689
  def handle_transition(nextstate); end

  # source://httpx//lib/httpx/connection.rb#773
  def initialize_type(uri, options); end

  # source://httpx//lib/httpx/connection.rb#838
  def on_error(error, request = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#538
  def parser; end

  # source://httpx//lib/httpx/connection.rb#945
  def parser_type(protocol); end

  # source://httpx//lib/httpx/connection.rb#767
  def purge_after_closed; end

  # source://httpx//lib/httpx/connection.rb#919
  def read_timeout_callback(request, read_timeout, error_type = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#532
  def send_pending; end

  # source://httpx//lib/httpx/connection.rb#542
  def send_request_to_parser(request); end

  # source://httpx//lib/httpx/connection.rb#564
  def set_parser_callbacks(parser); end

  # source://httpx//lib/httpx/connection.rb#880
  def set_request_read_timeout(request); end

  # source://httpx//lib/httpx/connection.rb#900
  def set_request_request_timeout(request); end

  # source://httpx//lib/httpx/connection.rb#930
  def set_request_timeout(label, request, timeout, start_event, finish_events, &callback); end

  # source://httpx//lib/httpx/connection.rb#874
  def set_request_timeouts(request); end

  # source://httpx//lib/httpx/connection.rb#890
  def set_request_write_timeout(request); end

  # source://httpx//lib/httpx/connection.rb#660
  def transition(nextstate); end

  # source://httpx//lib/httpx/connection.rb#910
  def write_timeout_callback(request, write_timeout); end
end

# source://httpx//lib/httpx/connection/http1.rb#6
class HTTPX::Connection::HTTP1
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/connection/http1.rb#17
  def initialize(buffer, options); end

  # source://httpx//lib/httpx/connection/http1.rb#70
  def <<(data); end

  # source://httpx//lib/httpx/connection/http1.rb#50
  def close; end

  # source://httpx//lib/httpx/connection/http1.rb#86
  def consume; end

  # source://httpx//lib/httpx/connection/http1.rb#158
  def dispatch; end

  # source://httpx//lib/httpx/connection/http1.rb#59
  def empty?; end

  # source://httpx//lib/httpx/connection/http1.rb#55
  def exhausted?; end

  # source://httpx//lib/httpx/connection/http1.rb#194
  def handle_error(ex, request = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection/http1.rb#33
  def interests; end

  # source://httpx//lib/httpx/connection/http1.rb#15
  def max_concurrent_requests; end

  # source://httpx//lib/httpx/connection/http1.rb#15
  def max_concurrent_requests=(_arg0); end

  # source://httpx//lib/httpx/connection/http1.rb#149
  def on_complete; end

  # source://httpx//lib/httpx/connection/http1.rb#133
  def on_data(chunk); end

  # source://httpx//lib/httpx/connection/http1.rb#105
  def on_headers(h); end

  # source://httpx//lib/httpx/connection/http1.rb#101
  def on_start; end

  # source://httpx//lib/httpx/connection/http1.rb#123
  def on_trailers(h); end

  # source://httpx//lib/httpx/connection/http1.rb#13
  def pending; end

  # source://httpx//lib/httpx/connection/http1.rb#221
  def ping; end

  # source://httpx//lib/httpx/connection/http1.rb#13
  def requests; end

  # source://httpx//lib/httpx/connection/http1.rb#43
  def reset; end

  # source://httpx//lib/httpx/connection/http1.rb#74
  def send(request); end

  # source://httpx//lib/httpx/connection/http1.rb#29
  def timeout; end

  # source://httpx//lib/httpx/connection/http1.rb#227
  def waiting_for_ping?; end

  private

  # source://httpx//lib/httpx/connection/http1.rb#395
  def capitalized(field); end

  # source://httpx//lib/httpx/connection/http1.rb#269
  def disable; end

  # source://httpx//lib/httpx/connection/http1.rb#276
  def disable_pipelining; end

  # source://httpx//lib/httpx/connection/http1.rb#331
  def handle(request); end

  # source://httpx//lib/httpx/connection/http1.rb#358
  def join_body(request); end

  # source://httpx//lib/httpx/connection/http1.rb#348
  def join_headers(request); end

  # source://httpx//lib/httpx/connection/http1.rb#381
  def join_headers2(headers); end

  # source://httpx//lib/httpx/connection/http1.rb#344
  def join_headline(request); end

  # source://httpx//lib/httpx/connection/http1.rb#373
  def join_trailers(request); end

  # source://httpx//lib/httpx/connection/http1.rb#233
  def manage_connection(request, response); end

  # source://httpx//lib/httpx/connection/http1.rb#296
  def set_protocol_headers(request); end
end

# source://httpx//lib/httpx/connection/http1.rb#11
HTTPX::Connection::HTTP1::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/connection/http1.rb#10
HTTPX::Connection::HTTP1::MAX_REQUESTS = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/connection/http1.rb#389
HTTPX::Connection::HTTP1::UPCASED = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/connection/http2.rb#7
class HTTPX::Connection::HTTP2
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/connection/http2.rb#33
  def initialize(buffer, options); end

  # source://httpx//lib/httpx/connection/http2.rb#103
  def <<(data); end

  # source://httpx//lib/httpx/connection/http2.rb#87
  def close; end

  # source://httpx//lib/httpx/connection/http2.rb#125
  def consume; end

  # source://httpx//lib/httpx/connection/http2.rb#95
  def empty?; end

  # source://httpx//lib/httpx/connection/http2.rb#99
  def exhausted?; end

  # source://httpx//lib/httpx/connection/http2.rb#133
  def handle_error(ex, request = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection/http2.rb#54
  def interests; end

  # source://httpx//lib/httpx/connection/http2.rb#31
  def pending; end

  # source://httpx//lib/httpx/connection/http2.rb#153
  def ping; end

  # source://httpx//lib/httpx/connection/http2.rb#210
  def reset; end

  # source://httpx//lib/httpx/connection/http2.rb#107
  def send(request, head = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection/http2.rb#31
  def streams; end

  # source://httpx//lib/httpx/connection/http2.rb#48
  def timeout; end

  # source://httpx//lib/httpx/connection/http2.rb#160
  def waiting_for_ping?; end

  private

  # source://httpx//lib/httpx/connection/http2.rb#166
  def can_buffer_more_requests?; end

  # source://httpx//lib/httpx/connection/http2.rb#286
  def end_stream?(request, next_chunk); end

  # source://httpx//lib/httpx/connection/http2.rb#178
  def handle(request, stream); end

  # source://httpx//lib/httpx/connection/http2.rb#213
  def handle_stream(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#190
  def init_connection; end

  # source://httpx//lib/httpx/connection/http2.rb#259
  def join_body(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#233
  def join_headers(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#247
  def join_trailers(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#436
  def on_altsvc(origin, frame); end

  # source://httpx//lib/httpx/connection/http2.rb#379
  def on_close(_last_frame, error, _payload); end

  # source://httpx//lib/httpx/connection/http2.rb#368
  def on_frame(bytes); end

  # source://httpx//lib/httpx/connection/http2.rb#420
  def on_frame_received(frame); end

  # source://httpx//lib/httpx/connection/http2.rb#404
  def on_frame_sent(frame); end

  # source://httpx//lib/httpx/connection/http2.rb#448
  def on_origin(origin); end

  # source://httpx//lib/httpx/connection/http2.rb#452
  def on_pong(ping); end

  # source://httpx//lib/httpx/connection/http2.rb#444
  def on_promise(stream); end

  # source://httpx//lib/httpx/connection/http2.rb#372
  def on_settings(*_arg0); end

  # source://httpx//lib/httpx/connection/http2.rb#332
  def on_stream_close(stream, request, error); end

  # source://httpx//lib/httpx/connection/http2.rb#321
  def on_stream_data(stream, request, data); end

  # source://httpx//lib/httpx/connection/http2.rb#294
  def on_stream_headers(stream, request, h); end

  # source://httpx//lib/httpx/connection/http2.rb#327
  def on_stream_refuse(stream, request, error); end

  # source://httpx//lib/httpx/connection/http2.rb#314
  def on_stream_trailers(stream, response, h); end

  # source://httpx//lib/httpx/connection/http2.rb#280
  def send_chunk(request, stream, chunk, next_chunk); end

  # source://httpx//lib/httpx/connection/http2.rb#172
  def send_pending; end

  # source://httpx//lib/httpx/connection/http2.rb#224
  def set_protocol_headers(request); end

  # source://httpx//lib/httpx/connection/http2.rb#458
  def teardown(request = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/connection/http2.rb#13
class HTTPX::Connection::HTTP2::Error < ::HTTPX::Error
  # source://httpx//lib/httpx/connection/http2.rb#14
  def initialize(id, error); end
end

# source://httpx//lib/httpx/connection/http2.rb#25
class HTTPX::Connection::HTTP2::GoawayError < ::HTTPX::Connection::HTTP2::Error
  # source://httpx//lib/httpx/connection/http2.rb#26
  def initialize(code = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/connection/http2.rb#11
HTTPX::Connection::HTTP2::MAX_CONCURRENT_REQUESTS = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/connection/http2.rb#19
class HTTPX::Connection::HTTP2::PingError < ::HTTPX::Connection::HTTP2::Error
  # source://httpx//lib/httpx/connection/http2.rb#20
  def initialize; end
end

# source://httpx//lib/httpx/errors.rb#9
class HTTPX::ConnectionError < ::HTTPX::Error; end

# Helper class which decodes the HTTP "content-type" header.
#
# source://httpx//lib/httpx/response.rb#208
class HTTPX::ContentType
  # @return [ContentType] a new instance of ContentType
  #
  # source://httpx//lib/httpx/response.rb#212
  def initialize(header_value); end

  # returns the charset declared in the header.
  #
  #   ContentType.new("application/json; charset=utf-8").charset #=> "utf-8"
  #   ContentType.new("text/plain").charset #=> nil
  #
  # source://httpx//lib/httpx/response.rb#230
  def charset; end

  # returns the mime type declared in the header.
  #
  #   ContentType.new("application/json; charset=utf-8").mime_type #=> "application/json"
  #
  # source://httpx//lib/httpx/response.rb#219
  def mime_type; end
end

# source://httpx//lib/httpx/response.rb#210
HTTPX::ContentType::CHARSET_RE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/response.rb#209
HTTPX::ContentType::MIME_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# Represents a domain name ready for extracting its registered domain
# and TLD.
#
# source://httpx//lib/httpx/domain_name.rb#34
class HTTPX::DomainName
  include ::Comparable

  # Parses _hostname_ into a DomainName object.  An IP address is also
  # accepted.  An IPv6 address may be enclosed in square brackets.
  #
  # @raise [ArgumentError]
  # @return [DomainName] a new instance of DomainName
  #
  # source://httpx//lib/httpx/domain_name.rb#75
  def initialize(hostname); end

  # source://httpx//lib/httpx/domain_name.rb#131
  def <=>(other); end

  # Checks if the server represented by this domain is qualified to
  # send and receive cookies with a domain attribute value of
  # _domain_.  A true value given as the second argument represents
  # cookies without a domain attribute value, in which case only
  # hostname equality is checked.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/domain_name.rb#115
  def cookie_domain?(domain, host_only = T.unsafe(nil)); end

  # The least "universally original" domain part of this domain name.
  # For example, "example.co.uk" for "www.sub.example.co.uk".  This
  # may be nil if the hostname does not have one, like when it is an
  # IP address, an effective TLD or higher itself, or of a
  # non-canonical domain.
  #
  # source://httpx//lib/httpx/domain_name.rb#52
  def domain; end

  # The full host name normalized, ASCII-ized and downcased using the
  # Unicode NFC rules and the Punycode algorithm.  If initialized with
  # an IP address, the string representation of the IP address
  # suitable for opening a connection to.
  #
  # source://httpx//lib/httpx/domain_name.rb#41
  def hostname; end

  class << self
    # source://httpx//lib/httpx/domain_name.rb#55
    def new(domain); end

    # Normalizes a _domain_ using the Punycode algorithm as necessary.
    # The result will be a downcased, ASCII-only string.
    #
    # source://httpx//lib/httpx/domain_name.rb#63
    def normalize(domain); end
  end
end

# source://httpx//lib/httpx.rb#8
HTTPX::EMPTY = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx.rb#9
HTTPX::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# the default exception class for exceptions raised by HTTPX.
#
# source://httpx//lib/httpx/errors.rb#5
class HTTPX::Error < ::StandardError; end

# Wraps an error which has happened while processing an HTTP Request. It has partial
# public API parity with HTTPX::Response, so users should rely on it to infer whether
# the returned response is one or the other.
#
#   response = HTTPX.get("https://some-domain/path") #=> response is HTTPX::Response or HTTPX::ErrorResponse
#   response.raise_for_status #=> raises if it wraps an error
#
# source://httpx//lib/httpx/response.rb#244
class HTTPX::ErrorResponse
  include ::HTTPX::Loggable
  include ::HTTPX::ErrorResponsePatternMatchExtensions
  extend ::Forwardable

  # @return [ErrorResponse] a new instance of ErrorResponse
  #
  # source://httpx//lib/httpx/response.rb#263
  def initialize(request, error); end

  # buffers lost chunks to error response
  #
  # source://httpx//lib/httpx/response.rb#294
  def <<(data); end

  # closes the error resources.
  #
  # source://httpx//lib/httpx/response.rb#277
  def close; end

  # the wrapped exception.
  #
  # source://httpx//lib/httpx/response.rb#255
  def error; end

  # source://httpx//lib/httpx/response.rb#286
  def finish!; end

  # always true for error responses.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#282
  def finished?; end

  # source://httpx//lib/httpx/response.rb#261
  def peer_address(*args, **_arg1, &block); end

  # raises the wrapped exception.
  #
  # @raise [@error]
  #
  # source://httpx//lib/httpx/response.rb#289
  def raise_for_status; end

  # the corresponding HTTPX::Request instance.
  #
  # source://httpx//lib/httpx/response.rb#249
  def request; end

  # the HTTPX::Response instance, when there is one (i.e. error happens fetching the response).
  #
  # source://httpx//lib/httpx/response.rb#252
  def response; end

  # returns the exception full message.
  #
  # source://httpx//lib/httpx/response.rb#272
  def to_s; end

  # source://httpx//lib/httpx/response.rb#258
  def uri(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#14
module HTTPX::ErrorResponsePatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#15
  def deconstruct; end

  # source://httpx//lib/httpx/pmatch_extensions.rb#19
  def deconstruct_keys(_keys); end
end

# The exception class for HTTP responses with 4xx or 5xx status.
#
# source://httpx//lib/httpx/errors.rb#94
class HTTPX::HTTPError < ::HTTPX::Error
  # Creates the instance and assigns the HTTPX::Response +response+.
  #
  # @return [HTTPError] a new instance of HTTPError
  #
  # source://httpx//lib/httpx/errors.rb#99
  def initialize(response); end

  # The HTTPX::Response response object this exception refers to.
  #
  # source://httpx//lib/httpx/errors.rb#96
  def response; end

  # The HTTP response status.
  #
  #   error.status #=> 404
  #
  # source://httpx//lib/httpx/errors.rb#107
  def status; end
end

# source://httpx//lib/httpx/headers.rb#4
class HTTPX::Headers
  include ::HTTPX::HeadersPatternMatchExtensions

  # @return [Headers] a new instance of Headers
  #
  # source://httpx//lib/httpx/headers.rb#13
  def initialize(headers = T.unsafe(nil)); end

  # source://httpx//lib/httpx/headers.rb#119
  def ==(other); end

  # returns the comma-separated values of the header field
  # identified by +field+, or nil otherwise.
  #
  # source://httpx//lib/httpx/headers.rb#69
  def [](field); end

  # sets +value+ (if not nil) as single value for the +field+ header.
  #
  # source://httpx//lib/httpx/headers.rb#76
  def []=(field, value); end

  # adds additional +value+ to the existing, for header +field+.
  #
  # source://httpx//lib/httpx/headers.rb#91
  def add(field, value); end

  # adds additional +value+ to the existing, for header +field+.
  # helper to be used when adding an header field as a value to another field
  #
  #     h2_headers.add_header("vary", "accept-encoding")
  #     h2_headers["vary"] #=> "accept-encoding"
  #     h1_headers.add_header("vary", "accept-encoding")
  #     h1_headers["vary"] #=> "Accept-Encoding"
  #
  # source://httpx//lib/httpx/headers.rb#102
  def add_header(field, value); end

  # deletes all values associated with +field+ header.
  #
  # source://httpx//lib/httpx/headers.rb#84
  def delete(field); end

  # returns the enumerable headers store in pairs of header field + the values in
  # the comma-separated string format
  #
  # source://httpx//lib/httpx/headers.rb#107
  def each(extra_headers = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/headers.rb#123
  def empty?; end

  # freezes the headers hash
  #
  # source://httpx//lib/httpx/headers.rb#49
  def freeze; end

  # returns the values for the +field+ header in array format.
  # This method is more internal, and for this reason doesn't try
  # to "correct" the user input, i.e. it doesn't downcase the key.
  #
  # source://httpx//lib/httpx/headers.rb#162
  def get(field); end

  # :nocov:
  #
  # source://httpx//lib/httpx/headers.rb#144
  def inspect; end

  # this is internal API and doesn't abide to other public API
  # guarantees, like downcasing strings.
  # Please do not use this outside of core!
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/headers.rb#154
  def key?(downcased_key); end

  # merges headers with another header-quack.
  # the merge rule is, if the header already exists,
  # ignore what the +other+ headers has. Otherwise, set
  #
  # source://httpx//lib/httpx/headers.rb#58
  def merge(other); end

  # the headers store in array of pairs format
  #
  # source://httpx//lib/httpx/headers.rb#134
  def to_a; end

  # the headers store in Hash format
  #
  # source://httpx//lib/httpx/headers.rb#131
  def to_h; end

  # the headers store in Hash format
  #
  # source://httpx//lib/httpx/headers.rb#128
  def to_hash; end

  # headers as string
  #
  # source://httpx//lib/httpx/headers.rb#139
  def to_s; end

  private

  # source://httpx//lib/httpx/headers.rb#168
  def array_value(value); end

  # source://httpx//lib/httpx/headers.rb#172
  def downcased(field); end

  # cloned initialization
  #
  # source://httpx//lib/httpx/headers.rb#37
  def initialize_clone(orig, **kwargs); end

  # dupped initialization
  #
  # source://httpx//lib/httpx/headers.rb#43
  def initialize_dup(orig); end

  class << self
    # source://httpx//lib/httpx/headers.rb#6
    def new(headers = T.unsafe(nil)); end
  end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#24
module HTTPX::HeadersPatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#25
  def deconstruct; end
end

# source://httpx//lib/httpx/loggable.rb#4
module HTTPX::Loggable
  # source://httpx//lib/httpx/loggable.rb#18
  def log(level: T.unsafe(nil), color: T.unsafe(nil), debug_level: T.unsafe(nil), debug: T.unsafe(nil), &msg); end

  # source://httpx//lib/httpx/loggable.rb#46
  def log_exception(ex, level: T.unsafe(nil), color: T.unsafe(nil), debug_level: T.unsafe(nil), debug: T.unsafe(nil)); end

  # source://httpx//lib/httpx/loggable.rb#50
  def log_redact(text, should_redact = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/loggable.rb#5
HTTPX::Loggable::COLORS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/loggable.rb#16
HTTPX::Loggable::USE_DEBUG_LOG = T.let(T.unsafe(nil), FalseClass)

# Error raised when there was an error while resolving a domain to an IP
# using a HTTPX::Resolver::Native resolver.
#
# source://httpx//lib/httpx/errors.rb#79
class HTTPX::NativeResolveError < ::HTTPX::ResolveError
  # initializes the exception with the +connection+ it refers to, the +host+ domain
  # which failed to resolve, and the error +message+.
  #
  # @return [NativeResolveError] a new instance of NativeResolveError
  #
  # source://httpx//lib/httpx/errors.rb#86
  def initialize(connection, host, message = T.unsafe(nil)); end

  # Returns the value of attribute connection.
  #
  # source://httpx//lib/httpx/errors.rb#82
  def connection; end

  # Sets the attribute connection
  #
  # @param value the value to set the attribute connection to.
  #
  # source://httpx//lib/httpx/errors.rb#82
  def connection=(_arg0); end

  # Returns the value of attribute host.
  #
  # source://httpx//lib/httpx/errors.rb#80
  def host; end
end

# Error raise when there was a timeout waiting for readiness of the socket the request is related to.
#
# source://httpx//lib/httpx/errors.rb#72
class HTTPX::OperationTimeoutError < ::HTTPX::TimeoutError; end

# Contains a set of options which are passed and shared across from session to its requests or
# responses.
#
# source://httpx//lib/httpx/options.rb#6
class HTTPX::Options
  # creates a new options instance from a given hash, which optionally define the following:
  #
  # :debug :: an object which log messages are written to (must respond to <tt><<</tt>)
  # :debug_level :: the log level of messages (can be 1, 2, or 3).
  # :debug_redact :: whether header/body payload should be redacted (defaults to <tt>false</tt>).
  # :ssl :: a hash of options which can be set as params of OpenSSL::SSL::SSLContext (see HTTPX::SSL)
  # :http2_settings :: a hash of options to be passed to a HTTP2::Connection (ex: <tt>{ max_concurrent_streams: 2 }</tt>)
  # :fallback_protocol :: version of HTTP protocol to use by default in the absence of protocol negotiation
  #                       like ALPN (defaults to <tt>"http/1.1"</tt>)
  # :supported_compression_formats :: list of compressions supported by the transcoder layer (defaults to <tt>%w[gzip deflate]</tt>).
  # :decompress_response_body :: whether to auto-decompress response body (defaults to <tt>true</tt>).
  # :compress_request_body :: whether to auto-decompress response body (defaults to <tt>true</tt>)
  # :timeout :: hash of timeout configurations (supports <tt>:connect_timeout</tt>, <tt>:settings_timeout</tt>,
  #             <tt>:operation_timeout</tt>, <tt>:keep_alive_timeout</tt>,  <tt>:read_timeout</tt>,  <tt>:write_timeout</tt>
  #             and <tt>:request_timeout</tt>
  # :headers :: hash of HTTP headers (ex: <tt>{ "x-custom-foo" => "bar" }</tt>)
  # :window_size :: number of bytes to read from a socket
  # :buffer_size :: internal read and write buffer size in bytes
  # :body_threshold_size :: maximum size in bytes of response payload that is buffered in memory.
  # :request_class :: class used to instantiate a request
  # :response_class :: class used to instantiate a response
  # :headers_class :: class used to instantiate headers
  # :request_body_class :: class used to instantiate a request body
  # :response_body_class :: class used to instantiate a response body
  # :connection_class :: class used to instantiate connections
  # :http1_class :: class used to manage HTTP1 sessions
  # :http2_class :: class used to imanage HTTP2 sessions
  # :resolver_native_class :: class used to resolve names using pure ruby DNS implementation
  # :resolver_system_class :: class used to resolve names using system-based (getaddrinfo) name resolution
  # :resolver_https_class :: class used to resolve names using DoH
  # :pool_class :: class used to instantiate the session connection pool
  # :options_class :: class used to instantiate options
  # :transport :: type of transport to use (set to "unix" for UNIX sockets)
  # :addresses :: bucket of peer addresses (can be a list of IP addresses, a hash of domain to list of adddresses;
  #               paths should be used for UNIX sockets instead)
  # :io :: open socket, or domain/ip-to-socket hash, which requests should be sent to
  # :persistent :: whether to persist connections in between requests (defaults to <tt>true</tt>)
  # :resolver_class :: which resolver to use (defaults to <tt>:native</tt>, can also be <tt>:system<tt> for
  #                    using getaddrinfo or <tt>:https</tt> for DoH resolver, or a custom class)
  # :resolver_options :: hash of options passed to the resolver. Accepted keys depend on the resolver type.
  # :pool_options :: hash of options passed to the connection pool (See Pool#initialize).
  # :ip_families :: which socket families are supported (system-dependent)
  # :origin :: HTTP origin to set on requests with relative path (ex: "https://api.serv.com")
  # :base_path :: path to prefix given relative paths with (ex: "/v2")
  # :max_concurrent_requests :: max number of requests which can be set concurrently
  # :max_requests :: max number of requests which can be made on socket before it reconnects.
  # :close_on_fork :: whether the session automatically closes when the process is fork (defaults to <tt>false</tt>).
  #                   it only works if the session is persistent (and ruby 3.1 or higher is used).
  #
  # This list of options are enhanced with each loaded plugin, see the plugin docs for details.
  #
  # @return [Options] a new instance of Options
  #
  # source://httpx//lib/httpx/options.rb#40
  def initialize(options = T.unsafe(nil)); end

  # source://httpx//lib/httpx/options.rb#40
  def ==(other); end

  # source://httpx//lib/httpx/options.rb#40
  def addresses; end

  # source://httpx//lib/httpx/options.rb#40
  def base_path; end

  # source://httpx//lib/httpx/options.rb#40
  def body_threshold_size; end

  # source://httpx//lib/httpx/options.rb#40
  def buffer_size; end

  # source://httpx//lib/httpx/options.rb#40
  def close_on_fork; end

  # source://httpx//lib/httpx/options.rb#40
  def compress_request_body; end

  # source://httpx//lib/httpx/options.rb#40
  def connection_class; end

  # source://httpx//lib/httpx/options.rb#40
  def debug; end

  # source://httpx//lib/httpx/options.rb#40
  def debug_level; end

  # source://httpx//lib/httpx/options.rb#40
  def debug_redact; end

  # source://httpx//lib/httpx/options.rb#40
  def decompress_response_body; end

  # source://httpx//lib/httpx/options.rb#40
  def extend_with_plugin_classes(pl); end

  # source://httpx//lib/httpx/options.rb#40
  def fallback_protocol; end

  # source://httpx//lib/httpx/options.rb#40
  def freeze; end

  # source://httpx//lib/httpx/options.rb#40
  def headers; end

  # source://httpx//lib/httpx/options.rb#40
  def headers_class; end

  # source://httpx//lib/httpx/options.rb#40
  def http1_class; end

  # source://httpx//lib/httpx/options.rb#40
  def http2_class; end

  # source://httpx//lib/httpx/options.rb#40
  def http2_settings; end

  # source://httpx//lib/httpx/options.rb#40
  def io; end

  # source://httpx//lib/httpx/options.rb#40
  def ip_families; end

  # source://httpx//lib/httpx/options.rb#40
  def max_concurrent_requests; end

  # source://httpx//lib/httpx/options.rb#40
  def max_requests; end

  # source://httpx//lib/httpx/options.rb#40
  def merge(other); end

  # source://httpx//lib/httpx/options.rb#40
  def options_class; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/options.rb#40
  def options_equals?(other, ignore_ivars = T.unsafe(nil)); end

  # source://httpx//lib/httpx/options.rb#40
  def origin; end

  # source://httpx//lib/httpx/options.rb#40
  def persistent; end

  # source://httpx//lib/httpx/options.rb#40
  def pool_class; end

  # source://httpx//lib/httpx/options.rb#40
  def pool_options; end

  # source://httpx//lib/httpx/options.rb#40
  def request_body_class; end

  # source://httpx//lib/httpx/options.rb#40
  def request_class; end

  # source://httpx//lib/httpx/options.rb#40
  def resolver_class; end

  # source://httpx//lib/httpx/options.rb#40
  def resolver_https_class; end

  # source://httpx//lib/httpx/options.rb#40
  def resolver_native_class; end

  # source://httpx//lib/httpx/options.rb#40
  def resolver_options; end

  # source://httpx//lib/httpx/options.rb#40
  def resolver_system_class; end

  # source://httpx//lib/httpx/options.rb#40
  def response_body_class; end

  # source://httpx//lib/httpx/options.rb#40
  def response_class; end

  # source://httpx//lib/httpx/options.rb#40
  def ssl; end

  # source://httpx//lib/httpx/options.rb#40
  def supported_compression_formats; end

  # source://httpx//lib/httpx/options.rb#40
  def timeout; end

  # source://httpx//lib/httpx/options.rb#40
  def to_hash; end

  # source://httpx//lib/httpx/options.rb#40
  def transport; end

  # source://httpx//lib/httpx/options.rb#40
  def window_size; end

  private

  # source://httpx//lib/httpx/options.rb#40
  def access_option(obj, k, ivar_map); end

  # source://httpx//lib/httpx/options.rb#40
  def option_addresses(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_base_path(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_body_threshold_size(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_buffer_size(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_close_on_fork(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_compress_request_body(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_connection_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_debug(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_debug_level(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_debug_redact(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_decompress_response_body(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_fallback_protocol(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_headers(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_headers_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_http1_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_http2_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_http2_settings(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_io(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_ip_families(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_max_concurrent_requests(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_max_requests(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_options_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_origin(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_persistent(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_pool_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_pool_options(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_request_body_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_request_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_resolver_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_resolver_https_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_resolver_native_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_resolver_options(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_resolver_system_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_response_body_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_response_class(v); end

  # source://httpx//lib/httpx/options.rb#40
  def option_ssl(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_supported_compression_formats(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_timeout(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#40
  def option_transport(value); end

  # source://httpx//lib/httpx/options.rb#40
  def option_window_size(value); end

  class << self
    # source://httpx//lib/httpx/options.rb#34
    def freeze; end

    # @private
    #
    # source://httpx//lib/httpx/options.rb#21
    def inherited(klass); end

    # @private
    #
    # source://httpx//lib/httpx/options.rb#39
    def method_added(meth); end

    # source://httpx//lib/httpx/options.rb#26
    def new(options = T.unsafe(nil)); end

    # Returns the value of attribute options_names.
    #
    # source://httpx//lib/httpx/options.rb#19
    def options_names; end
  end
end

# source://httpx//lib/httpx/options.rb#7
HTTPX::Options::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#12
HTTPX::Options::CLOSE_HANDSHAKE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#13
HTTPX::Options::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#415
HTTPX::Options::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/options.rb#10
HTTPX::Options::KEEP_ALIVE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# 112K
#
# source://httpx//lib/httpx/options.rb#9
HTTPX::Options::MAX_BODY_THRESHOLD_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#14
HTTPX::Options::OPERATION_TIMEOUT = T.let(T.unsafe(nil), T.untyped)

# source://httpx//lib/httpx/options.rb#13
HTTPX::Options::READ_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#165
HTTPX::Options::REQUEST_BODY_IVARS = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/options.rb#14
HTTPX::Options::REQUEST_TIMEOUT = T.let(T.unsafe(nil), T.untyped)

# source://httpx//lib/httpx/options.rb#11
HTTPX::Options::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#407
HTTPX::Options::SET_TEMPORARY_NAME = T.let(T.unsafe(nil), Proc)

# 16K
#
# source://httpx//lib/httpx/options.rb#8
HTTPX::Options::WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#13
HTTPX::Options::WRITE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/parser/http1.rb#4
module HTTPX::Parser; end

# source://httpx//lib/httpx/parser/http1.rb#5
class HTTPX::Parser::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/parser/http1.rb#7
class HTTPX::Parser::HTTP1
  # @return [HTTP1] a new instance of HTTP1
  #
  # source://httpx//lib/httpx/parser/http1.rb#12
  def initialize(observer); end

  # source://httpx//lib/httpx/parser/http1.rb#19
  def <<(chunk); end

  # Returns the value of attribute headers.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def headers; end

  # Returns the value of attribute http_version.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def http_version; end

  # source://httpx//lib/httpx/parser/http1.rb#24
  def reset!; end

  # Returns the value of attribute status_code.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def status_code; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/parser/http1.rb#31
  def upgrade?; end

  # source://httpx//lib/httpx/parser/http1.rb#35
  def upgrade_data; end

  private

  # source://httpx//lib/httpx/parser/http1.rb#173
  def nextstate(state); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/parser/http1.rb#163
  def no_more_data?; end

  # source://httpx//lib/httpx/parser/http1.rb#41
  def parse; end

  # source://httpx//lib/httpx/parser/http1.rb#118
  def parse_data; end

  # source://httpx//lib/httpx/parser/http1.rb#73
  def parse_headers; end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/parser/http1.rb#56
  def parse_headline; end

  # source://httpx//lib/httpx/parser/http1.rb#144
  def prepare_data(headers); end
end

# source://httpx//lib/httpx/parser/http1.rb#8
HTTPX::Parser::HTTP1::VERSIONS = T.let(T.unsafe(nil), Array)

# All plugins should be stored under this module/namespace. Can register and load
# plugins.
#
# source://httpx//lib/httpx.rb#14
module HTTPX::Plugins
  class << self
    # Loads a plugin based on a name. If the plugin hasn't been loaded, tries to load
    # it from the load path under "httpx/plugins/" directory.
    #
    # source://httpx//lib/httpx.rb#21
    def load_plugin(name); end

    # Registers a plugin (+mod+) in the central store indexed by +name+.
    #
    # source://httpx//lib/httpx.rb#33
    def register_plugin(name, mod); end
  end
end

# source://httpx//lib/httpx/adapters/sentry.rb#6
module HTTPX::Plugins::Sentry; end

# source://httpx//lib/httpx/adapters/sentry.rb#106
module HTTPX::Plugins::Sentry::ConnectionMethods
  # source://httpx//lib/httpx/adapters/sentry.rb#107
  def send(request); end
end

# source://httpx//lib/httpx/adapters/sentry.rb#97
module HTTPX::Plugins::Sentry::RequestMethods
  # source://httpx//lib/httpx/adapters/sentry.rb#98
  def __sentry_enable_trace!; end
end

# source://httpx//lib/httpx/adapters/sentry.rb#7
module HTTPX::Plugins::Sentry::Tracer
  private

  # source://httpx//lib/httpx/adapters/sentry.rb#10
  def call(request); end

  # source://httpx//lib/httpx/adapters/sentry.rb#79
  def extract_request_info(req); end

  # source://httpx//lib/httpx/adapters/sentry.rb#39
  def finish_sentry_span(span, request, response); end

  # source://httpx//lib/httpx/adapters/sentry.rb#46
  def record_sentry_breadcrumb(req, res); end

  # source://httpx//lib/httpx/adapters/sentry.rb#66
  def record_sentry_span(req, res, sentry_span); end

  # source://httpx//lib/httpx/adapters/sentry.rb#27
  def set_sentry_trace_header(request, sentry_span); end

  # source://httpx//lib/httpx/adapters/sentry.rb#20
  def start_sentry_span; end

  class << self
    # source://httpx//lib/httpx/adapters/sentry.rb#10
    def call(request); end

    # source://httpx//lib/httpx/adapters/sentry.rb#79
    def extract_request_info(req); end

    # source://httpx//lib/httpx/adapters/sentry.rb#39
    def finish_sentry_span(span, request, response); end

    # source://httpx//lib/httpx/adapters/sentry.rb#46
    def record_sentry_breadcrumb(req, res); end

    # source://httpx//lib/httpx/adapters/sentry.rb#66
    def record_sentry_span(req, res, sentry_span); end

    # source://httpx//lib/httpx/adapters/sentry.rb#27
    def set_sentry_trace_header(request, sentry_span); end

    # source://httpx//lib/httpx/adapters/sentry.rb#20
    def start_sentry_span; end
  end
end

# source://httpx//lib/httpx/pool.rb#10
class HTTPX::Pool
  # Sets up the connection pool with the given +options+, which can be the following:
  #
  # :max_connections:: the maximum number of connections held in the pool.
  # :max_connections_per_origin :: the maximum number of connections held in the pool pointing to a given origin.
  # :pool_timeout :: the number of seconds to wait for a connection to a given origin (before raising HTTPX::PoolTimeoutError)
  #
  # @return [Pool] a new instance of Pool
  #
  # source://httpx//lib/httpx/pool.rb#22
  def initialize(options); end

  # source://httpx//lib/httpx/pool.rb#90
  def checkin_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#130
  def checkin_resolver(resolver); end

  # opens a connection to the IP reachable through +uri+.
  # Many hostnames are reachable through the same IP, so we try to
  # maximize pipelining by opening as few connections as possible.
  #
  # source://httpx//lib/httpx/pool.rb#47
  def checkout_connection(uri, options); end

  # source://httpx//lib/httpx/pool.rb#101
  def checkout_mergeable_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#116
  def checkout_resolver(options); end

  # :nocov:
  #
  # source://httpx//lib/httpx/pool.rb#141
  def inspect; end

  # connections returned by this function are not expected to return to the connection pool.
  #
  # source://httpx//lib/httpx/pool.rb#37
  def pop_connection; end

  # source://httpx//lib/httpx/pool.rb#112
  def reset_resolvers; end

  private

  # source://httpx//lib/httpx/pool.rb#151
  def acquire_connection(uri, options); end

  # source://httpx//lib/httpx/pool.rb#161
  def checkout_new_connection(uri, options); end

  # source://httpx//lib/httpx/pool.rb#165
  def checkout_new_resolver(resolver_type, options); end

  # drops and returns the +connection+ from the connection pool; if +connection+ is <tt>nil</tt> (default),
  # the first available connection from the pool will be dropped.
  #
  # source://httpx//lib/httpx/pool.rb#175
  def drop_connection(connection = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/pool.rb#14
HTTPX::Pool::POOL_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Raise when it can't acquire a connection from the pool.
#
# source://httpx//lib/httpx/errors.rb#33
class HTTPX::PoolTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/punycode.rb#4
module HTTPX::Punycode
  private

  # source://httpx//lib/httpx/punycode.rb#14
  def encode_hostname(hostname); end

  class << self
    # source://httpx//lib/httpx/punycode.rb#14
    def encode_hostname(hostname); end
  end
end

# Error raised when there was a timeout while receiving a response from the server.
#
# source://httpx//lib/httpx/errors.rb#60
class HTTPX::ReadTimeoutError < ::HTTPX::RequestTimeoutError; end

# Defines how an HTTP request is handled internally, both in terms of making attributes accessible,
# as well as maintaining the state machine which manages streaming the request onto the wire.
#
# source://httpx//lib/httpx/request.rb#9
class HTTPX::Request
  include ::HTTPX::Loggable
  include ::HTTPX::Callbacks
  extend ::Forwardable

  # initializes the instance with the given +verb+ (an upppercase String, ex. 'GEt'),
  # an absolute or relative +uri+ (either as String or URI::HTTP object), the
  # request +options+ (instance of HTTPX::Options) and an optional Hash of +params+.
  #
  # Besides any of the options documented in HTTPX::Options (which would override or merge with what
  # +options+ sets), it accepts also the following:
  #
  # :params :: hash or array of key-values which will be encoded and set in the query string of request uris.
  # :body :: to be encoded in the request body payload. can be a String, an IO object (i.e. a File), or an Enumerable.
  # :form :: hash of array of key-values which will be form-urlencoded- or multipart-encoded in requests body payload.
  # :json :: hash of array of key-values which will be JSON-encoded in requests body payload.
  # :xml :: Nokogiri XML nodes which will be encoded in requests body payload.
  #
  # :body, :form, :json and :xml are all mutually exclusive, i.e. only one of them gets picked up.
  #
  # @raise [UnsupportedSchemeError]
  # @return [Request] a new instance of Request
  #
  # source://httpx//lib/httpx/request.rb#71
  def initialize(verb, uri, options, params = T.unsafe(nil)); end

  # Returns the value of attribute active_timeouts.
  #
  # source://httpx//lib/httpx/request.rb#49
  def active_timeouts; end

  # returs the URI authority of the request.
  #
  #   session.build_request("GET", "https://google.com/query").authority #=> "google.com"
  #   session.build_request("GET", "http://internal:3182/a").authority #=> "internal:3182"
  #
  # source://httpx//lib/httpx/request.rb#217
  def authority; end

  # an HTTPX::Request::Body object containing the request body payload (or +nil+, whenn there is none).
  #
  # source://httpx//lib/httpx/request.rb#30
  def body; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#162
  def can_buffer?; end

  # source://httpx//lib/httpx/request.rb#55
  def close(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/request.rb#112
  def complete!(response = T.unsafe(nil)); end

  # consumes and returns the next available chunk of request body that can be sent
  #
  # source://httpx//lib/httpx/request.rb#247
  def drain_body; end

  # Exception raised during enumerable body writes.
  #
  # source://httpx//lib/httpx/request.rb#42
  def drain_error; end

  # source://httpx//lib/httpx/request.rb#52
  def empty?(*args, **_arg1, &block); end

  # whether the request supports the 100-continue handshake and already processed the 100 response.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#313
  def expects?; end

  # an HTTPX::Headers object containing the request HTTP headers.
  #
  # source://httpx//lib/httpx/request.rb#27
  def headers; end

  # :nocov:
  #
  # source://httpx//lib/httpx/request.rb#263
  def inspect; end

  # returns +:r+ or +:w+, depending on whether the request is waiting for a response or flushing.
  #
  # source://httpx//lib/httpx/request.rb#156
  def interests; end

  # merges +h+ into the instance of HTTPX::Headers of the request.
  #
  # source://httpx//lib/httpx/request.rb#167
  def merge_headers(h); end

  # an HTTPX::Options object containing request options.
  #
  # source://httpx//lib/httpx/request.rb#36
  def options; end

  # returs the URI origin of the request.
  #
  #   session.build_request("GET", "https://google.com/query").authority #=> "https://google.com"
  #   session.build_request("GET", "http://internal:3182/a").authority #=> "http://internal:3182"
  #
  # source://httpx//lib/httpx/request.rb#225
  def origin; end

  # returnns the URI path of the request +uri+.
  #
  # source://httpx//lib/httpx/request.rb#205
  def path; end

  # The IP address from the peer server.
  #
  # source://httpx//lib/httpx/request.rb#45
  def peer_address; end

  # The IP address from the peer server.
  #
  # source://httpx//lib/httpx/request.rb#45
  def peer_address=(_arg0); end

  # Sets the attribute persistent
  #
  # @param value the value to set the attribute persistent to.
  #
  # source://httpx//lib/httpx/request.rb#47
  def persistent=(_arg0); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#141
  def persistent?; end

  # marks the request as having been buffered with a ping
  #
  # source://httpx//lib/httpx/request.rb#122
  def ping!; end

  # whether request has been buffered with a ping
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#117
  def ping?; end

  # returs the URI query string of the request (when available).
  #
  #   session.build_request("GET", "https://search.com").query #=> ""
  #   session.build_request("GET", "https://search.com?q=a").query #=> "q=a"
  #   session.build_request("GET", "https://search.com", params: { q: "a"}).query #=> "q=a"
  #   session.build_request("GET", "https://search.com?q=a", params: { foo: "bar"}).query #=> "q=a&foo&bar"
  #
  # source://httpx//lib/httpx/request.rb#235
  def query; end

  # the read timeout defined for this request.
  #
  # source://httpx//lib/httpx/request.rb#127
  def read_timeout; end

  # the request timeout defined for this request.
  #
  # source://httpx//lib/httpx/request.rb#137
  def request_timeout; end

  # the corresponding HTTPX::Response object, when there is one.
  #
  # source://httpx//lib/httpx/request.rb#39
  def response; end

  # sets the +response+ on this request.
  #
  # source://httpx//lib/httpx/request.rb#177
  def response=(response); end

  # the URI scheme of the request +uri+.
  #
  # source://httpx//lib/httpx/request.rb#172
  def scheme; end

  # source://httpx//lib/httpx/request.rb#317
  def set_timeout_callback(event, &callback); end

  # a symbol describing which frame is currently being flushed.
  #
  # source://httpx//lib/httpx/request.rb#33
  def state; end

  # returns an instance of HTTPX::Headers containing the trailer headers
  #
  # source://httpx//lib/httpx/request.rb#151
  def trailers; end

  # if the request contains trailer headers
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#146
  def trailers?; end

  # moves on to the +nextstate+ of the request state machine (when all preconditions are met)
  #
  # source://httpx//lib/httpx/request.rb#273
  def transition(nextstate); end

  # the absolute URI object for this request.
  #
  # source://httpx//lib/httpx/request.rb#24
  def uri; end

  # the upcased string HTTP verb for this request.
  #
  # source://httpx//lib/httpx/request.rb#21
  def verb; end

  # the write timeout defined for this request.
  #
  # source://httpx//lib/httpx/request.rb#132
  def write_timeout; end
end

# source://httpx//lib/httpx/request.rb#15
HTTPX::Request::ALLOWED_URI_SCHEMES = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/request/body.rb#5
class HTTPX::Request::Body < ::SimpleDelegator
  # source://httpx//lib/httpx/request/body.rb#28
  def initialize(h, options, **params); end

  # source://httpx//lib/httpx/request/body.rb#87
  def bytesize; end

  # source://httpx//lib/httpx/request/body.rb#113
  def chunk!; end

  # source://httpx//lib/httpx/request/body.rb#108
  def chunked?; end

  # source://httpx//lib/httpx/request/body.rb#67
  def close; end

  # source://httpx//lib/httpx/request/body.rb#49
  def each(&block); end

  # source://httpx//lib/httpx/request/body.rb#79
  def empty?; end

  # source://httpx//lib/httpx/request/body.rb#118
  def inspect; end

  # source://httpx//lib/httpx/request/body.rb#18
  def options; end

  # source://httpx//lib/httpx/request/body.rb#18
  def options=(_arg0); end

  # source://httpx//lib/httpx/request/body.rb#72
  def rewind; end

  # source://httpx//lib/httpx/request/body.rb#94
  def stream(body); end

  # source://httpx//lib/httpx/request/body.rb#101
  def unbounded_body?; end

  class << self
    # source://httpx//lib/httpx/request/body.rb#125
    def initialize_body(params); end

    # source://httpx//lib/httpx/request/body.rb#144
    def initialize_deflater_body(body, encoding); end

    # source://httpx//lib/httpx/request/body.rb#7
    def new(_, options, body: T.unsafe(nil), **params); end
  end
end

# default value used for "user-agent" header, when not overridden.
#
# source://httpx//lib/httpx/request.rb#18
HTTPX::Request::USER_AGENT = T.let(T.unsafe(nil), String)

# Error raised when there was a timeout while sending a request, or receiving a response
# from the server.
#
# source://httpx//lib/httpx/errors.rb#42
class HTTPX::RequestTimeoutError < ::HTTPX::TimeoutError
  # initializes the exception with the +request+ and +response+ it refers to, and the
  # +timeout+ causing the error, and the
  #
  # @return [RequestTimeoutError] a new instance of RequestTimeoutError
  #
  # source://httpx//lib/httpx/errors.rb#48
  def initialize(request, response, timeout); end

  # source://httpx//lib/httpx/errors.rb#54
  def marshal_dump; end

  # The HTTPX::Request request object this exception refers to.
  #
  # source://httpx//lib/httpx/errors.rb#44
  def request; end
end

# Error raised when there was an error while resolving a domain to an IP.
#
# source://httpx//lib/httpx/errors.rb#75
class HTTPX::ResolveError < ::HTTPX::Error; end

# Error raised when there was a timeout while resolving a domain to an IP.
#
# source://httpx//lib/httpx/errors.rb#69
class HTTPX::ResolveTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/resolver.rb#7
module HTTPX::Resolver
  private

  # source://httpx//lib/httpx/resolver.rb#73
  def cached_lookup(hostname); end

  # source://httpx//lib/httpx/resolver.rb#101
  def cached_lookup_evict(hostname, ip); end

  # source://httpx//lib/httpx/resolver.rb#80
  def cached_lookup_set(hostname, family, entries); end

  # source://httpx//lib/httpx/resolver.rb#143
  def decode_dns_answer(payload); end

  # source://httpx//lib/httpx/resolver.rb#136
  def encode_dns_query(hostname, type: T.unsafe(nil), message_id: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver.rb#132
  def generate_id; end

  # matches +hostname+ to entries in the hosts file, returns <tt>nil</nil> if none is
  # found, or there is no hosts file.
  #
  # source://httpx//lib/httpx/resolver.rb#65
  def hosts_resolve(hostname); end

  # source://httpx//lib/httpx/resolver.rb#185
  def id_synchronize(&block); end

  # tries to convert +hostname+ into an IPAddr, returns <tt>nil</tt> otherwise.
  #
  # source://httpx//lib/httpx/resolver.rb#58
  def ip_resolve(hostname); end

  # do not use directly!
  #
  # source://httpx//lib/httpx/resolver.rb#114
  def lookup(hostname, lookups, ttl); end

  # source://httpx//lib/httpx/resolver.rb#181
  def lookup_synchronize; end

  # source://httpx//lib/httpx/resolver.rb#53
  def nolookup_resolve(hostname); end

  # source://httpx//lib/httpx/resolver.rb#40
  def resolver_for(resolver_type, options); end

  # source://httpx//lib/httpx/resolver.rb#26
  def supported_ip_families; end

  class << self
    # source://httpx//lib/httpx/resolver.rb#73
    def cached_lookup(hostname); end

    # source://httpx//lib/httpx/resolver.rb#101
    def cached_lookup_evict(hostname, ip); end

    # source://httpx//lib/httpx/resolver.rb#80
    def cached_lookup_set(hostname, family, entries); end

    # source://httpx//lib/httpx/resolver.rb#143
    def decode_dns_answer(payload); end

    # source://httpx//lib/httpx/resolver.rb#136
    def encode_dns_query(hostname, type: T.unsafe(nil), message_id: T.unsafe(nil)); end

    # source://httpx//lib/httpx/resolver.rb#132
    def generate_id; end

    # matches +hostname+ to entries in the hosts file, returns <tt>nil</nil> if none is
    # found, or there is no hosts file.
    #
    # source://httpx//lib/httpx/resolver.rb#65
    def hosts_resolve(hostname); end

    # source://httpx//lib/httpx/resolver.rb#185
    def id_synchronize(&block); end

    # tries to convert +hostname+ into an IPAddr, returns <tt>nil</tt> otherwise.
    #
    # source://httpx//lib/httpx/resolver.rb#58
    def ip_resolve(hostname); end

    # do not use directly!
    #
    # source://httpx//lib/httpx/resolver.rb#114
    def lookup(hostname, lookups, ttl); end

    # source://httpx//lib/httpx/resolver.rb#181
    def lookup_synchronize; end

    # source://httpx//lib/httpx/resolver.rb#53
    def nolookup_resolve(hostname); end

    # @raise [Error]
    #
    # source://httpx//lib/httpx/resolver.rb#40
    def resolver_for(resolver_type, options); end

    # source://httpx//lib/httpx/resolver.rb#26
    def supported_ip_families; end
  end
end

# source://httpx//lib/httpx/resolver/entry.rb#7
class HTTPX::Resolver::Entry < ::SimpleDelegator
  # @return [Entry] a new instance of Entry
  #
  # source://httpx//lib/httpx/resolver/entry.rb#14
  def initialize(address, expires_in = T.unsafe(nil), rescue_on_convert: T.unsafe(nil)); end

  # Returns the value of attribute address.
  #
  # source://httpx//lib/httpx/resolver/entry.rb#8
  def address; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/entry.rb#25
  def expired?; end

  class << self
    # source://httpx//lib/httpx/resolver/entry.rb#10
    def convert(address); end
  end
end

# Implementation of a DoH name resolver (https://www.youtube.com/watch?v=unMXvnY2FNM).
# It wraps an HTTPX::Connection object which integrates with the main session in the
# same manner as other performed HTTP requests.
#
# source://httpx//lib/httpx/resolver/https.rb#13
class HTTPX::Resolver::HTTPS < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # @return [HTTPS] a new instance of HTTPS
  #
  # source://httpx//lib/httpx/resolver/https.rb#35
  def initialize(_, options); end

  # source://httpx//lib/httpx/resolver/https.rb#47
  def <<(connection); end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def call(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def close(*args, **_arg1, &block); end

  # This is already indirectly monitored bt the HTTP connection. In order to skip
  # monitoring, this method returns <tt>true</tt>.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/https.rb#64
  def closed?; end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def connecting?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/https.rb#68
  def empty?; end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def handle_socket_timeout(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def inflight?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#72
  def resolver_connection; end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def state(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def terminate(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#33
  def to_io(*args, **_arg1, &block); end

  private

  # source://httpx//lib/httpx/resolver/https.rb#215
  def build_request(hostname); end

  # source://httpx//lib/httpx/resolver/https.rb#234
  def decode_response_body(response); end

  # source://httpx//lib/httpx/resolver/https.rb#131
  def on_promise(_, stream); end

  # source://httpx//lib/httpx/resolver/https.rb#118
  def on_response(request, response); end

  # source://httpx//lib/httpx/resolver/https.rb#136
  def parse(request, response); end

  # source://httpx//lib/httpx/resolver/https.rb#166
  def parse_addresses(answers, request); end

  # source://httpx//lib/httpx/resolver/https.rb#244
  def reset_hostname(hostname, reset_candidates: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/https.rb#82
  def resolve(connection = T.unsafe(nil), hostname = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/resolver/https.rb#28
HTTPX::Resolver::HTTPS::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/https.rb#17
module HTTPX::Resolver::HTTPS::DNSExtensions; end

# source://httpx//lib/httpx/resolver/https.rb#26
HTTPX::Resolver::HTTPS::NAMESERVER = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/resolver/multi.rb#7
class HTTPX::Resolver::Multi
  include ::HTTPX::Callbacks

  # @return [Multi] a new instance of Multi
  #
  # source://httpx//lib/httpx/resolver/multi.rb#13
  def initialize(resolver_type, options); end

  # source://httpx//lib/httpx/resolver/multi.rb#59
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/multi.rb#43
  def closed?; end

  # source://httpx//lib/httpx/resolver/multi.rb#63
  def connections; end

  # source://httpx//lib/httpx/resolver/multi.rb#29
  def current_selector=(s); end

  # source://httpx//lib/httpx/resolver/multi.rb#34
  def current_session=(s); end

  # source://httpx//lib/httpx/resolver/multi.rb#67
  def early_resolve(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/multi.rb#47
  def empty?; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/multi.rb#51
  def inflight?; end

  # source://httpx//lib/httpx/resolver/multi.rb#93
  def lazy_resolve(connection); end

  # source://httpx//lib/httpx/resolver/multi.rb#39
  def log(*args, **kwargs, &blk); end

  # Returns the value of attribute options.
  #
  # source://httpx//lib/httpx/resolver/multi.rb#11
  def options; end

  # Returns the value of attribute resolvers.
  #
  # source://httpx//lib/httpx/resolver/multi.rb#11
  def resolvers; end

  # source://httpx//lib/httpx/resolver/multi.rb#55
  def timeout; end
end

# Implements a pure ruby name resolver, which abides by the Selectable API.
# It delegates DNS payload encoding/decoding to the +resolv+ stlid gem.
#
# source://httpx//lib/httpx/resolver/native.rb#10
class HTTPX::Resolver::Native < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # @return [Native] a new instance of Native
  #
  # source://httpx//lib/httpx/resolver/native.rb#27
  def initialize(family, options); end

  # source://httpx//lib/httpx/resolver/native.rb#83
  def <<(connection); end

  # source://httpx//lib/httpx/resolver/native.rb#64
  def call; end

  # source://httpx//lib/httpx/resolver/native.rb#48
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/native.rb#56
  def closed?; end

  # source://httpx//lib/httpx/resolver/native.rb#23
  def empty?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/native.rb#103
  def handle_socket_timeout(interval); end

  # source://httpx//lib/httpx/resolver/native.rb#71
  def interests; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/resolver/native.rb#25
  def state; end

  # source://httpx//lib/httpx/resolver/native.rb#52
  def terminate; end

  # source://httpx//lib/httpx/resolver/native.rb#95
  def timeout; end

  # source://httpx//lib/httpx/resolver/native.rb#60
  def to_io; end

  private

  # source://httpx//lib/httpx/resolver/native.rb#444
  def build_socket; end

  # source://httpx//lib/httpx/resolver/native.rb#107
  def calculate_interests; end

  # source://httpx//lib/httpx/resolver/native.rb#536
  def close_or_resolve; end

  # source://httpx//lib/httpx/resolver/native.rb#115
  def consume; end

  # source://httpx//lib/httpx/resolver/native.rb#163
  def do_retry(h, connection, interval); end

  # source://httpx//lib/httpx/resolver/native.rb#459
  def downgrade_socket; end

  # source://httpx//lib/httpx/resolver/native.rb#204
  def dread(wsize = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#253
  def dwrite; end

  # source://httpx//lib/httpx/resolver/native.rb#424
  def encode_dns_query(hostname); end

  # source://httpx//lib/httpx/resolver/native.rb#431
  def generate_candidates(name); end

  # source://httpx//lib/httpx/resolver/native.rb#505
  def handle_error(error); end

  # source://httpx//lib/httpx/resolver/native.rb#273
  def parse(buffer); end

  # source://httpx//lib/httpx/resolver/native.rb#324
  def parse_addresses(addresses); end

  # source://httpx//lib/httpx/resolver/native.rb#524
  def reset_hostname(hostname, connection: T.unsafe(nil), reset_candidates: T.unsafe(nil)); end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/resolver/native.rb#386
  def resolve(connection = T.unsafe(nil), hostname = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#144
  def schedule_retry; end

  # source://httpx//lib/httpx/resolver/native.rb#467
  def transition(nextstate); end
end

# source://httpx//lib/httpx/resolver/native.rb#14
HTTPX::Resolver::Native::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/native.rb#21
HTTPX::Resolver::Native::DNS_PORT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver.rb#8
HTTPX::Resolver::RESOLVE_TIMEOUT = T.let(T.unsafe(nil), Array)

# Base class for all internal internet name resolvers. It handles basic blocks
# from the Selectable API.
#
# source://httpx//lib/httpx/resolver/resolver.rb#9
class HTTPX::Resolver::Resolver
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # @return [Resolver] a new instance of Resolver
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#37
  def initialize(family, options); end

  # source://httpx//lib/httpx/resolver/resolver.rb#54
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#58
  def closed?; end

  # Sets the attribute current_selector
  #
  # @param value the value to set the attribute current_selector to.
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#33
  def current_selector=(_arg0); end

  # Sets the attribute current_session
  #
  # @param value the value to set the attribute current_session to.
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#33
  def current_session=(_arg0); end

  # source://httpx//lib/httpx/resolver/resolver.rb#46
  def each_connection(&block); end

  # source://httpx//lib/httpx/resolver/resolver.rb#70
  def emit_addresses(connection, family, addresses, early_resolve = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#62
  def empty?; end

  # Returns the value of attribute family.
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#31
  def family; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#66
  def inflight?; end

  # Returns the value of attribute multi.
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#35
  def multi; end

  # Sets the attribute multi
  #
  # @param value the value to set the attribute multi to.
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#35
  def multi=(_arg0); end

  # Returns the value of attribute options.
  #
  # source://httpx//lib/httpx/resolver/resolver.rb#31
  def options; end

  # source://httpx//lib/httpx/resolver/resolver.rb#56
  def terminate; end

  private

  # source://httpx//lib/httpx/resolver/resolver.rb#169
  def close_resolver(resolver); end

  # source://httpx//lib/httpx/resolver/resolver.rb#126
  def early_resolve(connection, hostname: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#163
  def emit_connection_error(connection, error); end

  # source://httpx//lib/httpx/resolver/resolver.rb#140
  def emit_resolve_error(connection, hostname = T.unsafe(nil), ex = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#109
  def emit_resolved_connection(connection, addresses, early_resolve); end

  # source://httpx//lib/httpx/resolver/resolver.rb#159
  def resolve_connection(connection); end

  # source://httpx//lib/httpx/resolver/resolver.rb#144
  def resolve_error(hostname, ex = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#153
  def set_resolver_callbacks; end

  class << self
    # @return [Boolean]
    #
    # source://httpx//lib/httpx/resolver/resolver.rb#26
    def multi?; end
  end
end

# source://httpx//lib/httpx/resolver/resolver.rb#20
HTTPX::Resolver::Resolver::FAMILY_TYPES = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/resolver.rb#15
HTTPX::Resolver::Resolver::RECORD_TYPES = T.let(T.unsafe(nil), Hash)

# Implementation of a synchronous name resolver which relies on the system resolver,
# which is lib'c getaddrinfo function (abstracted in ruby via Addrinfo.getaddrinfo).
#
# Its main advantage is relying on the reference implementation for name resolution
# across most/all OSs which deploy ruby (it's what TCPSocket also uses), its main
# disadvantage is the inability to set timeouts / check socket for readiness events,
# hence why it relies on using the Timeout module, which poses a lot of problems for
# the selector loop, specially when network is unstable.
#
# source://httpx//lib/httpx/resolver/system.rb#15
class HTTPX::Resolver::System < ::HTTPX::Resolver::Resolver
  # @return [System] a new instance of System
  #
  # source://httpx//lib/httpx/resolver/system.rb#34
  def initialize(options); end

  # source://httpx//lib/httpx/resolver/system.rb#98
  def <<(connection); end

  # source://httpx//lib/httpx/resolver/system.rb#74
  def call; end

  # source://httpx//lib/httpx/resolver/system.rb#62
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/system.rb#66
  def closed?; end

  # source://httpx//lib/httpx/resolver/system.rb#103
  def early_resolve(connection, **_arg1); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/resolver/system.rb#58
  def empty?; end

  # source://httpx//lib/httpx/resolver/system.rb#108
  def handle_socket_timeout(interval); end

  # source://httpx//lib/httpx/resolver/system.rb#82
  def interests; end

  # source://httpx//lib/httpx/resolver/system.rb#54
  def multi; end

  # @yield [_self]
  # @yieldparam _self [HTTPX::Resolver::System] the object that the method was called on
  #
  # source://httpx//lib/httpx/resolver/system.rb#48
  def resolvers; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/resolver/system.rb#32
  def state; end

  # source://httpx//lib/httpx/resolver/system.rb#88
  def timeout; end

  # source://httpx//lib/httpx/resolver/system.rb#70
  def to_io; end

  private

  # source://httpx//lib/httpx/resolver/system.rb#245
  def __addrinfo_resolve(host, scheme); end

  # source://httpx//lib/httpx/resolver/system.rb#199
  def async_resolve(connection, hostname, scheme); end

  # source://httpx//lib/httpx/resolver/system.rb#253
  def close_resolver(resolver); end

  # source://httpx//lib/httpx/resolver/system.rb#140
  def consume; end

  # source://httpx//lib/httpx/resolver/system.rb#249
  def emit_connection_error(_, error); end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/resolver/system.rb#173
  def resolve(connection = T.unsafe(nil), hostname = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/system.rb#123
  def transition(nextstate); end

  class << self
    # @return [Boolean]
    #
    # source://httpx//lib/httpx/resolver/system.rb#27
    def multi?; end
  end
end

# source://httpx//lib/httpx/resolver/system.rb#23
HTTPX::Resolver::System::DONE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver/system.rb#24
HTTPX::Resolver::System::ERROR = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver/system.rb#18
HTTPX::Resolver::System::RESOLV_ERRORS = T.let(T.unsafe(nil), Array)

# Defines a HTTP response is handled internally, with a few properties exposed as attributes.
#
# It delegates the following methods to the corresponding HTTPX::Request:
#
# * HTTPX::Request#uri
# * HTTPX::Request#peer_address
#
# It implements (indirectly, via the +body+) the IO write protocol to internally buffer payloads.
#
# It implements the IO reader protocol in order for users to buffer/stream it, acts as an enumerable
# (of payload chunks).
#
# source://httpx//lib/httpx/response.rb#22
class HTTPX::Response
  include ::HTTPX::Callbacks
  include ::HTTPX::ResponsePatternMatchExtensions
  extend ::Forwardable

  # inits the instance with the corresponding +request+ to this response, an the
  # response HTTP +status+, +version+ and HTTPX::Headers instance of +headers+.
  #
  # @return [Response] a new instance of Response
  #
  # source://httpx//lib/httpx/response.rb#63
  def initialize(request, status, version, headers); end

  # writes +data+ chunk into the response body.
  #
  # source://httpx//lib/httpx/response.rb#94
  def <<(data); end

  # a HTTPX::Response::Body object wrapping the response body. The following methods are delegated to it:
  #
  # * HTTPX::Response::Body#to_s
  # * HTTPX::Response::Body#to_str
  # * HTTPX::Response::Body#read
  # * HTTPX::Response::Body#copy_to
  # * HTTPX::Response::Body#close
  #
  # source://httpx//lib/httpx/response.rb#39
  def body; end

  # returns whether the response contains body payload.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#118
  def bodyless?; end

  # closes the respective +@request+ and +@body+.
  #
  # source://httpx//lib/httpx/response.rb#83
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#131
  def complete?; end

  # returns the HTTPX::ContentType for the response, as per what's declared in the content-type header.
  #
  #   response.content_type #=> #<HTTPX::ContentType:xxx @header_value="text/plain">
  #   response.content_type.mime_type #=> "text/plain"
  #
  # source://httpx//lib/httpx/response.rb#102
  def content_type; end

  # source://httpx//lib/httpx/response.rb#53
  def copy_to(*args, **_arg1, &block); end

  # returns an instance of HTTPX::HTTPError if the response has a 4xx or 5xx
  # status code, or nothing.
  #
  #   ok_response.error #=> nil
  #   not_found_response.error #=> HTTPX::HTTPError instance, status 404
  #
  # source://httpx//lib/httpx/response.rb#150
  def error; end

  # marks the response as finished, freezes the headers.
  #
  # source://httpx//lib/httpx/response.rb#112
  def finish!; end

  # returns whether the response has been fully fetched.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#107
  def finished?; end

  # decodes the response payload into a ruby object **if** the payload is valid
  # "application/x-www-urlencoded" or "multipart/form-data".
  #
  # source://httpx//lib/httpx/response.rb#176
  def form; end

  # an HTTPX::Headers object containing the response HTTP headers.
  #
  # source://httpx//lib/httpx/response.rb#30
  def headers; end

  # :nocov:
  #
  # source://httpx//lib/httpx/response.rb#136
  def inspect; end

  # decodes the response payload into a ruby object **if** the payload is valid json.
  #
  #   response.json #> { "foo" => "bar" } for "{\"foo\":\"bar\"}" payload
  #   response.json(symbolize_names: true) #> { foo: "bar" } for "{\"foo\":\"bar\"}" payload
  #
  # source://httpx//lib/httpx/response.rb#170
  def json(*args); end

  # merges headers defined in +h+ into the response headers.
  #
  # source://httpx//lib/httpx/response.rb#89
  def merge_headers(h); end

  # source://httpx//lib/httpx/response.rb#59
  def peer_address(*args, **_arg1, &block); end

  # it raises the exception returned by +error+, or itself otherwise.
  #
  #   ok_response.raise_for_status #=> ok_response
  #   not_found_response.raise_for_status #=> raises HTTPX::HTTPError exception
  #
  # source://httpx//lib/httpx/response.rb#160
  def raise_for_status; end

  # source://httpx//lib/httpx/response.rb#50
  def read(*args, **_arg1, &block); end

  # the HTTP response status code
  #
  # source://httpx//lib/httpx/response.rb#27
  def status; end

  # source://httpx//lib/httpx/response.rb#45
  def to_s(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/response.rb#47
  def to_str(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/response.rb#56
  def uri(*args, **_arg1, &block); end

  # The HTTP protocol version used to fetch the response.
  #
  # source://httpx//lib/httpx/response.rb#42
  def version; end

  # source://httpx//lib/httpx/response.rb#180
  def xml; end

  private

  # decodes the response payload using the given +transcoder+, which implements the decoding logic.
  #
  # +transcoder+ must implement the internal transcoder API, i.e. respond to <tt>decode(HTTPX::Response response)</tt>,
  # which returns a decoder which responds to <tt>call(HTTPX::Response response, **kwargs)</tt>
  #
  # @raise [Error]
  #
  # source://httpx//lib/httpx/response.rb#194
  def decode(transcoder, *args); end

  # dupped initialization
  #
  # source://httpx//lib/httpx/response.rb#75
  def initialize_dup(orig); end
end

# source://httpx//lib/httpx/response/body.rb#7
class HTTPX::Response::Body
  # source://httpx//lib/httpx/response/body.rb#18
  def initialize(response, options); end

  # source://httpx//lib/httpx/response/body.rb#153
  def ==(other); end

  # source://httpx//lib/httpx/response/body.rb#85
  def bytesize; end

  # source://httpx//lib/httpx/response/body.rb#144
  def close; end

  # source://httpx//lib/httpx/response/body.rb#49
  def closed?; end

  # source://httpx//lib/httpx/response/body.rb#131
  def copy_to(dest); end

  # source://httpx//lib/httpx/response/body.rb#90
  def each; end

  # source://httpx//lib/httpx/response/body.rb#122
  def empty?; end

  # source://httpx//lib/httpx/response/body.rb#9
  def encoding; end

  # source://httpx//lib/httpx/response/body.rb#12
  def encodings; end

  # source://httpx//lib/httpx/response/body.rb#106
  def filename; end

  # source://httpx//lib/httpx/response/body.rb#163
  def inspect; end

  # source://httpx//lib/httpx/response/body.rb#72
  def read(*args); end

  # source://httpx//lib/httpx/response/body.rb#171
  def rewind; end

  # source://httpx//lib/httpx/response/body.rb#113
  def to_s; end

  # source://httpx//lib/httpx/response/body.rb#119
  def to_str; end

  # source://httpx//lib/httpx/response/body.rb#55
  def write(chunk); end

  protected

  # source://httpx//lib/httpx/response/body.rb#14
  def buffer; end

  private

  # source://httpx//lib/httpx/response/body.rb#205
  def decode_chunk(chunk); end

  # source://httpx//lib/httpx/response/body.rb#43
  def initialize_dup(other); end

  # source://httpx//lib/httpx/response/body.rb#183
  def initialize_inflaters; end

  # source://httpx//lib/httpx/response/body.rb#214
  def transition(nextstate); end

  class << self
    # source://httpx//lib/httpx/response/body.rb#232
    def initialize_inflater_by_encoding(encoding, response, **kwargs); end
  end
end

# source://httpx//lib/httpx/response/buffer.rb#9
class HTTPX::Response::Buffer < ::SimpleDelegator
  # source://httpx//lib/httpx/response/buffer.rb#15
  def initialize(threshold_size:, bytesize: T.unsafe(nil), encoding: T.unsafe(nil)); end

  # source://httpx//lib/httpx/response/buffer.rb#76
  def ==(other); end

  # source://httpx//lib/httpx/response/buffer.rb#71
  def close; end

  # source://httpx//lib/httpx/response/buffer.rb#39
  def size; end

  # source://httpx//lib/httpx/response/buffer.rb#51
  def to_s; end

  # source://httpx//lib/httpx/response/buffer.rb#44
  def write(chunk); end

  protected

  # source://httpx//lib/httpx/response/buffer.rb#10
  def buffer; end

  private

  # source://httpx//lib/httpx/response/buffer.rb#23
  def initialize_dup(other); end

  # source://httpx//lib/httpx/response/buffer.rb#97
  def try_upgrade_buffer; end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#4
module HTTPX::ResponsePatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#5
  def deconstruct; end

  # source://httpx//lib/httpx/pmatch_extensions.rb#9
  def deconstruct_keys(_keys); end
end

# session may be overridden by certain adapters.
#
# source://httpx//lib/httpx/session.rb#611
HTTPX::S = HTTPX::Session

# source://httpx//lib/httpx/io/ssl.rb#8
class HTTPX::SSL < ::HTTPX::TCP
  # @return [SSL] a new instance of SSL
  #
  # source://httpx//lib/httpx/io/ssl.rb#19
  def initialize(_, _, options); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#73
  def can_verify_peer?; end

  # source://httpx//lib/httpx/io/ssl.rb#92
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#84
  def connected?; end

  # in jruby, alpn_protocol may return ""
  # https://github.com/jruby/jruby-openssl/issues/287
  #
  # source://httpx//lib/httpx/io/ssl.rb#53
  def protocol; end

  # session_new_cb not implemented under JRuby
  #
  # source://httpx//lib/httpx/io/ssl.rb#45
  def session_new_cb(&pr); end

  # Sets the attribute ssl_session
  #
  # @param value the value to set the attribute ssl_session to.
  #
  # source://httpx//lib/httpx/io/ssl.rb#17
  def ssl_session=(_arg0); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#88
  def ssl_session_expired?; end

  # source://httpx//lib/httpx/io/ssl.rb#117
  def try_ssl_connect; end

  # source://httpx//lib/httpx/io/ssl.rb#77
  def verify_hostname(host); end

  private

  # source://httpx//lib/httpx/io/ssl.rb#147
  def log_transition_state(nextstate); end

  # source://httpx//lib/httpx/io/ssl.rb#135
  def transition(nextstate); end
end

# source://httpx//lib/httpx/io/ssl.rb#10
HTTPX::SSL::TLS_OPTIONS = T.let(T.unsafe(nil), Hash)

# Implements the selector loop, where it registers and monitors "Selectable" objects.
#
# A Selectable object is an object which can calculate the **interests** (<tt>:r</tt>, <tt>:w</tt> or <tt>:rw</tt>,
# respectively "read", "write" or "read-write") it wants to monitor for, and returns (via <tt>to_io</tt> method) an
# IO object which can be passed to functions such as IO.select . More exhaustively, a Selectable **must** implement
# the following methods:
#
# state :: returns the state as a Symbol, must return <tt>:closed</tt> when disposed of resources.
# to_io :: returns the IO object.
# call :: gets called when the IO is ready.
# interests :: returns the current interests to monitor for, as described above.
# timeout :: returns nil or an integer, representing how long to wait for interests.
# handle_socket_timeout(Numeric) :: called when waiting for interest times out.
#
# source://httpx//lib/httpx/selector.rb#21
class HTTPX::Selector
  extend ::Forwardable

  # @return [Selector] a new instance of Selector
  #
  # source://httpx//lib/httpx/selector.rb#34
  def initialize; end

  # source://httpx//lib/httpx/selector.rb#30
  def after(*args, **_arg1, &block); end

  # deregisters +io+ from selectables.
  #
  # source://httpx//lib/httpx/selector.rb#127
  def deregister(io); end

  # source://httpx//lib/httpx/selector.rb#40
  def each(&blk); end

  # source://httpx//lib/httpx/selector.rb#101
  def each_connection(&block); end

  # source://httpx//lib/httpx/selector.rb#32
  def empty?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/selector.rb#114
  def find_connection(request_uri, options); end

  # source://httpx//lib/httpx/selector.rb#120
  def find_mergeable_connection(connection); end

  # source://httpx//lib/httpx/selector.rb#93
  def find_resolver(options); end

  # source://httpx//lib/httpx/selector.rb#44
  def next_tick; end

  # register +io+.
  #
  # source://httpx//lib/httpx/selector.rb#132
  def register(io); end

  # source://httpx//lib/httpx/selector.rb#77
  def terminate; end

  private

  # source://httpx//lib/httpx/selector.rb#246
  def next_timeout; end

  # source://httpx//lib/httpx/selector.rb#269
  def rw_wait(io, interval); end

  # source://httpx//lib/httpx/selector.rb#140
  def select(interval, &block); end

  # source://httpx//lib/httpx/selector.rb#208
  def select_many(r, w, interval, &block); end

  # @yield [io]
  #
  # source://httpx//lib/httpx/selector.rb#230
  def select_one(io, interests, interval); end
end

# source://httpx//lib/httpx/selector.rb#24
HTTPX::Selector::READABLE = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/selector.rb#25
HTTPX::Selector::WRITABLE = T.let(T.unsafe(nil), Array)

# Class implementing the APIs being used publicly.
#
#   HTTPX.get(..) #=> delegating to an internal HTTPX::Session object.
#   HTTPX.plugin(..).get(..) #=> creating an intermediate HTTPX::Session with plugin, then sending the GET request
#
# source://httpx//lib/httpx/session.rb#8
class HTTPX::Session
  include ::HTTPX::Loggable
  include ::HTTPX::Chainable

  # initializes the session with a set of +options+, which will be shared by all
  # requests sent from it.
  #
  # When pass a block, it'll yield itself to it, then closes after the block is evaluated.
  #
  # @return [Session] a new instance of Session
  #
  # source://httpx//lib/httpx/session.rb#16
  def initialize(options = T.unsafe(nil), &blk); end

  # returns a HTTP::Request instance built from the HTTP +verb+, the request +uri+, and
  # the optional set of request-specific +options+. This request **must** be sent through
  # the same session it was built from.
  #
  #   req = session.build_request("GET", "https://server.com")
  #   resp = session.request(req)
  #
  # source://httpx//lib/httpx/session.rb#114
  def build_request(verb, uri, params = T.unsafe(nil), options = T.unsafe(nil)); end

  # closes all the active connections from the session.
  #
  # when called directly without specifying +selector+, all available connections
  # will be picked up from the connection pool and closed. Connections in use
  # by other sessions, or same session in a different thread, will not be reaped.
  #
  # source://httpx//lib/httpx/session.rb#64
  def close(selector = T.unsafe(nil)); end

  # source://httpx//lib/httpx/session.rb#134
  def deselect_connection(connection, selector, cloned = T.unsafe(nil)); end

  # source://httpx//lib/httpx/session.rb#151
  def deselect_resolver(resolver, selector); end

  # returns the HTTPX::Connection through which the +request+ should be sent through.
  #
  # source://httpx//lib/httpx/session.rb#179
  def find_connection(request_uri, selector, options); end

  # source://httpx//lib/httpx/session.rb#127
  def pin_connection(connection, selector); end

  # performs one, or multple requests; it accepts:
  #
  # 1. one or multiple HTTPX::Request objects;
  # 2. an HTTP verb, then a sequence of URIs or URI/options tuples;
  # 3. one or multiple HTTP verb / uri / (optional) options tuples;
  #
  # when present, the set of +options+ kwargs is applied to all of the
  # sent requests.
  #
  # respectively returns a single HTTPX::Response response, or all of them in an Array, in the same order.
  #
  #  resp1 = session.request(req1)
  #  resp1, resp2 = session.request(req1, req2)
  #  resp1 = session.request("GET", "https://server.org/a")
  #  resp1, resp2 = session.request("GET", ["https://server.org/a", "https://server.org/b"])
  #  resp1, resp2 = session.request(["GET", "https://server.org/a"], ["GET", "https://server.org/b"])
  #  resp1 = session.request("POST", "https://server.org/a", form: { "foo" => "bar" })
  #  resp1, resp2 = session.request(["POST", "https://server.org/a", form: { "foo" => "bar" }], ["GET", "https://server.org/b"])
  #  resp1, resp2 = session.request("GET", ["https://server.org/a", "https://server.org/b"], headers: { "x-api-token" => "TOKEN" })
  #
  # @raise [ArgumentError]
  #
  # source://httpx//lib/httpx/session.rb#98
  def request(*args, **params); end

  # source://httpx//lib/httpx/session.rb#122
  def select_connection(connection, selector); end

  # source://httpx//lib/httpx/session.rb#132
  def select_resolver(connection, selector); end

  # source://httpx//lib/httpx/session.rb#163
  def try_clone_connection(connection, selector, family); end

  # Yields itself the block, then closes it after the block is evaluated.
  #
  #   session.wrap do |http|
  #     http.get("https://wikipedia.com")
  #   end # wikipedia connection closes here
  #
  # source://httpx//lib/httpx/session.rb#31
  def wrap; end

  private

  # sends an array of HTTPX::Request objects
  #
  # source://httpx//lib/httpx/session.rb#324
  def _send_requests(requests, selector); end

  # returns a set of HTTPX::Request objects built from the given +args+ and +options+.
  #
  # @raise [ArgumentError]
  #
  # source://httpx//lib/httpx/session.rb#273
  def build_requests(*args, params); end

  # coalesces +conn2+ into +conn1+. if +conn1+ was loaded from the connection pool
  # (it is known via +from_pool+), then it adds its to the +selector+.
  #
  # source://httpx//lib/httpx/session.rb#441
  def coalesce_connections(conn1, conn2, selector, from_pool); end

  # tries deactivating connections in the +selector+, deregistering the ones that have been deactivated.
  #
  # source://httpx//lib/httpx/session.rb#226
  def deactivate(selector); end

  # source://httpx//lib/httpx/session.rb#302
  def do_init_connection(connection, selector); end

  # returns the corresponding HTTP::Response to the given +request+ if it has been received.
  #
  # source://httpx//lib/httpx/session.rb#243
  def fetch_response(request, _selector, _options); end

  # source://httpx//lib/httpx/session.rb#425
  def find_resolver_for(connection, selector); end

  # source://httpx//lib/httpx/session.rb#459
  def get_current_selector; end

  # callback executed when an HTTP/2 promise frame has been received.
  #
  # source://httpx//lib/httpx/session.rb#237
  def on_promise(_, stream); end

  # source://httpx//lib/httpx/session.rb#418
  def on_resolver_close(resolver, selector); end

  # source://httpx//lib/httpx/session.rb#401
  def on_resolver_connection(connection, selector); end

  # returns the array of HTTPX::Response objects corresponding to the array of HTTPX::Request +requests+.
  #
  # source://httpx//lib/httpx/session.rb#331
  def receive_requests(requests, selector); end

  # source://httpx//lib/httpx/session.rb#382
  def resolve_connection(connection, selector); end

  # source://httpx//lib/httpx/session.rb#216
  def selector_close(selector); end

  # source://httpx//lib/httpx/session.rb#471
  def selector_store; end

  # sends the +request+ to the corresponding HTTPX::Connection
  #
  # source://httpx//lib/httpx/session.rb#254
  def send_request(request, selector, options = T.unsafe(nil)); end

  # sends an array of HTTPX::Request +requests+, returns the respective array of HTTPX::Response objects.
  #
  # source://httpx//lib/httpx/session.rb#307
  def send_requests(*requests); end

  # source://httpx//lib/httpx/session.rb#463
  def set_current_selector(selector); end

  # source://httpx//lib/httpx/session.rb#298
  def set_request_callbacks(request); end

  # source://httpx//lib/httpx/session.rb#481
  def thread_selector_store(th); end

  class << self
    # source://httpx//lib/httpx/session.rb#585
    def after_fork; end

    # Returns the value of attribute default_options.
    #
    # source://httpx//lib/httpx/session.rb#490
    def default_options; end

    # @private
    #
    # source://httpx//lib/httpx/session.rb#492
    def inherited(klass); end

    # returns a new HTTPX::Session instance, with the plugin pointed by +pl+ loaded.
    #
    #   session_with_retries = session.plugin(:retries)
    #   session_with_custom = session.plugin(CustomPlugin)
    #
    # @raise [ArgumentError]
    #
    # source://httpx//lib/httpx/session.rb#504
    def plugin(pl, options = T.unsafe(nil), &block); end
  end
end

# source://httpx//lib/httpx/session.rb#591
module HTTPX::Session::ForkTracker
  # source://httpx//lib/httpx/session.rb#592
  def _fork; end
end

# source://httpx//lib/httpx/session.rb#582
HTTPX::Session::INSTANCES = T.let(T.unsafe(nil), ObjectSpace::WeakMap)

# Error raised when there was a timeout while waiting for the HTTP/2 settings frame from the server.
#
# source://httpx//lib/httpx/errors.rb#66
class HTTPX::SettingsTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/io/tcp.rb#6
class HTTPX::TCP
  include ::HTTPX::Loggable

  # @return [TCP] a new instance of TCP
  #
  # source://httpx//lib/httpx/io/tcp.rb#15
  def initialize(origin, addresses, options); end

  # source://httpx//lib/httpx/io/tcp.rb#50
  def add_addresses(addrs); end

  # Returns the value of attribute addresses.
  #
  # source://httpx//lib/httpx/io/tcp.rb#11
  def addresses; end

  # eliminates expired entries and returns whether there are still any left.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#64
  def addresses?; end

  # source://httpx//lib/httpx/io/tcp.rb#181
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#195
  def closed?; end

  # source://httpx//lib/httpx/io/tcp.rb#88
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#191
  def connected?; end

  # Returns the value of attribute ip.
  #
  # source://httpx//lib/httpx/io/tcp.rb#13
  def host; end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/tcp.rb#200
  def inspect; end

  # Returns the value of attribute interests.
  #
  # source://httpx//lib/httpx/io/tcp.rb#11
  def interests; end

  # Returns the value of attribute ip.
  #
  # source://httpx//lib/httpx/io/tcp.rb#11
  def ip; end

  # Returns the value of attribute port.
  #
  # source://httpx//lib/httpx/io/tcp.rb#11
  def port; end

  # source://httpx//lib/httpx/io/tcp.rb#84
  def protocol; end

  # source://httpx//lib/httpx/io/tcp.rb#158
  def read(size, buffer); end

  # source://httpx//lib/httpx/io/tcp.rb#46
  def socket; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/io/tcp.rb#11
  def state; end

  # source://httpx//lib/httpx/io/tcp.rb#80
  def to_io; end

  # source://httpx//lib/httpx/io/tcp.rb#170
  def write(buffer); end

  private

  # source://httpx//lib/httpx/io/tcp.rb#212
  def build_socket; end

  # source://httpx//lib/httpx/io/tcp.rb#228
  def do_transition(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#233
  def log_transition_state(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#217
  def transition(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#140
  def try_connect; end
end

# source://httpx//lib/httpx/io/ssl.rb#6
HTTPX::TLSError = OpenSSL::SSL::SSLError

# Error raised when there was a timeout. Its subclasses allow for finer-grained
# control of which timeout happened.
#
# source://httpx//lib/httpx/errors.rb#13
class HTTPX::TimeoutError < ::HTTPX::Error
  # initializes the timeout exception with the +timeout+ causing the error, and the
  # error +message+ for it.
  #
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://httpx//lib/httpx/errors.rb#19
  def initialize(timeout, message); end

  # The timeout value which caused this error to be raised.
  #
  # source://httpx//lib/httpx/errors.rb#15
  def timeout; end

  # clones this error into a HTTPX::ConnectionTimeoutError.
  #
  # source://httpx//lib/httpx/errors.rb#25
  def to_connection_error; end
end

# source://httpx//lib/httpx/timers.rb#4
class HTTPX::Timers
  # @return [Timers] a new instance of Timers
  #
  # source://httpx//lib/httpx/timers.rb#5
  def initialize; end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/timers.rb#9
  def after(interval_in_secs, cb = T.unsafe(nil), &blk); end

  # source://httpx//lib/httpx/timers.rb#41
  def fire(error = T.unsafe(nil)); end

  # source://httpx//lib/httpx/timers.rb#31
  def wait_interval; end

  private

  # source://httpx//lib/httpx/timers.rb#56
  def drop_elapsed!(elapsed_time = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/timers.rb#77
class HTTPX::Timers::Interval
  include ::Comparable

  # @return [Interval] a new instance of Interval
  #
  # source://httpx//lib/httpx/timers.rb#82
  def initialize(interval); end

  # source://httpx//lib/httpx/timers.rb#101
  def <<(callback); end

  # source://httpx//lib/httpx/timers.rb#87
  def <=>(other); end

  # source://httpx//lib/httpx/timers.rb#91
  def ==(other); end

  # source://httpx//lib/httpx/timers.rb#105
  def delete(callback); end

  # source://httpx//lib/httpx/timers.rb#117
  def elapse(elapsed); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/timers.rb#113
  def elapsed?(elapsed = T.unsafe(nil)); end

  # Returns the value of attribute interval.
  #
  # source://httpx//lib/httpx/timers.rb#80
  def interval; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/timers.rb#109
  def no_callbacks?; end

  # source://httpx//lib/httpx/timers.rb#97
  def to_f; end
end

# source://httpx//lib/httpx/timers.rb#66
class HTTPX::Timers::Timer
  # @return [Timer] a new instance of Timer
  #
  # source://httpx//lib/httpx/timers.rb#67
  def initialize(interval, callback); end

  # source://httpx//lib/httpx/timers.rb#72
  def cancel; end
end

# source://httpx//lib/httpx/transcoder.rb#4
module HTTPX::Transcoder
  private

  # source://httpx//lib/httpx/transcoder.rb#7
  def normalize_keys(key, value, cond = T.unsafe(nil), &block); end

  # based on https://github.com/rack/rack/blob/d15dd728440710cfc35ed155d66a98dc2c07ae42/lib/rack/query_parser.rb#L82
  #
  # source://httpx//lib/httpx/transcoder.rb#28
  def normalize_query(params, name, v, depth); end

  # source://httpx//lib/httpx/transcoder.rb#71
  def params_hash_has_key?(hash, key); end

  class << self
    # source://httpx//lib/httpx/transcoder.rb#7
    def normalize_keys(key, value, cond = T.unsafe(nil), &block); end

    # based on https://github.com/rack/rack/blob/d15dd728440710cfc35ed155d66a98dc2c07ae42/lib/rack/query_parser.rb#L82
    #
    # @raise [Error]
    #
    # source://httpx//lib/httpx/transcoder.rb#28
    def normalize_query(params, name, v, depth); end

    # @return [Boolean]
    #
    # source://httpx//lib/httpx/transcoder.rb#71
    def params_hash_has_key?(hash, key); end
  end
end

# source://httpx//lib/httpx/transcoder/body.rb#6
module HTTPX::Transcoder::Body
  private

  # source://httpx//lib/httpx/transcoder/body.rb#39
  def encode(body); end

  class << self
    # source://httpx//lib/httpx/transcoder/body.rb#39
    def encode(body); end
  end
end

# source://httpx//lib/httpx/transcoder/body.rb#11
class HTTPX::Transcoder::Body::Encoder < ::SimpleDelegator
  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/body.rb#12
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/body.rb#18
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/body.rb#34
  def content_type; end
end

# source://httpx//lib/httpx/transcoder/body.rb#7
class HTTPX::Transcoder::Body::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/transcoder/utils/body_reader.rb#7
class HTTPX::Transcoder::BodyReader
  # @return [BodyReader] a new instance of BodyReader
  #
  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#8
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#19
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#41
  def close; end

  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#25
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#6
module HTTPX::Transcoder::Chunker
  private

  # source://httpx//lib/httpx/transcoder/chunker.rb#111
  def encode(chunks); end

  class << self
    # source://httpx//lib/httpx/transcoder/chunker.rb#111
    def encode(chunks); end
  end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#9
HTTPX::Transcoder::Chunker::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/transcoder/chunker.rb#32
class HTTPX::Transcoder::Chunker::Decoder
  extend ::Forwardable

  # @return [Decoder] a new instance of Decoder
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#41
  def initialize(buffer, trailers = T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/chunker.rb#37
  def <<(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/chunker.rb#39
  def clear(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/chunker.rb#53
  def each; end

  # source://httpx//lib/httpx/transcoder/chunker.rb#35
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#98
  def finished?; end

  # source://httpx//lib/httpx/transcoder/chunker.rb#49
  def to_s; end

  private

  # source://httpx//lib/httpx/transcoder/chunker.rb#104
  def nextstate(state); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#11
class HTTPX::Transcoder::Chunker::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#14
  def initialize(body); end

  # @yield ["0#{CRLF}"]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#18
  def each; end

  private

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#27
  def respond_to_missing?(meth, *args); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#7
class HTTPX::Transcoder::Chunker::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/transcoder/deflate.rb#8
module HTTPX::Transcoder::Deflate
  private

  # source://httpx//lib/httpx/transcoder/deflate.rb#31
  def decode(response, bytesize: T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/deflate.rb#27
  def encode(body); end

  class << self
    # source://httpx//lib/httpx/transcoder/deflate.rb#31
    def decode(response, bytesize: T.unsafe(nil)); end

    # source://httpx//lib/httpx/transcoder/deflate.rb#27
    def encode(body); end
  end
end

# source://httpx//lib/httpx/transcoder/deflate.rb#9
class HTTPX::Transcoder::Deflate::Deflater < ::HTTPX::Transcoder::Deflater
  # source://httpx//lib/httpx/transcoder/deflate.rb#10
  def deflate(chunk); end
end

# source://httpx//lib/httpx/transcoder/utils/deflater.rb#7
class HTTPX::Transcoder::Deflater
  # @return [Deflater] a new instance of Deflater
  #
  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#10
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#16
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#41
  def close; end

  # Returns the value of attribute content_type.
  #
  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#8
  def content_type; end

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#22
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#51
  def rewind; end

  private

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#60
  def buffer_deflate!; end
end

# source://httpx//lib/httpx/transcoder/form.rb#9
module HTTPX::Transcoder::Form
  private

  # source://httpx//lib/httpx/transcoder/form.rb#54
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/form.rb#50
  def encode(form); end

  class << self
    # source://httpx//lib/httpx/transcoder/form.rb#54
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/form.rb#50
    def encode(form); end
  end
end

# source://httpx//lib/httpx/transcoder/form.rb#40
module HTTPX::Transcoder::Form::Decoder
  private

  # source://httpx//lib/httpx/transcoder/form.rb#43
  def call(response, *_arg1); end

  class << self
    # source://httpx//lib/httpx/transcoder/form.rb#43
    def call(response, *_arg1); end
  end
end

# source://httpx//lib/httpx/transcoder/form.rb#14
class HTTPX::Transcoder::Form::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/form.rb#25
  def initialize(form); end

  # source://httpx//lib/httpx/transcoder/form.rb#23
  def ==(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/form.rb#21
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/form.rb#35
  def content_type; end

  # source://httpx//lib/httpx/transcoder/form.rb#17
  def to_s(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/form.rb#19
  def to_str(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/transcoder/form.rb#12
HTTPX::Transcoder::Form::PARAM_DEPTH_LIMIT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/transcoder/gzip.rb#7
module HTTPX::Transcoder::GZIP
  private

  # source://httpx//lib/httpx/transcoder/gzip.rb#65
  def decode(response, bytesize: T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/gzip.rb#61
  def encode(body); end

  class << self
    # source://httpx//lib/httpx/transcoder/gzip.rb#65
    def decode(response, bytesize: T.unsafe(nil)); end

    # source://httpx//lib/httpx/transcoder/gzip.rb#61
    def encode(body); end
  end
end

# source://httpx//lib/httpx/transcoder/gzip.rb#8
class HTTPX::Transcoder::GZIP::Deflater < ::HTTPX::Transcoder::Deflater
  # @return [Deflater] a new instance of Deflater
  #
  # source://httpx//lib/httpx/transcoder/gzip.rb#9
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/gzip.rb#14
  def deflate(chunk); end

  private

  # source://httpx//lib/httpx/transcoder/gzip.rb#35
  def compressed_chunk; end

  # source://httpx//lib/httpx/transcoder/gzip.rb#31
  def write(chunk); end
end

# source://httpx//lib/httpx/transcoder/gzip.rb#42
class HTTPX::Transcoder::GZIP::Inflater
  # @return [Inflater] a new instance of Inflater
  #
  # source://httpx//lib/httpx/transcoder/gzip.rb#43
  def initialize(bytesize); end

  # source://httpx//lib/httpx/transcoder/gzip.rb#48
  def call(chunk); end
end

# source://httpx//lib/httpx/transcoder/json.rb#6
module HTTPX::Transcoder::JSON
  private

  # source://httpx//lib/httpx/transcoder/json.rb#46
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/json.rb#42
  def encode(json); end

  # source://httpx//lib/httpx/transcoder/json.rb#57
  def json_dump(*args); end

  # source://httpx//lib/httpx/transcoder/json.rb#56
  def json_load(*args); end

  class << self
    # @raise [HTTPX::Error]
    #
    # source://httpx//lib/httpx/transcoder/json.rb#46
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/json.rb#42
    def encode(json); end

    # source://httpx//lib/httpx/transcoder/json.rb#57
    def json_dump(*args); end

    # source://httpx//lib/httpx/transcoder/json.rb#56
    def json_load(*args); end
  end
end

# source://httpx//lib/httpx/transcoder/json.rb#23
class HTTPX::Transcoder::JSON::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/json.rb#32
  def initialize(json); end

  # source://httpx//lib/httpx/transcoder/json.rb#30
  def ==(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/json.rb#28
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/json.rb#37
  def content_type; end

  # source://httpx//lib/httpx/transcoder/json.rb#26
  def to_s(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/transcoder/json.rb#9
HTTPX::Transcoder::JSON::JSON_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/encoder.rb#4
module HTTPX::Transcoder::Multipart
  private

  # source://httpx//lib/httpx/transcoder/multipart.rb#27
  def encode(form_data); end

  # source://httpx//lib/httpx/transcoder/multipart.rb#19
  def multipart?(form_data); end

  class << self
    # source://httpx//lib/httpx/transcoder/multipart.rb#27
    def encode(form_data); end

    # @return [Boolean]
    #
    # source://httpx//lib/httpx/transcoder/multipart.rb#19
    def multipart?(form_data); end
  end
end

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#21
class HTTPX::Transcoder::Multipart::Decoder
  include ::HTTPX::Utils

  # @return [Decoder] a new instance of Decoder
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#31
  def initialize(response); end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#44
  def call(response, *_arg1); end

  private

  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#58
  def parse; end
end

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#25
HTTPX::Transcoder::Multipart::Decoder::BOUNDARY_RE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#24
HTTPX::Transcoder::Multipart::Decoder::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#27
HTTPX::Transcoder::Multipart::Decoder::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#28
HTTPX::Transcoder::Multipart::Decoder::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#26
HTTPX::Transcoder::Multipart::Decoder::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#29
HTTPX::Transcoder::Multipart::Decoder::WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/transcoder/multipart/encoder.rb#5
class HTTPX::Transcoder::Multipart::Encoder
  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#8
  def initialize(form); end

  # Returns the value of attribute bytesize.
  #
  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#6
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#18
  def content_type; end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#28
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#37
  def rewind; end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#22
  def to_s; end

  private

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#80
  def header_part(key, content_type, filename); end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#88
  def read_chunks(buffer, length = T.unsafe(nil)); end

  # if there's a current part to read from, tries to read a chunk.
  #
  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#105
  def read_from_part(max_length = T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#54
  def to_parts(form); end
end

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#9
class HTTPX::Transcoder::Multipart::FilePart < ::SimpleDelegator
  # @return [FilePart] a new instance of FilePart
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#12
  def initialize(filename, content_type); end

  # Returns the value of attribute content_type.
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#10
  def content_type; end

  # Returns the value of attribute original_filename.
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#10
  def original_filename; end
end

# source://httpx//lib/httpx/transcoder/multipart.rb#10
HTTPX::Transcoder::Multipart::MULTIPART_VALUE_COND = T.let(T.unsafe(nil), Proc)

# source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#5
module HTTPX::Transcoder::Multipart::MimeTypeDetector
  private

  # source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#26
  def call(file, filename); end

  class << self
    # source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#26
    def call(file, filename); end
  end
end

# source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#8
HTTPX::Transcoder::Multipart::MimeTypeDetector::DEFAULT_MIMETYPE = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/transcoder/multipart/part.rb#5
module HTTPX::Transcoder::Multipart::Part
  private

  # source://httpx//lib/httpx/transcoder/multipart/part.rb#8
  def call(value); end

  class << self
    # source://httpx//lib/httpx/transcoder/multipart/part.rb#8
    def call(value); end
  end
end

# source://httpx//lib/httpx/io/udp.rb#6
class HTTPX::UDP
  include ::HTTPX::Loggable

  # @return [UDP] a new instance of UDP
  #
  # source://httpx//lib/httpx/io/udp.rb#9
  def initialize(ip, port, options); end

  # source://httpx//lib/httpx/io/udp.rb#26
  def close; end

  # source://httpx//lib/httpx/io/udp.rb#20
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/udp.rb#22
  def connected?; end

  # source://httpx//lib/httpx/io/udp.rb#51
  def read(size, buffer); end

  # source://httpx//lib/httpx/io/udp.rb#16
  def to_io; end

  # In JRuby, sendmsg_nonblock is not implemented
  #
  # source://httpx//lib/httpx/io/udp.rb#39
  def write(buffer); end
end

# source://httpx//lib/httpx/io/unix.rb#4
class HTTPX::UNIX < ::HTTPX::TCP
  # @return [UNIX] a new instance of UNIX
  #
  # source://httpx//lib/httpx/io/unix.rb#11
  def initialize(origin, path, options); end

  # the path is always explicitly passed, so no point in resolving.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/unix.rb#55
  def addresses?; end

  # source://httpx//lib/httpx/io/unix.rb#37
  def connect; end

  # Returns the value of attribute path.
  #
  # source://httpx//lib/httpx/io/unix.rb#9
  def host; end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/unix.rb#60
  def inspect; end

  # Returns the value of attribute path.
  #
  # source://httpx//lib/httpx/io/unix.rb#7
  def path; end

  private

  # source://httpx//lib/httpx/io/unix.rb#67
  def build_socket; end
end

# source://httpx//lib/httpx/extensions.rb#36
module HTTPX::URIExtensions; end

# source://httpx//lib/httpx/errors.rb#7
class HTTPX::UnsupportedSchemeError < ::HTTPX::Error; end

# source://httpx//lib/httpx/utils.rb#4
module HTTPX::Utils
  private

  # source://httpx//lib/httpx/utils.rb#18
  def elapsed_time(monotonic_timestamp); end

  # source://httpx//lib/httpx/utils.rb#33
  def get_filename(header, _prefix_regex = T.unsafe(nil)); end

  # source://httpx//lib/httpx/utils.rb#14
  def now; end

  # The value of this field can be either an HTTP-date or a number of
  # seconds to delay after the response is received.
  #
  # source://httpx//lib/httpx/utils.rb#24
  def parse_retry_after(retry_after); end

  # source://httpx//lib/httpx/utils.rb#59
  def to_uri(uri); end

  class << self
    # source://httpx//lib/httpx/utils.rb#18
    def elapsed_time(monotonic_timestamp); end

    # source://httpx//lib/httpx/utils.rb#33
    def get_filename(header, _prefix_regex = T.unsafe(nil)); end

    # source://httpx//lib/httpx/utils.rb#14
    def now; end

    # The value of this field can be either an HTTP-date or a number of
    # seconds to delay after the response is received.
    #
    # source://httpx//lib/httpx/utils.rb#24
    def parse_retry_after(retry_after); end

    # source://httpx//lib/httpx/utils.rb#59
    def to_uri(uri); end
  end
end

# source://httpx//lib/httpx/utils.rb#10
HTTPX::Utils::FILENAME_EXTENSION_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#9
HTTPX::Utils::FILENAME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#7
HTTPX::Utils::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#57
HTTPX::Utils::URIParser = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# source://httpx//lib/httpx/utils.rb#8
HTTPX::Utils::VALUE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/version.rb#4
HTTPX::VERSION = T.let(T.unsafe(nil), String)

# Error raised when there was a timeout while sending a request from the server.
#
# source://httpx//lib/httpx/errors.rb#63
class HTTPX::WriteTimeoutError < ::HTTPX::RequestTimeoutError; end

module Process
  extend ::SQLite3::ForkSafety::CoreExt
  extend ::HTTPX::Session::ForkTracker
  extend ::ActiveSupport::ForkTracker::CoreExt
  extend ::FFI::ModernForkTracking
end

# source://httpx//lib/httpx/adapters/webmock.rb#3
module WebMock; end

# source://httpx//lib/httpx/adapters/webmock.rb#4
module WebMock::HttpLibAdapters; end

# source://httpx//lib/httpx/adapters/webmock.rb#6
WebMock::HttpLibAdapters::HTTP_REASONS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/adapters/webmock.rb#153
class WebMock::HttpLibAdapters::HttpxAdapter < ::WebMock::HttpLibAdapter
  class << self
    # source://httpx//lib/httpx/adapters/webmock.rb#166
    def disable!; end

    # source://httpx//lib/httpx/adapters/webmock.rb#157
    def enable!; end
  end
end

# HTTPX plugin for webmock.
#
# Requests are "hijacked" at the session, before they're distributed to a connection.
#
# source://httpx//lib/httpx/adapters/webmock.rb#13
module WebMock::HttpLibAdapters::Plugin
  class << self
    # source://httpx//lib/httpx/adapters/webmock.rb#49
    def build_error_response(request, exception); end

    # source://httpx//lib/httpx/adapters/webmock.rb#36
    def build_from_webmock_response(request, webmock_response); end

    # source://httpx//lib/httpx/adapters/webmock.rb#15
    def build_webmock_request_signature(request); end

    # source://httpx//lib/httpx/adapters/webmock.rb#28
    def build_webmock_response(_request, response); end
  end
end

# source://httpx//lib/httpx/adapters/webmock.rb#91
module WebMock::HttpLibAdapters::Plugin::ConnectionMethods
  # source://httpx//lib/httpx/adapters/webmock.rb#92
  def initialize(*_arg0); end

  # source://httpx//lib/httpx/adapters/webmock.rb#103
  def interests; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/adapters/webmock.rb#97
  def open?; end

  # source://httpx//lib/httpx/adapters/webmock.rb#113
  def send(request); end

  # source://httpx//lib/httpx/adapters/webmock.rb#109
  def terminate; end
end

# source://httpx//lib/httpx/adapters/webmock.rb#54
module WebMock::HttpLibAdapters::Plugin::InstanceMethods
  private

  # source://httpx//lib/httpx/adapters/webmock.rb#57
  def do_init_connection(connection, selector); end
end

# source://httpx//lib/httpx/adapters/webmock.rb#83
module WebMock::HttpLibAdapters::Plugin::ResponseBodyMethods
  # source://httpx//lib/httpx/adapters/webmock.rb#84
  def decode_chunk(chunk); end
end

# source://httpx//lib/httpx/adapters/webmock.rb#74
module WebMock::HttpLibAdapters::Plugin::ResponseMethods
  # source://httpx//lib/httpx/adapters/webmock.rb#77
  def initialize(*_arg0); end

  # Returns the value of attribute mocked.
  #
  # source://httpx//lib/httpx/adapters/webmock.rb#75
  def mocked; end

  # Sets the attribute mocked
  #
  # @param value the value to set the attribute mocked to.
  #
  # source://httpx//lib/httpx/adapters/webmock.rb#75
  def mocked=(_arg0); end
end
