# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actioncable-next` gem.
# Please instead update this file by running `bin/tapioca gem actioncable-next`.


# :markup: markdown
# :include: ../README.md
#
# source://actioncable-next//lib/action_cable.rb#57
module ActionCable
  private

  # Singleton instance of the server
  #
  # source://actioncable-next//lib/action_cable.rb#80
  def server; end

  class << self
    # source://actioncable-next//lib/action_cable/deprecator.rb#6
    def deprecator; end

    # Returns the currently loaded version of Action Cable as a `Gem::Version`.
    #
    # source://actioncable-next//lib/action_cable/gem_version.rb#7
    def gem_version; end

    # Singleton instance of the server
    #
    # source://actioncable-next//lib/action_cable.rb#80
    def server; end

    # Returns the currently loaded version of Action Cable as a `Gem::Version`.
    #
    # source://actioncable-next//lib/action_cable/version.rb#9
    def version; end
  end
end

# source://actioncable-next//lib/action_cable/channel/base.rb#9
module ActionCable::Channel; end

# # Action Cable Channel Base
#
# The channel provides the basic structure of grouping behavior into logical
# units when communicating over the WebSocket connection. You can think of a
# channel like a form of controller, but one that's capable of pushing content
# to the subscriber in addition to simply responding to the subscriber's direct
# requests.
#
# Channel instances are long-lived. A channel object will be instantiated when
# the cable consumer becomes a subscriber, and then lives until the consumer
# disconnects. This may be seconds, minutes, hours, or even days. That means you
# have to take special care not to do anything silly in a channel that would
# balloon its memory footprint or whatever. The references are forever, so they
# won't be released as is normally the case with a controller instance that gets
# thrown away after every request.
#
# Long-lived channels (and connections) also mean you're responsible for
# ensuring that the data is fresh. If you hold a reference to a user record, but
# the name is changed while that reference is held, you may be sending stale
# data if you don't take precautions to avoid it.
#
# The upside of long-lived channel instances is that you can use instance
# variables to keep reference to objects that future subscriber requests can
# interact with. Here's a quick example:
#
#     class ChatChannel < ApplicationCable::Channel
#       def subscribed
#         @room = Chat::Room[params[:room_number]]
#       end
#
#       def speak(data)
#         @room.speak data, user: current_user
#       end
#     end
#
# The #speak action simply uses the Chat::Room object that was created when the
# channel was first subscribed to by the consumer when that subscriber wants to
# say something in the room.
#
# ## Action processing
#
# Unlike subclasses of ActionController::Base, channels do not follow a RESTful
# constraint form for their actions. Instead, Action Cable operates through a
# remote-procedure call model. You can declare any public method on the channel
# (optionally taking a `data` argument), and this method is automatically
# exposed as callable to the client.
#
# Example:
#
#     class AppearanceChannel < ApplicationCable::Channel
#       def subscribed
#         @connection_token = generate_connection_token
#       end
#
#       def unsubscribed
#         current_user.disappear @connection_token
#       end
#
#       def appear(data)
#         current_user.appear @connection_token, on: data['appearing_on']
#       end
#
#       def away
#         current_user.away @connection_token
#       end
#
#       private
#         def generate_connection_token
#           SecureRandom.hex(36)
#         end
#     end
#
# In this example, the subscribed and unsubscribed methods are not callable
# methods, as they were already declared in ActionCable::Channel::Base, but
# `#appear` and `#away` are. `#generate_connection_token` is also not callable,
# since it's a private method. You'll see that appear accepts a data parameter,
# which it then uses as part of its model call. `#away` does not, since it's
# simply a trigger action.
#
# Also note that in this example, `current_user` is available because it was
# marked as an identifying attribute on the connection. All such identifiers
# will automatically create a delegation method of the same name on the channel
# instance.
#
# ## Rejecting subscription requests
#
# A channel can reject a subscription request in the #subscribed callback by
# invoking the #reject method:
#
#     class ChatChannel < ApplicationCable::Channel
#       def subscribed
#         @room = Chat::Room[params[:room_number]]
#         reject unless current_user.can_access?(@room)
#       end
#     end
#
# In this example, the subscription will be rejected if the `current_user` does
# not have access to the chat room. On the client-side, the `Channel#rejected`
# callback will get invoked when the server rejects the subscription request.
#
# source://actioncable-next//lib/action_cable/channel/base.rb#109
class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  include ::ActiveSupport::Rescuable
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods

  # @return [Base] a new instance of Base
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def initialize(connection, identifier, params = T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#110
  def __callbacks; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#110
  def _run_subscribe_callbacks(&block); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#110
  def _run_subscribe_callbacks!(&block); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#110
  def _run_unsubscribe_callbacks(&block); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#110
  def _run_unsubscribe_callbacks!(&block); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#110
  def _subscribe_callbacks; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#110
  def _unsubscribe_callbacks; end

  # Returns the value of attribute connection.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#117
  def connection; end

  # Returns the value of attribute identifier.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#117
  def identifier; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#118
  def logger(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute params.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#117
  def params; end

  # Extract the action name from the passed data and process it via the channel.
  # The process will ensure that the action requested is a public method on the
  # channel declared by the user (so not one of the callbacks like #subscribed).
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def perform_action(data); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#111
  def periodic_timers=(_arg0); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#115
  def rescue_handlers; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#115
  def rescue_handlers=(_arg0); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#115
  def rescue_handlers?; end

  # This method is called after subscription has been added to the connection and
  # confirms or rejects the subscription.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def subscribe_to_channel; end

  # Called by the cable connection when it's cut, so the channel has a chance to
  # cleanup with callbacks. This method is not intended to be called directly by
  # the user. Instead, override the #unsubscribed callback.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def unsubscribe_from_channel; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def unsubscribed?; end

  private

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def action_signature(action, data); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def defer_subscription_confirmation!; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def defer_subscription_confirmation?; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def delegate_connection_identifiers; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def dispatch_action(action, data); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def ensure_confirmation_sent; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def extract_action(data); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def parameter_filter; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def processable_action?(action); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def reject; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def reject_subscription; end

  # Called once a consumer has become a subscriber of the channel. Usually the
  # place to set up any streams you want this channel to be sending to the
  # subscriber.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def subscribed; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def subscription_confirmation_sent?; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def subscription_rejected?; end

  # Transmit a hash of data to the subscriber. The hash will automatically be
  # wrapped in a JSON envelope with the proper channel identifier marked as the
  # recipient.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def transmit(data, via: T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def transmit_subscription_confirmation; end

  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def transmit_subscription_rejection; end

  # Called once a consumer has cut its cable connection. Can be used for cleaning
  # up connections or marking users as offline or the like.
  #
  # source://actioncable-next//lib/action_cable/channel/base.rb#157
  def unsubscribed; end

  class << self
    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def __callbacks; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def __callbacks=(value); end

    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def _subscribe_callbacks; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def _subscribe_callbacks=(value); end

    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def _unsubscribe_callbacks; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def _unsubscribe_callbacks=(value); end

    # A list of method names that should be considered actions. This includes all
    # public instance methods on a channel, less any internal methods (defined on
    # Base), adding back in any methods that are internal, but still exist on the
    # class itself.
    #
    # #### Returns
    # *   `Set` - A set of all methods that should be considered actions.
    #
    # source://actioncable-next//lib/action_cable/channel/base.rb#128
    def action_methods; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#111
    def periodic_timers; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#111
    def periodic_timers=(value); end

    # source://actioncable-next//lib/action_cable/channel/base.rb#111
    def periodic_timers?; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#115
    def rescue_handlers; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#115
    def rescue_handlers=(value); end

    # source://actioncable-next//lib/action_cable/channel/base.rb#115
    def rescue_handlers?; end

    private

    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def __class_attr___callbacks; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#110
    def __class_attr___callbacks=(new_value); end

    # source://actioncable-next//lib/action_cable/channel/base.rb#111
    def __class_attr_periodic_timers; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#111
    def __class_attr_periodic_timers=(new_value); end

    # source://actioncable-next//lib/action_cable/channel/base.rb#115
    def __class_attr_rescue_handlers; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#115
    def __class_attr_rescue_handlers=(new_value); end

    # action_methods are cached and there is sometimes need to refresh them.
    # ::clear_action_methods! allows you to do that, so next time you run
    # action_methods, they will be recalculated.
    #
    # source://actioncable-next//lib/action_cable/channel/base.rb#147
    def clear_action_methods!; end

    # source://actioncable-next//lib/action_cable/channel/base.rb#151
    def internal_methods; end

    # Refresh the cached action_methods when a new action_method is added.
    #
    # source://actioncable-next//lib/action_cable/channel/base.rb#156
    def method_added(name); end
  end
end

# source://actioncable-next//lib/action_cable/channel/broadcasting.rb#9
module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Broadcasting::ClassMethods

  # source://actioncable-next//lib/action_cable/channel/broadcasting.rb#45
  def broadcast_to(model, message); end

  # source://actioncable-next//lib/action_cable/channel/broadcasting.rb#41
  def broadcasting_for(model); end
end

# source://actioncable-next//lib/action_cable/channel/broadcasting.rb#12
module ActionCable::Channel::Broadcasting::ClassMethods
  # Broadcast a hash to a unique broadcasting for this array of `broadcastables` in this channel.
  #
  # source://actioncable-next//lib/action_cable/channel/broadcasting.rb#14
  def broadcast_to(broadcastables, message); end

  # Returns a unique broadcasting identifier for this `model` in this channel:
  #
  #     CommentsChannel.broadcasting_for("all") # => "comments:all"
  #
  # You can pass an array of objects as a target (e.g. Active Record model), and it would
  # be serialized into a string under the hood.
  #
  # source://actioncable-next//lib/action_cable/channel/broadcasting.rb#24
  def broadcasting_for(broadcastables); end

  private

  # source://actioncable-next//lib/action_cable/channel/broadcasting.rb#29
  def serialize_broadcasting(object); end
end

# # Action Cable Channel Callbacks
#
# Action Cable Channel provides callback hooks that are invoked during the life
# cycle of a channel:
#
# *   [before_subscribe](rdoc-ref:ClassMethods#before_subscribe)
# *   [after_subscribe](rdoc-ref:ClassMethods#after_subscribe) (aliased as
#     [on_subscribe](rdoc-ref:ClassMethods#on_subscribe))
# *   [before_unsubscribe](rdoc-ref:ClassMethods#before_unsubscribe)
# *   [after_unsubscribe](rdoc-ref:ClassMethods#after_unsubscribe) (aliased as
#     [on_unsubscribe](rdoc-ref:ClassMethods#on_unsubscribe))
#
#
# #### Example
#
#     class ChatChannel < ApplicationCable::Channel
#       after_subscribe :send_welcome_message, unless: :subscription_rejected?
#       after_subscribe :track_subscription
#
#       private
#         def send_welcome_message
#           broadcast_to(...)
#         end
#
#         def track_subscription
#           # ...
#         end
#     end
#
# source://actioncable-next//lib/action_cable/channel/callbacks.rb#38
module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActionCable::Channel::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
  end
end

# source://actioncable-next//lib/action_cable/channel/callbacks.rb#49
module ActionCable::Channel::Callbacks::ClassMethods
  # This callback will be triggered after the Base#subscribed method is called,
  # even if the subscription was rejected with the Base#reject method.
  #
  # To trigger the callback only on successful subscriptions, use the
  # Base#subscription_rejected? method:
  #
  #     after_subscribe :my_method, unless: :subscription_rejected?
  #
  # source://actioncable-next//lib/action_cable/channel/callbacks.rb#62
  def after_subscribe(*methods, &block); end

  # source://actioncable-next//lib/action_cable/channel/callbacks.rb#71
  def after_unsubscribe(*methods, &block); end

  # source://actioncable-next//lib/action_cable/channel/callbacks.rb#50
  def before_subscribe(*methods, &block); end

  # source://actioncable-next//lib/action_cable/channel/callbacks.rb#67
  def before_unsubscribe(*methods, &block); end

  # This callback will be triggered after the Base#subscribed method is called,
  # even if the subscription was rejected with the Base#reject method.
  #
  # To trigger the callback only on successful subscriptions, use the
  # Base#subscription_rejected? method:
  #
  #     after_subscribe :my_method, unless: :subscription_rejected?
  #
  # source://actioncable-next//lib/action_cable/channel/callbacks.rb#65
  def on_subscribe(*methods, &block); end

  # source://actioncable-next//lib/action_cable/channel/callbacks.rb#74
  def on_unsubscribe(*methods, &block); end

  private

  # source://actioncable-next//lib/action_cable/channel/callbacks.rb#77
  def internal_methods; end
end

# source://actioncable-next//lib/action_cable/channel/callbacks.rb#42
ActionCable::Channel::Callbacks::INTERNAL_METHODS = T.let(T.unsafe(nil), Array)

# # Action Cable Channel extensions for testing
#
# Add public aliases for +subscription_confirmation_sent?+ and
# +subscription_rejected?+ and +stream_names+ to access the list of subscribed streams.
#
# source://actioncable-next//lib/action_cable/channel/test_case.rb#24
module ActionCable::Channel::ChannelExt
  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#25
  def confirmed?; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#27
  def rejected?; end

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#29
  def stream_names; end
end

# source://actioncable-next//lib/action_cable/channel/naming.rb#7
module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Naming::ClassMethods

  # source://actioncable-next//lib/action_cable/channel/naming.rb#23
  def channel_name; end
end

# source://actioncable-next//lib/action_cable/channel/naming.rb#10
module ActionCable::Channel::Naming::ClassMethods
  # Returns the name of the channel, underscored, without the `Channel` ending. If
  # the channel is in a namespace, then the namespaces are represented by single
  # colon separators in the channel name.
  #
  #     ChatChannel.channel_name # => 'chat'
  #     Chats::AppearancesChannel.channel_name # => 'chats:appearances'
  #     FooChats::BarAppearancesChannel.channel_name # => 'foo_chats:bar_appearances'
  #
  # source://actioncable-next//lib/action_cable/channel/naming.rb#18
  def channel_name; end
end

# source://actioncable-next//lib/action_cable/channel/test_case.rb#12
class ActionCable::Channel::NonInferrableChannelError < ::StandardError
  # @return [NonInferrableChannelError] a new instance of NonInferrableChannelError
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#13
  def initialize(name); end
end

# source://actioncable-next//lib/action_cable/channel/periodic_timers.rb#7
module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Channel::PeriodicTimers::ClassMethods

  private

  # source://actioncable-next//lib/action_cable/channel/periodic_timers.rb#56
  def active_periodic_timers; end

  # source://actioncable-next//lib/action_cable/channel/periodic_timers.rb#66
  def start_periodic_timer(timer_callback, every:); end

  # source://actioncable-next//lib/action_cable/channel/periodic_timers.rb#60
  def start_periodic_timers; end

  # source://actioncable-next//lib/action_cable/channel/periodic_timers.rb#75
  def stop_periodic_timers; end

  module GeneratedClassMethods
    def periodic_timers; end
    def periodic_timers=(value); end
    def periodic_timers?; end
  end

  module GeneratedInstanceMethods
    def periodic_timers=(value); end
  end
end

# source://actioncable-next//lib/action_cable/channel/periodic_timers.rb#17
module ActionCable::Channel::PeriodicTimers::ClassMethods
  # Periodically performs a task on the channel, like updating an online user
  # counter, polling a backend for new status messages, sending regular
  # "heartbeat" messages, or doing some internal work and giving progress updates.
  #
  # Pass a method name or lambda argument or provide a block to call. Specify the
  # calling period in seconds using the `every:` keyword argument.
  #
  #     periodically :transmit_progress, every: 5.seconds
  #
  #     periodically every: 3.minutes do
  #       transmit action: :update_count, count: current_count
  #     end
  #
  # source://actioncable-next//lib/action_cable/channel/periodic_timers.rb#31
  def periodically(callback_or_method_name = T.unsafe(nil), every:, &block); end
end

# # Action Cable Channel Streams
#
# Streams allow channels to route broadcastings to the subscriber. A
# broadcasting is, as discussed elsewhere, a pubsub queue where any data placed
# into it is automatically sent to the clients that are connected at that time.
# It's purely an online queue, though. If you're not streaming a broadcasting at
# the very moment it sends out an update, you will not get that update, even if
# you connect after it has been sent.
#
# Most commonly, the streamed broadcast is sent straight to the subscriber on
# the client-side. The channel just acts as a connector between the two parties
# (the broadcaster and the channel subscriber). Here's an example of a channel
# that allows subscribers to get all new comments on a given page:
#
#     class CommentsChannel < ApplicationCable::Channel
#       def follow(data)
#         stream_from "comments_for_#{data['recording_id']}"
#       end
#
#       def unfollow
#         stop_all_streams
#       end
#     end
#
# Based on the above example, the subscribers of this channel will get whatever
# data is put into the, let's say, `comments_for_45` broadcasting as soon as
# it's put there.
#
# An example broadcasting for this channel looks like so:
#
#     ActionCable.server.broadcast "comments_for_45", { author: 'DHH', content: 'Rails is just swell' }
#
# If you have a stream that is related to a model, then the broadcasting used
# can be generated from the model and channel. The following example would
# subscribe to a broadcasting like `comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE`.
#
#     class CommentsChannel < ApplicationCable::Channel
#       def subscribed
#         post = Post.find(params[:id])
#         stream_for post
#       end
#     end
#
# You can then broadcast to this channel using:
#
#     CommentsChannel.broadcast_to(@post, @comment)
#
# If you don't just want to parlay the broadcast unfiltered to the subscriber,
# you can also supply a callback that lets you alter what is sent out. The below
# example shows how you can use this to provide performance introspection in the
# process:
#
#     class ChatChannel < ApplicationCable::Channel
#       def subscribed
#         @room = Chat::Room[params[:room_number]]
#
#         stream_for @room, coder: ActiveSupport::JSON do |message|
#           if message['originated_at'].present?
#             elapsed_time = (Time.now.to_f - message['originated_at']).round(2)
#
#             ActiveSupport::Notifications.instrument :performance, measurement: 'Chat.message_delay', value: elapsed_time, action: :timing
#             logger.info "Message took #{elapsed_time}s to arrive"
#           end
#
#           transmit message
#         end
#       end
#     end
#
# You can stop streaming from all broadcasts by calling #stop_all_streams.
#
# source://actioncable-next//lib/action_cable/channel/streams.rb#77
module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern

  # source://actioncable-next//lib/action_cable/channel/streams.rb#153
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # Unsubscribes all streams associated with this channel from the pubsub queue.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#135
  def stop_all_streams; end

  # Unsubscribes streams for the `model`.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#130
  def stop_stream_for(model); end

  # Unsubscribes streams from the named `broadcasting`.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#121
  def stop_stream_from(broadcasting); end

  # Start streaming the pubsub queue for the `broadcastables` in this channel. Optionally,
  # you can pass a `callback` that'll be used instead of the default of just
  # transmitting the updates straight to the subscriber.
  #
  # Pass `coder: ActiveSupport::JSON` to decode messages as JSON before passing to
  # the callback. Defaults to `coder: nil` which does no decoding, passes raw
  # messages.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#116
  def stream_for(broadcastables, *_arg1, **_arg2, &_arg3); end

  # Start streaming from the named `broadcasting` pubsub queue. Optionally, you
  # can pass a `callback` that'll be used instead of the default of just
  # transmitting the updates straight to the subscriber. Pass `coder:
  # ActiveSupport::JSON` to decode messages as JSON before passing to the
  # callback. Defaults to `coder: nil` which does no decoding, passes raw
  # messages.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#90
  def stream_from(broadcasting, callback = T.unsafe(nil), coder: T.unsafe(nil), &block); end

  # Calls stream_for with the given `model` if it's present to start streaming,
  # otherwise rejects the subscription.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#144
  def stream_or_reject_for(model); end

  private

  # May be overridden to change the default stream handling behavior which decodes
  # JSON and transmits to the client.
  #
  # TODO: Tests demonstrating this.
  #
  # TODO: Room for optimization. Update transmit API to be coder-aware so we can
  # no-op when pubsub and connection are both JSON-encoded. Then we can skip
  # decode+encode if we're just proxying messages.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#200
  def default_stream_handler(broadcasting, coder:); end

  # source://actioncable-next//lib/action_cable/channel/streams.rb#221
  def identity_handler; end

  # Optimized stream handler that avoids double JSON encoding/decoding on broadcast
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#174
  def opt_worker_pool_stream_handler(broadcasting); end

  # source://actioncable-next//lib/action_cable/channel/streams.rb#205
  def stream_decoder(handler = T.unsafe(nil), coder:); end

  # May be overridden to add instrumentation, logging, specialized error handling,
  # or other forms of handler decoration.
  #
  # TODO: Tests demonstrating this.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#184
  def stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/channel/streams.rb#213
  def stream_transmitter(handler = T.unsafe(nil), broadcasting:); end

  # source://actioncable-next//lib/action_cable/channel/streams.rb#155
  def streams; end

  # Always wrap the outermost handler to invoke the user handler on the worker
  # pool rather than blocking the event loop.
  #
  # source://actioncable-next//lib/action_cable/channel/streams.rb#161
  def worker_pool_stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end
end

# Superclass for Action Cable channel functional tests.
#
# ## Basic example
#
# Functional tests are written as follows:
# 1.  First, one uses the `subscribe` method to simulate subscription creation.
# 2.  Then, one asserts whether the current state is as expected. "State" can be
#     anything: transmitted messages, subscribed streams, etc.
#
#
# For example:
#
#     class ChatChannelTest < ActionCable::Channel::TestCase
#       def test_subscribed_with_room_number
#         # Simulate a subscription creation
#         subscribe room_number: 1
#
#         # Asserts that the subscription was successfully created
#         assert subscription.confirmed?
#
#         # Asserts that the channel subscribes connection to a stream
#         assert_has_stream "chat_1"
#
#         # Asserts that the channel subscribes connection to a specific
#         # stream created for a model
#         assert_has_stream_for Room.find(1)
#       end
#
#       def test_does_not_stream_with_incorrect_room_number
#         subscribe room_number: -1
#
#         # Asserts that not streams was started
#         assert_no_streams
#       end
#
#       def test_does_not_subscribe_without_room_number
#         subscribe
#
#         # Asserts that the subscription was rejected
#         assert subscription.rejected?
#       end
#     end
#
# You can also perform actions:
#     def test_perform_speak
#       subscribe room_number: 1
#
#       perform :speak, message: "Hello, Rails!"
#
#       assert_equal "Hello, Rails!", transmissions.last["text"]
#     end
#
# ## Special methods
#
# ActionCable::Channel::TestCase will also automatically provide the following
# instance methods for use in the tests:
#
# connection
#     connection.
#
# subscription
#
# transmissions
#
#
# ## Channel is automatically inferred
#
# ActionCable::Channel::TestCase will automatically infer the channel under test
# from the test class name. If the channel cannot be inferred from the test
# class name, you can explicitly set it with `tests`.
#
#     class SpecialEdgeCaseChannelTest < ActionCable::Channel::TestCase
#       tests SpecialChannel
#     end
#
# ## Specifying connection identifiers
#
# You need to set up your connection manually to provide values for the
# identifiers. To do this just use:
#
#     stub_connection(user: users(:john))
#
# ## Testing broadcasting
#
# ActionCable::Channel::TestCase enhances ActionCable::TestHelper assertions
# (e.g. `assert_broadcasts`) to handle broadcasting to models:
#
#     # in your channel
#     def speak(data)
#       broadcast_to room, text: data["message"]
#     end
#
#     def test_speak
#       subscribe room_id: rooms(:chat).id
#
#       assert_broadcast_on(rooms(:chat), text: "Hello, Rails!") do
#         perform :speak, message: "Hello, Rails!"
#       end
#     end
#
# source://actioncable-next//lib/action_cable/channel/test_case.rb#134
class ActionCable::Channel::TestCase < ::ActionCable::Connection::TestCase
  include ::ActionCable::TestHelper
  include ::ActionCable::Channel::TestCase::Behavior
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
  def _channel_class; end

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
  def _channel_class=(_arg0); end

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
  def _channel_class?; end

  class << self
    # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
    def _channel_class; end

    # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
    def _channel_class=(value); end

    # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
    def _channel_class?; end

    private

    # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
    def __class_attr__channel_class; end

    # source://actioncable-next//lib/action_cable/channel/test_case.rb#144
    def __class_attr__channel_class=(new_value); end
  end
end

# source://actioncable-next//lib/action_cable/channel/test_case.rb#135
module ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionCable::Channel::TestCase::Behavior::ClassMethods

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#252
  def assert_broadcast_on(stream_or_object, *args); end

  # Enhance TestHelper assertions to handle non-String broadcastings
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#248
  def assert_broadcasts(stream_or_object, *args); end

  # Asserts that the specified stream has not been started.
  #
  #     def test_assert_no_started_stream
  #       subscribe
  #       assert_has_no_stream 'messages'
  #     end
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#298
  def assert_has_no_stream(stream); end

  # Asserts that the specified stream for a model has not started.
  #
  #     def test_assert_no_started_stream_for
  #       subscribe id: 41
  #       assert_has_no_stream_for User.find(42)
  #     end
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#310
  def assert_has_no_stream_for(object); end

  # Asserts that the specified stream has been started.
  #
  #     def test_assert_started_stream
  #       subscribe
  #       assert_has_stream 'messages'
  #     end
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#275
  def assert_has_stream(stream); end

  # Asserts that the specified stream for a model has started.
  #
  #     def test_assert_started_stream_for
  #       subscribe id: 42
  #       assert_has_stream_for User.find(42)
  #     end
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#287
  def assert_has_stream_for(object); end

  # Asserts that no streams have been started.
  #
  #     def test_assert_no_started_stream
  #       subscribe
  #       assert_no_streams
  #     end
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#263
  def assert_no_streams; end

  # Perform action on a channel.
  #
  # NOTE: Must be subscribed.
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#236
  def perform(action, data = T.unsafe(nil)); end

  # Set up test connection with the specified identifiers:
  #
  #     class ApplicationCable < ActionCable::Connection::Base
  #       identified_by :user, :token
  #     end
  #
  #     stub_connection(user: users[:john], token: 'my-secret-token')
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#207
  def stub_connection(server: T.unsafe(nil), **identifiers); end

  # Subscribe to the channel under test. Optionally pass subscription parameters
  # as a Hash.
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#219
  def subscribe(params = T.unsafe(nil)); end

  # Use testserver (not test_server) to silence "Test is missing assertions: `test_server`" warnings
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#198
  def subscription; end

  # Use testserver (not test_server) to silence "Test is missing assertions: `test_server`" warnings
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#198
  def testserver; end

  # Returns messages transmitted into channel
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#242
  def transmissions; end

  # Unsubscribe the subscription under test.
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#228
  def unsubscribe; end

  private

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#319
  def broadcasting_for(stream_or_object); end

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#315
  def check_subscribed!; end

  module GeneratedClassMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
  end

  module GeneratedInstanceMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
  end
end

# source://actioncable-next//lib/action_cable/channel/test_case.rb#141
ActionCable::Channel::TestCase::Behavior::CHANNEL_IDENTIFIER = T.let(T.unsafe(nil), String)

# source://actioncable-next//lib/action_cable/channel/test_case.rb#149
module ActionCable::Channel::TestCase::Behavior::ClassMethods
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#161
  def channel_class; end

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#180
  def connection_class; end

  # @raise [NonInferrableChannelError]
  #
  # source://actioncable-next//lib/action_cable/channel/test_case.rb#188
  def determine_default_channel(name); end

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#150
  def tests(channel); end

  # source://actioncable-next//lib/action_cable/channel/test_case.rb#169
  def tests_connection(connection); end
end

# source://actioncable-next//lib/action_cable/connection/identification.rb#6
module ActionCable::Connection; end

# source://actioncable-next//lib/action_cable/connection/test_case.rb#22
module ActionCable::Connection::Assertions
  # Asserts that the connection is rejected (via
  # `reject_unauthorized_connection`).
  #
  #     # Asserts that connection without user_id fails
  #     assert_reject_connection { connect params: { user_id: '' } }
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#28
  def assert_reject_connection(&block); end
end

# source://actioncable-next//lib/action_cable/connection/authorization.rb#7
module ActionCable::Connection::Authorization
  # Closes the WebSocket connection if it is open and returns an "unauthorized"
  # reason.
  #
  # @raise [UnauthorizedError]
  #
  # source://actioncable-next//lib/action_cable/connection/authorization.rb#12
  def reject_unauthorized_connection; end
end

# source://actioncable-next//lib/action_cable/connection/authorization.rb#8
class ActionCable::Connection::Authorization::UnauthorizedError < ::StandardError; end

# # Action Cable Connection Base
#
# For every WebSocket connection the Action Cable server accepts, a Connection
# object will be instantiated. This instance becomes the parent of all of the
# channel subscriptions that are created from there on. Incoming messages are
# then routed to these channel subscriptions based on an identifier sent by the
# Action Cable consumer. The Connection itself does not deal with any specific
# application logic beyond authentication and authorization.
#
# Here's a basic example:
#
#     module ApplicationCable
#       class Connection < ActionCable::Connection::Base
#         identified_by :current_user
#
#         def connect
#           self.current_user = find_verified_user
#           logger.add_tags current_user.name
#         end
#
#         def disconnect
#           # Any cleanup work needed when the cable connection is cut.
#         end
#
#         private
#           def find_verified_user
#             User.find_by_identity(cookies.encrypted[:identity_id]) ||
#               reject_unauthorized_connection
#           end
#       end
#     end
#
# First, we declare that this connection can be identified by its current_user.
# This allows us to later be able to find all connections established for that
# current_user (and potentially disconnect them). You can declare as many
# identification indexes as you like. Declaring an identification means that an
# attr_accessor is automatically set for that key.
#
# Second, we rely on the fact that the WebSocket connection is established with
# the cookies from the domain being sent along. This makes it easy to use signed
# cookies that were set when logging in via a web interface to authorize the
# WebSocket connection.
#
# Finally, we add a tag to the connection-specific logger with the name of the
# current user to easily distinguish their messages in the log.
#
# source://actioncable-next//lib/action_cable/connection/base.rb#55
class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Connection::Callbacks
  include ::ActiveSupport::Rescuable
  extend ::ActionCable::Connection::Identification::ClassMethods
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Connection::Callbacks::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods

  # @return [Base] a new instance of Base
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#68
  def initialize(server, socket); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#59
  def __callbacks; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#59
  def _command_callbacks; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#59
  def _run_command_callbacks; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#59
  def _run_command_callbacks!(&block); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#146
  def beat; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#65
  def broadcast(*_arg0, **_arg1, &_arg2); end

  # Close the connection.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#125
  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#65
  def config(*_arg0, **_arg1, &_arg2); end

  # This method is called every time an Action Cable client establishes an underlying connection.
  # Override it in your class to define authentication logic and
  # populate connection identifiers.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#83
  def connect; end

  # This method is called every time an Action Cable client disconnects.
  # Override it in your class to cleanup the relevant application state (e.g., presence, online counts, etc.)
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#88
  def disconnect; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#66
  def env(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#65
  def executor(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#106
  def handle_channel_command(payload); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#99
  def handle_close; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#114
  def handle_incoming(payload); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#91
  def handle_open; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#56
  def identifiers; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#56
  def identifiers=(_arg0); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#56
  def identifiers?; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#150
  def inspect; end

  # Returns the value of attribute logger.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#62
  def logger; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#66
  def perform_work(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#66
  def protocol(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#65
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#120
  def raw_transmit(data); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#66
  def request(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#60
  def rescue_handlers; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#60
  def rescue_handlers=(_arg0); end

  # source://actioncable-next//lib/action_cable/connection/base.rb#60
  def rescue_handlers?; end

  # Return a basic hash of statistics for the connection keyed with `identifier`,
  # `started_at`, `subscriptions`, and `request_id`. This can be returned by a
  # health check against the connection.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#137
  def statistics; end

  # Returns the value of attribute subscriptions.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#62
  def subscriptions; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#116
  def transmit(data); end

  private

  # The cookies of the request that initiated the WebSocket connection. Useful for performing authorization checks.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#156
  def cookies; end

  # source://actioncable-next//lib/action_cable/connection/base.rb#160
  def send_welcome_message; end

  # Returns the value of attribute server.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#63
  def server; end

  # Returns the value of attribute socket.
  #
  # source://actioncable-next//lib/action_cable/connection/base.rb#63
  def socket; end

  class << self
    # source://actioncable-next//lib/action_cable/connection/base.rb#59
    def __callbacks; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#59
    def __callbacks=(value); end

    # source://actioncable-next//lib/action_cable/connection/base.rb#173
    def __restore_visibility__; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#59
    def _command_callbacks; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#59
    def _command_callbacks=(value); end

    # source://actioncable-next//lib/action_cable/connection/base.rb#56
    def identifiers; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#56
    def identifiers=(value); end

    # source://actioncable-next//lib/action_cable/connection/base.rb#56
    def identifiers?; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#60
    def rescue_handlers; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#60
    def rescue_handlers=(value); end

    # source://actioncable-next//lib/action_cable/connection/base.rb#60
    def rescue_handlers?; end

    private

    # source://actioncable-next//lib/action_cable/connection/base.rb#59
    def __class_attr___callbacks; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#59
    def __class_attr___callbacks=(new_value); end

    # source://actioncable-next//lib/action_cable/connection/base.rb#56
    def __class_attr_identifiers; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#56
    def __class_attr_identifiers=(new_value); end

    # source://actioncable-next//lib/action_cable/connection/base.rb#60
    def __class_attr_rescue_handlers; end

    # source://actioncable-next//lib/action_cable/connection/base.rb#60
    def __class_attr_rescue_handlers=(new_value); end
  end
end

# # Action Cable Connection Callbacks
#
# The [before_command](rdoc-ref:ClassMethods#before_command),
# [after_command](rdoc-ref:ClassMethods#after_command), and
# [around_command](rdoc-ref:ClassMethods#around_command) callbacks are invoked
# when sending commands to the client, such as when subscribing, unsubscribing,
# or performing an action.
#
# #### Example
#
#     module ApplicationCable
#       class Connection < ActionCable::Connection::Base
#         identified_by :user
#
#         around_command :set_current_account
#
#         private
#
#         def set_current_account
#           # Now all channels could use Current.account
#           Current.set(account: user.account) { yield }
#         end
#       end
#     end
#
# source://actioncable-next//lib/action_cable/connection/callbacks.rb#34
module ActionCable::Connection::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActionCable::Connection::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
  end
end

# source://actioncable-next//lib/action_cable/connection/callbacks.rb#42
module ActionCable::Connection::Callbacks::ClassMethods
  # source://actioncable-next//lib/action_cable/connection/callbacks.rb#47
  def after_command(*methods, &block); end

  # source://actioncable-next//lib/action_cable/connection/callbacks.rb#51
  def around_command(*methods, &block); end

  # source://actioncable-next//lib/action_cable/connection/callbacks.rb#43
  def before_command(*methods, &block); end
end

# source://actioncable-next//lib/action_cable/connection/identification.rb#7
module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Connection::Identification::ClassMethods

  # Return a single connection identifier that combines the value of all the
  # registered identifiers into a single gid.
  #
  # source://actioncable-next//lib/action_cable/connection/identification.rb#29
  def connection_identifier; end

  private

  # source://actioncable-next//lib/action_cable/connection/identification.rb#38
  def connection_gid(ids); end

  module GeneratedClassMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end

  module GeneratedInstanceMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end
end

# source://actioncable-next//lib/action_cable/connection/identification.rb#14
module ActionCable::Connection::Identification::ClassMethods
  # Mark a key as being a connection identifier index that can then be used to
  # find the specific connection again later. Common identifiers are current_user
  # and current_account, but could be anything, really.
  #
  # Note that anything marked as an identifier will automatically create a
  # delegate by the same name on any channel instances created off the connection.
  #
  # source://actioncable-next//lib/action_cable/connection/identification.rb#21
  def identified_by(*identifiers); end
end

# # Action Cable InternalChannel
#
# Makes it possible for the RemoteConnection to disconnect a specific
# connection.
#
# source://actioncable-next//lib/action_cable/connection/internal_channel.rb#11
module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern

  private

  # source://actioncable-next//lib/action_cable/connection/internal_channel.rb#15
  def internal_channel; end

  # source://actioncable-next//lib/action_cable/connection/internal_channel.rb#36
  def process_internal_message(message); end

  # source://actioncable-next//lib/action_cable/connection/internal_channel.rb#19
  def subscribe_to_internal_channel; end

  # source://actioncable-next//lib/action_cable/connection/internal_channel.rb#30
  def unsubscribe_from_internal_channel; end
end

# source://actioncable-next//lib/action_cable/connection/test_case.rb#14
class ActionCable::Connection::NonInferrableConnectionError < ::StandardError
  # @return [NonInferrableConnectionError] a new instance of NonInferrableConnectionError
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#15
  def initialize(name); end
end

# # Action Cable Connection Subscriptions
#
# Collection class for all the channel subscriptions established on a given
# connection. Responsible for routing incoming commands that arrive on the
# connection to the proper channel.
#
# source://actioncable-next//lib/action_cable/connection/subscriptions.rb#14
class ActionCable::Connection::Subscriptions
  # @return [Subscriptions] a new instance of Subscriptions
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#47
  def initialize(connection); end

  # @raise [MalformedCommandError]
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#62
  def add(data); end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#52
  def execute_command(data); end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#94
  def identifiers; end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#104
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#90
  def perform_action(data); end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#80
  def remove(data); end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#85
  def remove_subscription(subscription); end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#98
  def unsubscribe_from_all; end

  private

  # Returns the value of attribute connection.
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#103
  def connection; end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#106
  def find(data); end

  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#114
  def subscription_from_identifier(id_key); end

  # Returns the value of attribute subscriptions.
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#103
  def subscriptions; end
end

# source://actioncable-next//lib/action_cable/connection/subscriptions.rb#17
class ActionCable::Connection::Subscriptions::AlreadySubscribedError < ::ActionCable::Connection::Subscriptions::Error
  # @return [AlreadySubscribedError] a new instance of AlreadySubscribedError
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#18
  def initialize(identifier); end
end

# source://actioncable-next//lib/action_cable/connection/subscriptions.rb#23
class ActionCable::Connection::Subscriptions::ChannelNotFound < ::ActionCable::Connection::Subscriptions::Error
  # @return [ChannelNotFound] a new instance of ChannelNotFound
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#24
  def initialize(channel_id); end
end

# source://actioncable-next//lib/action_cable/connection/subscriptions.rb#15
class ActionCable::Connection::Subscriptions::Error < ::StandardError; end

# source://actioncable-next//lib/action_cable/connection/subscriptions.rb#29
class ActionCable::Connection::Subscriptions::MalformedCommandError < ::ActionCable::Connection::Subscriptions::Error
  # @return [MalformedCommandError] a new instance of MalformedCommandError
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#30
  def initialize(data); end
end

# source://actioncable-next//lib/action_cable/connection/subscriptions.rb#35
class ActionCable::Connection::Subscriptions::UnknownCommandError < ::ActionCable::Connection::Subscriptions::Error
  # @return [UnknownCommandError] a new instance of UnknownCommandError
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#36
  def initialize(command); end
end

# source://actioncable-next//lib/action_cable/connection/subscriptions.rb#41
class ActionCable::Connection::Subscriptions::UnknownSubscription < ::ActionCable::Connection::Subscriptions::Error
  # @return [UnknownSubscription] a new instance of UnknownSubscription
  #
  # source://actioncable-next//lib/action_cable/connection/subscriptions.rb#42
  def initialize(identifier); end
end

# # Action Cable Connection TestCase
#
# Unit test Action Cable connections.
#
# Useful to check whether a connection's `identified_by` gets assigned properly
# and that any improper connection requests are rejected.
#
# ## Basic example
#
# Unit tests are written by first simulating a connection attempt by calling
# `connect` and then asserting state, e.g. identifiers, have been assigned.
#
#     class ApplicationCable::ConnectionTest < ActionCable::Connection::TestCase
#       def test_connects_with_proper_cookie
#         # Simulate the connection request with a cookie.
#         cookies["user_id"] = users(:john).id
#
#         connect
#
#         # Assert the connection identifier matches the fixture.
#         assert_equal users(:john).id, connection.user.id
#       end
#
#       def test_rejects_connection_without_proper_cookie
#         assert_reject_connection { connect }
#       end
#     end
#
# `connect` accepts additional information about the HTTP request with the
# `params`, `headers`, `session`, and Rack `env` options.
#
#     def test_connect_with_headers_and_query_string
#       connect params: { user_id: 1 }, headers: { "X-API-TOKEN" => "secret-my" }
#
#       assert_equal "1", connection.user.id
#       assert_equal "secret-my", connection.token
#     end
#
#     def test_connect_with_params
#       connect params: { user_id: 1 }
#
#       assert_equal "1", connection.user.id
#     end
#
# You can also set up the correct cookies before the connection request:
#
#     def test_connect_with_cookies
#       # Plain cookies:
#       cookies["user_id"] = 1
#
#       # Or signed/encrypted:
#       # cookies.signed["user_id"] = 1
#       # cookies.encrypted["user_id"] = 1
#
#       connect
#
#       assert_equal "1", connection.user_id
#     end
#
# ## Connection is automatically inferred
#
# ActionCable::Connection::TestCase will automatically infer the connection
# under test from the test class name. If the channel cannot be inferred from
# the test class name, you can explicitly set it with `tests`.
#
#     class ConnectionTest < ActionCable::Connection::TestCase
#       tests ApplicationCable::Connection
#     end
#
# source://actioncable-next//lib/action_cable/connection/test_case.rb#205
class ActionCable::Connection::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::Assertions
  include ::ActionCable::Connection::TestCase::Behavior
  extend ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
  def _connection_class; end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
  def _connection_class=(_arg0); end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
  def _connection_class?; end

  class << self
    # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
    def _connection_class; end

    # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
    def _connection_class=(value); end

    # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
    def _connection_class?; end

    private

    # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
    def __class_attr__connection_class; end

    # source://actioncable-next//lib/action_cable/connection/test_case.rb#215
    def __class_attr__connection_class=(new_value); end
  end
end

# source://actioncable-next//lib/action_cable/connection/test_case.rb#206
module ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionCable::Connection::TestCase::Behavior::ClassMethods

  # Performs connection attempt to exert #connect on the connection under test.
  #
  # Accepts request path as the first argument and the following request options:
  #
  # *   params URL parameters (Hash)
  # *   headers  request headers (Hash)
  # *   session session data (Hash)
  # *   env additional Rack env configuration (Hash)
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#259
  def connect(path = T.unsafe(nil), server: T.unsafe(nil), **request_params); end

  # Returns the value of attribute connection.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#249
  def connection; end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#279
  def cookies; end

  # Exert #disconnect on the connection under test.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#272
  def disconnect; end

  # Returns the value of attribute socket.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#249
  def socket; end

  # Returns the value of attribute testserver.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#249
  def testserver; end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#283
  def transmissions; end

  module GeneratedClassMethods
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
  end

  module GeneratedInstanceMethods
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
  end
end

# source://actioncable-next//lib/action_cable/connection/test_case.rb#220
module ActionCable::Connection::TestCase::Behavior::ClassMethods
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#232
  def connection_class; end

  # @raise [NonInferrableConnectionError]
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#240
  def determine_default_connection(name); end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#221
  def tests(connection); end
end

# source://actioncable-next//lib/action_cable/connection/test_case.rb#209
ActionCable::Connection::TestCase::Behavior::DEFAULT_PATH = T.let(T.unsafe(nil), String)

# We don't want to use the whole "encryption stack" for connection unit-tests,
# but we want to make sure that users test against the correct types of cookies
# (i.e. signed or encrypted or plain)
#
# source://actioncable-next//lib/action_cable/connection/test_case.rb#43
class ActionCable::Connection::TestCookieJar < ::ActionCable::Connection::TestCookies
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#48
  def encrypted; end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#44
  def signed; end
end

# source://actioncable-next//lib/action_cable/connection/test_case.rb#33
class ActionCable::Connection::TestCookies < ::ActiveSupport::HashWithIndifferentAccess
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#34
  def []=(name, options); end
end

# TestServer provides test pub/sub and executor implementations
#
# source://actioncable-next//lib/action_cable/connection/test_case.rb#106
class ActionCable::Connection::TestServer
  # @return [TestServer] a new instance of TestServer
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#109
  def initialize(server); end

  # Returns the value of attribute config.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#107
  def config; end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#115
  def executor; end

  # Inline async calls
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#120
  def post(&work); end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#114
  def pubsub; end

  # Returns the value of attribute streams.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#107
  def streams; end

  # == Pub/sub interface ==
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#125
  def subscribe(stream, callback, success_callback = T.unsafe(nil)); end

  # We don't support timers in unit tests yet
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#122
  def timer(_every); end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#130
  def unsubscribe(stream, callback); end
end

# source://actioncable-next//lib/action_cable/connection/test_case.rb#53
class ActionCable::Connection::TestSocket
  # @return [TestSocket] a new instance of TestSocket
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#85
  def initialize(request); end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#100
  def close; end

  # Returns the value of attribute closed.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#59
  def closed; end

  # Returns the value of attribute env.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#59
  def env; end

  # Returns the value of attribute logger.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#59
  def logger; end

  # Returns the value of attribute request.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#59
  def request; end

  # Returns the value of attribute transmissions.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#59
  def transmissions; end

  # source://actioncable-next//lib/action_cable/connection/test_case.rb#96
  def transmit(data); end

  class << self
    # source://actioncable-next//lib/action_cable/connection/test_case.rb#62
    def build_request(path, params: T.unsafe(nil), headers: T.unsafe(nil), session: T.unsafe(nil), env: T.unsafe(nil), cookies: T.unsafe(nil)); end
  end
end

# Make session and cookies available to the connection
#
# source://actioncable-next//lib/action_cable/connection/test_case.rb#55
class ActionCable::Connection::TestSocket::Request < ::ActionDispatch::TestRequest
  # Returns the value of attribute cookie_jar.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#56
  def cookie_jar; end

  # Sets the attribute cookie_jar
  #
  # @param value the value to set the attribute cookie_jar to.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#56
  def cookie_jar=(_arg0); end

  # Returns the value of attribute session.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#56
  def session; end

  # Sets the attribute session
  #
  # @param value the value to set the attribute session to.
  #
  # source://actioncable-next//lib/action_cable/connection/test_case.rb#56
  def session=(_arg0); end
end

# source://actioncable-next//lib/action_cable/engine.rb#10
class ActionCable::Engine < ::Rails::Engine; end

# source://actioncable-next//lib/action_cable/helpers/action_cable_helper.rb#6
module ActionCable::Helpers; end

# source://actioncable-next//lib/action_cable/helpers/action_cable_helper.rb#7
module ActionCable::Helpers::ActionCableHelper
  # Returns an "action-cable-url" meta tag with the value of the URL specified in
  # your configuration. Ensure this is above your JavaScript tag:
  #
  #     <head>
  #       <%= action_cable_meta_tag %>
  #       <%= javascript_include_tag 'application', 'data-turbo-track' => 'reload' %>
  #     </head>
  #
  # This is then used by Action Cable to determine the URL of your WebSocket
  # server. Your JavaScript can then connect to the server without needing to
  # specify the URL directly:
  #
  #     import Cable from "@rails/actioncable"
  #     window.Cable = Cable
  #     window.App = {}
  #     App.cable = Cable.createConsumer()
  #
  # Make sure to specify the correct server location in each of your environment
  # config files:
  #
  #     config.action_cable.mount_path = "/cable123"
  #     <%= action_cable_meta_tag %> would render:
  #     => <meta name="action-cable-url" content="/cable123" />
  #
  #     config.action_cable.url = "ws://actioncable.com"
  #     <%= action_cable_meta_tag %> would render:
  #     => <meta name="action-cable-url" content="ws://actioncable.com" />
  #
  # source://actioncable-next//lib/action_cable/helpers/action_cable_helper.rb#36
  def action_cable_meta_tag; end
end

# source://actioncable-next//lib/action_cable.rb#61
ActionCable::INTERNAL = T.let(T.unsafe(nil), Hash)

# # Action Cable Remote Connections
#
# If you need to disconnect a given connection, you can go through the
# RemoteConnections. You can find the connections you're looking for by
# searching for the identifier declared on the connection. For example:
#
#     module ApplicationCable
#       class Connection < ActionCable::Connection::Base
#         identified_by :current_user
#         ....
#       end
#     end
#
#     ActionCable.server.remote_connections.where(current_user: User.find(1)).disconnect
#
# This will disconnect all the connections established for `User.find(1)`,
# across all servers running on all machines, because it uses the internal
# channel that all of these servers are subscribed to.
#
# By default, server sends a "disconnect" message with "reconnect" flag set to
# true. You can override it by specifying the `reconnect` option:
#
#     ActionCable.server.remote_connections.where(current_user: User.find(1)).disconnect(reconnect: false)
#
# source://actioncable-next//lib/action_cable/remote_connections.rb#31
class ActionCable::RemoteConnections
  # @return [RemoteConnections] a new instance of RemoteConnections
  #
  # source://actioncable-next//lib/action_cable/remote_connections.rb#34
  def initialize(server); end

  # Returns the value of attribute server.
  #
  # source://actioncable-next//lib/action_cable/remote_connections.rb#32
  def server; end

  # source://actioncable-next//lib/action_cable/remote_connections.rb#38
  def where(identifier); end
end

# # Action Cable Remote Connection
#
# Represents a single remote connection found via
# `ActionCable.server.remote_connections.where(*)`. Exists solely for the
# purpose of calling #disconnect on that connection.
#
# source://actioncable-next//lib/action_cable/remote_connections.rb#47
class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  extend ::ActionCable::Connection::Identification::ClassMethods

  # @return [RemoteConnection] a new instance of RemoteConnection
  #
  # source://actioncable-next//lib/action_cable/remote_connections.rb#52
  def initialize(server, ids); end

  # Uses the internal channel to disconnect the connection.
  #
  # source://actioncable-next//lib/action_cable/remote_connections.rb#58
  def disconnect(reconnect: T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/remote_connections.rb#50
  def identifiers; end

  # source://actioncable-next//lib/action_cable/remote_connections.rb#50
  def identifiers=(_arg0); end

  # source://actioncable-next//lib/action_cable/remote_connections.rb#50
  def identifiers?; end

  protected

  # Returns the value of attribute server.
  #
  # source://actioncable-next//lib/action_cable/remote_connections.rb#68
  def server; end

  private

  # @raise [InvalidIdentifiersError]
  #
  # source://actioncable-next//lib/action_cable/remote_connections.rb#71
  def set_identifier_instance_vars(ids); end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/remote_connections.rb#76
  def valid_identifiers?(ids); end

  class << self
    # source://actioncable-next//lib/action_cable/remote_connections.rb#50
    def identifiers; end

    # source://actioncable-next//lib/action_cable/remote_connections.rb#50
    def identifiers=(value); end

    # source://actioncable-next//lib/action_cable/remote_connections.rb#50
    def identifiers?; end

    private

    # source://actioncable-next//lib/action_cable/remote_connections.rb#50
    def __class_attr_identifiers; end

    # source://actioncable-next//lib/action_cable/remote_connections.rb#50
    def __class_attr_identifiers=(new_value); end
  end
end

# source://actioncable-next//lib/action_cable/remote_connections.rb#48
class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError < ::StandardError; end

# source://actioncable-next//lib/action_cable/server/base.rb#8
module ActionCable::Server; end

# # Action Cable Server Base
#
# A singleton ActionCable::Server instance is available via ActionCable.server.
# It's used by the Rack process that starts the Action Cable server, but is also
# used by the user to reach the RemoteConnections object, which is used for
# finding and disconnecting connections across all servers.
#
# Also, this is the server instance used for broadcasting. See Broadcasting for
# more information.
#
# source://actioncable-next//lib/action_cable/server/base.rb#41
class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections

  # @return [Base] a new instance of Base
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#54
  def initialize(config: T.unsafe(nil)); end

  # Check if the request origin is allowed to connect to the Action Cable server.
  #
  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#146
  def allow_request_origin?(env); end

  # Called by Rack to set up the server.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#61
  def call(env); end

  # Returns the value of attribute config.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#47
  def config; end

  # All of the identifiers applied to the connection class associated with this
  # server.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#134
  def connection_identifiers; end

  # Disconnect all the connections identified by `identifiers` on this server or
  # any others via RemoteConnections.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#69
  def disconnect(identifiers); end

  # source://actioncable-next//lib/action_cable/server/base.rb#98
  def event_loop; end

  # Executor is used by various actions within Action Cable (e.g., pub/sub operations) to run code asynchronously.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#123
  def executor; end

  # source://actioncable-next//lib/action_cable/server/base.rb#50
  def logger(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute mutex.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#52
  def mutex; end

  # Tags are declared in the server but computed in the connection. This allows us per-connection tailored tags.
  # You can pass request object either directly or via block to lazily evaluate it.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#140
  def new_tagged_logger(request = T.unsafe(nil), &block); end

  # Adapter used for all streams/broadcasting.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#128
  def pubsub; end

  # Gateway to RemoteConnections. See that class for details.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#94
  def remote_connections; end

  # source://actioncable-next//lib/action_cable/server/base.rb#73
  def restart; end

  # The worker pool is where we run connection callbacks and channel actions. We
  # do as little as possible on the server's main thread. The worker pool is an
  # executor service that's backed by a pool of threads working from a task queue.
  # The thread pool size maxes out at 4 worker threads by default. Tune the size
  # yourself with `config.action_cable.worker_pool_size`.
  #
  # Using Active Record, Redis, etc within your channel actions means you'll get a
  # separate connection from each thread in the worker pool. Plan your deployment
  # accordingly: 5 servers each running 5 Puma workers each running an 8-thread
  # worker pool means at least 200 database connections.
  #
  # Also, ensure that your database connection pool size is as least as large as
  # your worker pool size. Otherwise, workers may oversubscribe the database
  # connection pool and block while they wait for other workers to release their
  # connections. Use a smaller worker pool or a larger database connection pool
  # instead.
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#118
  def worker_pool; end

  class << self
    # source://actioncable-next//lib/action_cable/server/base.rb#45
    def config; end

    # source://actioncable-next//lib/action_cable/server/base.rb#45
    def config=(val); end

    # source://actioncable-next//lib/action_cable/server/base.rb#49
    def logger; end
  end
end

# # Action Cable Server Broadcasting
#
# Broadcasting is how other parts of your application can send messages to a
# channel's subscribers. As explained in Channel, most of the time, these
# broadcastings are streamed directly to the clients subscribed to the named
# broadcasting. Let's explain with a full-stack example:
#
#     class WebNotificationsChannel < ApplicationCable::Channel
#       def subscribed
#         stream_from "web_notifications_#{current_user.id}"
#       end
#     end
#
#     # Somewhere in your app this is called, perhaps from a NewCommentJob:
#     ActionCable.server.broadcast \
#       "web_notifications_1", { title: "New things!", body: "All that's fit for print" }
#
#     // Client-side JavaScript, which assumes you've already requested the right to send web notifications:
#     App.cable.subscriptions.create("WebNotificationsChannel", {
#       received: function(data) {
#         new Notification(data['title'], { body: data['body'] });
#       }
#     });
#
# source://actioncable-next//lib/action_cable/server/broadcasting.rb#30
module ActionCable::Server::Broadcasting
  # Broadcast a hash directly to a named `broadcasting`. This will later be JSON
  # encoded.
  #
  # source://actioncable-next//lib/action_cable/server/broadcasting.rb#33
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  # Returns a broadcaster for a named `broadcasting` that can be reused. Useful
  # when you have an object that may need multiple spots to transmit to a specific
  # broadcasting over and over.
  #
  # source://actioncable-next//lib/action_cable/server/broadcasting.rb#40
  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

# source://actioncable-next//lib/action_cable/server/broadcasting.rb#45
class ActionCable::Server::Broadcasting::Broadcaster
  # @return [Broadcaster] a new instance of Broadcaster
  #
  # source://actioncable-next//lib/action_cable/server/broadcasting.rb#48
  def initialize(server, broadcasting, coder:); end

  # source://actioncable-next//lib/action_cable/server/broadcasting.rb#52
  def broadcast(message); end

  # Returns the value of attribute broadcasting.
  #
  # source://actioncable-next//lib/action_cable/server/broadcasting.rb#46
  def broadcasting; end

  # Returns the value of attribute coder.
  #
  # source://actioncable-next//lib/action_cable/server/broadcasting.rb#46
  def coder; end

  # Returns the value of attribute server.
  #
  # source://actioncable-next//lib/action_cable/server/broadcasting.rb#46
  def server; end
end

# # Action Cable Server Configuration
#
# An instance of this configuration object is available via
# ActionCable.server.config, which allows you to tweak Action Cable
# configuration in a Rails config initializer.
#
# source://actioncable-next//lib/action_cable/server/configuration.rb#14
class ActionCable::Server::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#24
  def initialize; end

  # Returns the value of attribute allow_same_origin_as_host.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def allow_same_origin_as_host; end

  # Sets the attribute allow_same_origin_as_host
  #
  # @param value the value to set the attribute allow_same_origin_as_host to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def allow_same_origin_as_host=(_arg0); end

  # Returns the value of attribute allowed_request_origins.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def allowed_request_origins; end

  # Sets the attribute allowed_request_origins
  #
  # @param value the value to set the attribute allowed_request_origins to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def allowed_request_origins=(_arg0); end

  # Returns the value of attribute cable.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#18
  def cable; end

  # Sets the attribute cable
  #
  # @param value the value to set the attribute cable to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#18
  def cable=(_arg0); end

  # Returns the value of attribute connection_class.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#16
  def connection_class; end

  # Sets the attribute connection_class
  #
  # @param value the value to set the attribute connection_class to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#16
  def connection_class=(_arg0); end

  # Returns the value of attribute disable_request_forgery_protection.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def disable_request_forgery_protection; end

  # Sets the attribute disable_request_forgery_protection
  #
  # @param value the value to set the attribute disable_request_forgery_protection to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def disable_request_forgery_protection=(_arg0); end

  # Returns the value of attribute executor_pool_size.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#16
  def executor_pool_size; end

  # Sets the attribute executor_pool_size
  #
  # @param value the value to set the attribute executor_pool_size to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#16
  def executor_pool_size=(_arg0); end

  # Returns the value of attribute fastlane_broadcasts_enabled.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#22
  def fastlane_broadcasts_enabled; end

  # Sets the attribute fastlane_broadcasts_enabled
  #
  # @param value the value to set the attribute fastlane_broadcasts_enabled to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#22
  def fastlane_broadcasts_enabled=(_arg0); end

  # Returns the value of attribute filter_parameters.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def filter_parameters; end

  # Sets the attribute filter_parameters
  #
  # @param value the value to set the attribute filter_parameters to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#17
  def filter_parameters=(_arg0); end

  # Returns the value of attribute health_check_application.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#20
  def health_check_application; end

  # Sets the attribute health_check_application
  #
  # @param value the value to set the attribute health_check_application to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#20
  def health_check_application=(_arg0); end

  # Returns the value of attribute health_check_path.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#20
  def health_check_path; end

  # Sets the attribute health_check_path
  #
  # @param value the value to set the attribute health_check_path to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#20
  def health_check_path=(_arg0); end

  # Returns the value of attribute log_tags.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#15
  def log_tags; end

  # Sets the attribute log_tags
  #
  # @param value the value to set the attribute log_tags to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#15
  def log_tags=(_arg0); end

  # Returns the value of attribute logger.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#15
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#15
  def logger=(_arg0); end

  # Returns the value of attribute mount_path.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#18
  def mount_path; end

  # Sets the attribute mount_path
  #
  # @param value the value to set the attribute mount_path to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#18
  def mount_path=(_arg0); end

  # Returns the value of attribute precompile_assets.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#19
  def precompile_assets; end

  # Sets the attribute precompile_assets
  #
  # @param value the value to set the attribute precompile_assets to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#19
  def precompile_assets=(_arg0); end

  # Returns constant of subscription adapter specified in config/cable.yml or directly in the configuration.
  # If the adapter cannot be found, this will default to the Redis adapter. Also makes
  # sure proper dependencies are required.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#45
  def pubsub_adapter; end

  # Sets the attribute pubsub_adapter
  #
  # @param value the value to set the attribute pubsub_adapter to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#21
  def pubsub_adapter=(_arg0); end

  # Returns the value of attribute url.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#18
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#18
  def url=(_arg0); end

  # Returns the value of attribute worker_pool_size.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#16
  def worker_pool_size; end

  # Sets the attribute worker_pool_size
  #
  # @param value the value to set the attribute worker_pool_size to.
  #
  # source://actioncable-next//lib/action_cable/server/configuration.rb#16
  def worker_pool_size=(_arg0); end
end

# # Action Cable Server Connections
#
# Collection class for all the connections that have been established on this
# specific server. Remember, usually you'll run many Action Cable servers, so
# you can't use this collection as a full list of all of the connections
# established against your application. Instead, use RemoteConnections for that.
#
# source://actioncable-next//lib/action_cable/server/connections.rb#13
module ActionCable::Server::Connections
  # source://actioncable-next//lib/action_cable/server/connections.rb#22
  def add_connection(connection); end

  # source://actioncable-next//lib/action_cable/server/connections.rb#20
  def connections; end

  # source://actioncable-next//lib/action_cable/server/connections.rb#16
  def connections_map; end

  # source://actioncable-next//lib/action_cable/server/connections.rb#41
  def open_connections_statistics; end

  # source://actioncable-next//lib/action_cable/server/connections.rb#26
  def remove_connection(connection); end

  # WebSocket connection implementations differ on when they'll mark a connection
  # as stale. We basically never want a connection to go stale, as you then can't
  # rely on being able to communicate with the connection. To solve this, a 3
  # second heartbeat runs on all connections. If the beat fails, we automatically
  # disconnect.
  #
  # source://actioncable-next//lib/action_cable/server/connections.rb#35
  def setup_heartbeat_timer; end
end

# source://actioncable-next//lib/action_cable/server/connections.rb#14
ActionCable::Server::Connections::BEAT_INTERVAL = T.let(T.unsafe(nil), Integer)

# This class encapsulates all the low-level logic of working with the underlying WebSocket conenctions
# and delegate all the business-logic to the user-level connection object (e.g., ApplicationCable::Connection).
# This connection object is also responsible for handling encoding and decoding of messages, so the user-level
# connection object shouldn't know about such details.
#
# source://actioncable-next//lib/action_cable/server/socket.rb#11
class ActionCable::Server::Socket
  # @return [Socket] a new instance of Socket
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#17
  def initialize(server, env, coder: T.unsafe(nil)); end

  # Close the WebSocket connection.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#57
  def close(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#15
  def config(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute connection.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#12
  def connection; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#84
  def dispatch_websocket_message(websocket_message); end

  # Returns the value of attribute env.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#12
  def env; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#15
  def event_loop(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#111
  def inspect; end

  # Returns the value of attribute logger.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#12
  def logger; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#107
  def on_close(reason, code); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#102
  def on_error(message); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#98
  def on_message(message); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#94
  def on_open; end

  # Invoke a method on the connection asynchronously through the pool of thread workers.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#62
  def perform_work(receiver, method, *args); end

  # Called by the server when a new WebSocket connection is established.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#31
  def process; end

  # Returns the value of attribute protocol.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#12
  def protocol; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#15
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#50
  def raw_transmit(message); end

  # Decodes WebSocket messages and dispatches them to subscribed channels.
  # WebSocket message transfer encoding is always JSON.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#80
  def receive(websocket_message); end

  # The request that initiated the WebSocket connection is available here. This gives access to the environment, cookies, etc.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#71
  def request; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#66
  def send_async(method, *arguments); end

  # Returns the value of attribute server.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#12
  def server; end

  # Send a non-serialized message over the WebSocket connection.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#44
  def transmit(cable_message); end

  private

  # source://actioncable-next//lib/action_cable/server/socket.rb#123
  def decode(websocket_message); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#119
  def encode(cable_message); end

  # source://actioncable-next//lib/action_cable/server/socket.rb#165
  def finished_request_message; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#136
  def handle_close; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#127
  def handle_open; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#173
  def invalid_request_message; end

  # Returns the value of attribute message_buffer.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#117
  def message_buffer; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#148
  def respond_to_invalid_request; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#143
  def respond_to_successful_request; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#156
  def started_request_message; end

  # source://actioncable-next//lib/action_cable/server/socket.rb#179
  def successful_request_message; end

  # Returns the value of attribute websocket.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#116
  def websocket; end

  # Returns the value of attribute worker_pool.
  #
  # source://actioncable-next//lib/action_cable/server/socket.rb#13
  def worker_pool; end
end

# source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#12
class ActionCable::Server::Socket::ClientSocket
  # @return [ClientSocket] a new instance of ClientSocket
  #
  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#35
  def initialize(env, event_target, event_loop, protocols); end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#113
  def alive?; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#109
  def client_gone; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#91
  def close(code = T.unsafe(nil), reason = T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#33
  def env; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#105
  def parse(data); end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#117
  def protocol; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#70
  def rack_response; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#58
  def start_driver; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#81
  def transmit(message); end

  # Returns the value of attribute url.
  #
  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#33
  def url; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#75
  def write(data); end

  private

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#141
  def begin_close(reason, code); end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#135
  def emit_error(message); end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#150
  def finalize_close; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#122
  def open; end

  # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#129
  def receive_message(data); end

  class << self
    # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#13
    def determine_url(env); end

    # @return [Boolean]
    #
    # source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#18
    def secure_request?(env); end
  end
end

# source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#31
ActionCable::Server::Socket::ClientSocket::CLOSED = T.let(T.unsafe(nil), Integer)

# source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#30
ActionCable::Server::Socket::ClientSocket::CLOSING = T.let(T.unsafe(nil), Integer)

# source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#28
ActionCable::Server::Socket::ClientSocket::CONNECTING = T.let(T.unsafe(nil), Integer)

# source://actioncable-next//lib/action_cable/server/socket/client_socket.rb#29
ActionCable::Server::Socket::ClientSocket::OPEN = T.let(T.unsafe(nil), Integer)

# Allows us to buffer messages received from the WebSocket before the Connection has been fully initialized, and is ready to receive them.
#
# source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#7
class ActionCable::Server::Socket::MessageBuffer
  # @return [MessageBuffer] a new instance of MessageBuffer
  #
  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#8
  def initialize(connection); end

  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#13
  def append(message); end

  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#29
  def process!; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#25
  def processing?; end

  private

  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#46
  def buffer(message); end

  # Returns the value of attribute buffered_messages.
  #
  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#36
  def buffered_messages; end

  # Returns the value of attribute connection.
  #
  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#35
  def connection; end

  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#42
  def receive(message); end

  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#50
  def receive_buffered_messages; end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/server/socket/message_buffer.rb#38
  def valid?(message); end
end

# source://actioncable-next//lib/action_cable/server/socket/stream.rb#10
class ActionCable::Server::Socket::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#11
  def initialize(event_loop, socket); end

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#27
  def close; end

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#23
  def each(&callback); end

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#71
  def flush_write_buffer; end

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#97
  def hijack_rack_socket; end

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#93
  def receive(data); end

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#32
  def shutdown; end

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#36
  def write(data); end

  private

  # source://actioncable-next//lib/action_cable/server/socket/stream.rb#109
  def clean_rack_hijack; end
end

# # Action Cable Connection WebSocket
#
# Wrap the real socket to minimize the externally-presented API
#
# source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#13
class ActionCable::Server::Socket::WebSocket
  # @return [WebSocket] a new instance of WebSocket
  #
  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#14
  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#22
  def alive?; end

  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#30
  def close(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#18
  def possible?; end

  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#34
  def protocol; end

  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#38
  def rack_response; end

  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#26
  def transmit(*_arg0, **_arg1, &_arg2); end

  private

  # Returns the value of attribute websocket.
  #
  # source://actioncable-next//lib/action_cable/server/socket/web_socket.rb#43
  def websocket; end
end

# source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#9
class ActionCable::Server::StreamEventLoop
  # @return [StreamEventLoop] a new instance of StreamEventLoop
  #
  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#10
  def initialize; end

  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#19
  def attach(io, stream); end

  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#27
  def detach(io, stream); end

  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#45
  def stop; end

  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#36
  def writes_pending(io); end

  private

  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#69
  def run; end

  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#51
  def spawn; end

  # source://actioncable-next//lib/action_cable/server/stream_event_loop.rb#65
  def wakeup; end
end

# # Action Cable Connection TaggedLoggerProxy
#
# Allows the use of per-connection tags against the server logger. This wouldn't work using the traditional
# ActiveSupport::TaggedLogging enhanced Rails.logger, as that logger will reset the tags between requests.
# The connection is long-lived, so it needs its own set of tags for its independent duration.
#
# source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#12
class ActionCable::Server::TaggedLoggerProxy
  # @return [TaggedLoggerProxy] a new instance of TaggedLoggerProxy
  #
  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#15
  def initialize(logger, tags:); end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#20
  def add_tags(*tags); end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#35
  def debug(message = T.unsafe(nil), &block); end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#35
  def error(message = T.unsafe(nil), &block); end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#35
  def fatal(message = T.unsafe(nil), &block); end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#35
  def info(message = T.unsafe(nil), &block); end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#25
  def tag(logger, &block); end

  # Returns the value of attribute tags.
  #
  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#13
  def tags; end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#35
  def unknown(message = T.unsafe(nil), &block); end

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#35
  def warn(message = T.unsafe(nil), &block); end

  private

  # source://actioncable-next//lib/action_cable/server/tagged_logger_proxy.rb#41
  def log(type, message, &block); end
end

# A wrapper over ConcurrentRuby::ThreadPoolExecutor and Concurrent::TimerTask
#
# source://actioncable-next//lib/action_cable/server/base.rb#10
class ActionCable::Server::ThreadedExecutor
  # @return [ThreadedExecutor] a new instance of ThreadedExecutor
  #
  # source://actioncable-next//lib/action_cable/server/base.rb#11
  def initialize(max_size: T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/server/base.rb#20
  def post(task = T.unsafe(nil), &block); end

  # source://actioncable-next//lib/action_cable/server/base.rb#29
  def shutdown; end

  # source://actioncable-next//lib/action_cable/server/base.rb#25
  def timer(interval, &block); end
end

# Worker used by Server.send_async to do connection work in threads.
#
# source://actioncable-next//lib/action_cable/server/worker.rb#12
class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @return [Worker] a new instance of Worker
  #
  # source://actioncable-next//lib/action_cable/server/worker.rb#21
  def initialize(max_size: T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/server/worker.rb#13
  def __callbacks; end

  # source://actioncable-next//lib/action_cable/server/worker.rb#16
  def _run_work_callbacks(&block); end

  # source://actioncable-next//lib/action_cable/server/worker.rb#16
  def _run_work_callbacks!(&block); end

  # source://actioncable-next//lib/action_cable/server/worker.rb#16
  def _work_callbacks; end

  # source://actioncable-next//lib/action_cable/server/worker.rb#48
  def async_exec(receiver, *args, connection:, &block); end

  # source://actioncable-next//lib/action_cable/server/worker.rb#52
  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  # source://actioncable-next//lib/action_cable/server/worker.rb#15
  def connection; end

  # source://actioncable-next//lib/action_cable/server/worker.rb#15
  def connection=(obj); end

  # Returns the value of attribute executor.
  #
  # source://actioncable-next//lib/action_cable/server/worker.rb#19
  def executor; end

  # Stop processing work: any work that has not already started running will be
  # discarded from the queue
  #
  # source://actioncable-next//lib/action_cable/server/worker.rb#32
  def halt; end

  # source://actioncable-next//lib/action_cable/server/worker.rb#58
  def invoke(receiver, method, *args, connection:, &block); end

  # @return [Boolean]
  #
  # source://actioncable-next//lib/action_cable/server/worker.rb#36
  def stopping?; end

  # source://actioncable-next//lib/action_cable/server/worker.rb#40
  def work(connection, &block); end

  private

  # source://actioncable-next//lib/action_cable/server/worker.rb#70
  def logger; end

  class << self
    # source://actioncable-next//lib/action_cable/server/worker.rb#13
    def __callbacks; end

    # source://actioncable-next//lib/action_cable/server/worker.rb#13
    def __callbacks=(value); end

    # source://actioncable-next//lib/action_cable/server/worker.rb#16
    def _work_callbacks; end

    # source://actioncable-next//lib/action_cable/server/worker.rb#16
    def _work_callbacks=(value); end

    # source://actioncable-next//lib/action_cable/server/worker.rb#15
    def connection; end

    # source://actioncable-next//lib/action_cable/server/worker.rb#15
    def connection=(obj); end

    private

    # source://actioncable-next//lib/action_cable/server/worker.rb#13
    def __class_attr___callbacks; end

    # source://actioncable-next//lib/action_cable/server/worker.rb#13
    def __class_attr___callbacks=(new_value); end
  end
end

# source://actioncable-next//lib/action_cable/server/worker/active_record_connection_management.rb#8
module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern

  # source://actioncable-next//lib/action_cable/server/worker/active_record_connection_management.rb#17
  def with_database_connections(&block); end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#6
module ActionCable::SubscriptionAdapter; end

# source://actioncable-next//lib/action_cable/subscription_adapter/async.rb#7
class ActionCable::SubscriptionAdapter::Async < ::ActionCable::SubscriptionAdapter::Inline
  private

  # source://actioncable-next//lib/action_cable/subscription_adapter/async.rb#9
  def new_subscriber_map; end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#7
class ActionCable::SubscriptionAdapter::Base
  # @return [Base] a new instance of Base
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#13
  def initialize(server); end

  # @raise [NotImplementedError]
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#18
  def broadcast(channel, payload); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#34
  def identifier; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#11
  def logger(*_arg0, **_arg1, &_arg2); end

  # @raise [NotImplementedError]
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#30
  def shutdown; end

  # @raise [NotImplementedError]
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#22
  def subscribe(channel, message_callback, success_callback = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#26
  def unsubscribe(channel, message_callback); end

  private

  # Returns the value of attribute config.
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#9
  def config; end

  # Returns the value of attribute executor.
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/base.rb#8
  def executor; end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/channel_prefix.rb#7
module ActionCable::SubscriptionAdapter::ChannelPrefix
  # source://actioncable-next//lib/action_cable/subscription_adapter/channel_prefix.rb#8
  def broadcast(channel, payload); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/channel_prefix.rb#13
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/channel_prefix.rb#18
  def unsubscribe(channel, callback); end

  private

  # Returns the channel name, including channel_prefix specified in cable.yml
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/channel_prefix.rb#25
  def channel_with_prefix(channel); end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#7
class ActionCable::SubscriptionAdapter::Inline < ::ActionCable::SubscriptionAdapter::Base
  # @return [Inline] a new instance of Inline
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#8
  def initialize(*_arg0); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#14
  def broadcast(channel, payload); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#26
  def shutdown; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#18
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#22
  def unsubscribe(channel, callback); end

  private

  # source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#35
  def new_subscriber_map; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/inline.rb#31
  def subscriber_map; end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#11
class ActionCable::SubscriptionAdapter::PostgreSQL < ::ActionCable::SubscriptionAdapter::Base
  include ::ActionCable::SubscriptionAdapter::ChannelPrefix

  # @return [PostgreSQL] a new instance of PostgreSQL
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#14
  def initialize(*_arg0); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#20
  def broadcast(channel, payload); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#34
  def shutdown; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#26
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#30
  def unsubscribe(channel, callback); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#52
  def with_broadcast_connection(&block); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#38
  def with_subscriptions_connection(&block); end

  private

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#61
  def channel_identifier(channel); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#65
  def listener; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#69
  def verify!(pg_conn); end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#75
class ActionCable::SubscriptionAdapter::PostgreSQL::Listener < ::ActionCable::SubscriptionAdapter::SubscriberMap::Async
  # @return [Listener] a new instance of Listener
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#76
  def initialize(adapter, executor); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#119
  def add_channel(channel, on_success); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#88
  def listen; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#123
  def remove_channel(channel); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/postgresql.rb#114
  def shutdown; end
end

class ActionCable::SubscriptionAdapter::SolidCable < ::ActionCable::SubscriptionAdapter::Base; end

# source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#7
class ActionCable::SubscriptionAdapter::SubscriberMap
  # @return [SubscriberMap] a new instance of SubscriberMap
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#21
  def initialize; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#64
  def add_channel(channel, on_success); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#26
  def add_subscriber(channel, subscriber, on_success); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#51
  def broadcast(channel, message); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#71
  def invoke_callback(callback, message); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#68
  def remove_channel(channel); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#40
  def remove_subscriber(channel, subscriber); end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#75
class ActionCable::SubscriptionAdapter::SubscriberMap::Async < ::ActionCable::SubscriptionAdapter::SubscriberMap
  # @return [Async] a new instance of Async
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#76
  def initialize(executor); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#81
  def add_subscriber(*_arg0); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#89
  def invoke_callback(*_arg0); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#85
  def remove_subscriber(*_arg0); end
end

# source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#8
class ActionCable::SubscriptionAdapter::SubscriberMap::Message < ::Struct
  # @return [Message] a new instance of Message
  #
  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#9
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/subscriber_map.rb#14
  def encoded_for(identifier); end
end

# ## Test adapter for Action Cable
#
# The test adapter should be used only in testing. Along with
# ActionCable::TestHelper it makes a great tool to test your Rails application.
#
# To use the test adapter set `adapter` value to `test` in your
# `config/cable.yml` file.
#
# NOTE: `Test` adapter extends the `ActionCable::SubscriptionAdapter::Async`
# adapter, so it could be used in system tests too.
#
# source://actioncable-next//lib/action_cable/subscription_adapter/test.rb#17
class ActionCable::SubscriptionAdapter::Test < ::ActionCable::SubscriptionAdapter::Async
  # source://actioncable-next//lib/action_cable/subscription_adapter/test.rb#18
  def broadcast(channel, payload); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/test.rb#23
  def broadcasts(channel); end

  # source://actioncable-next//lib/action_cable/subscription_adapter/test.rb#31
  def clear; end

  # source://actioncable-next//lib/action_cable/subscription_adapter/test.rb#27
  def clear_messages(channel); end

  private

  # source://actioncable-next//lib/action_cable/subscription_adapter/test.rb#36
  def channels_data; end
end

# source://actioncable-next//lib/action_cable/test_case.rb#8
class ActionCable::TestCase < ::ActiveSupport::TestCase
  include ::ActionCable::TestHelper
end

# Provides helper methods for testing Action Cable broadcasting
#
# source://actioncable-next//lib/action_cable/test_helper.rb#7
module ActionCable::TestHelper
  # source://actioncable-next//lib/action_cable/test_helper.rb#18
  def after_teardown; end

  # Asserts that the specified message has been sent to the stream.
  #
  #     def test_assert_transmitted_message
  #       ActionCable.server.broadcast 'messages', text: 'hello'
  #       assert_broadcast_on('messages', text: 'hello')
  #     end
  #
  # If a block is passed, that block should cause a message with the specified
  # data to be sent.
  #
  #     def test_assert_broadcast_on_again
  #       assert_broadcast_on('messages', text: 'hello') do
  #         ActionCable.server.broadcast 'messages', text: 'hello'
  #       end
  #     end
  #
  # source://actioncable-next//lib/action_cable/test_helper.rb#116
  def assert_broadcast_on(stream, data, &block); end

  # Asserts that the number of broadcasted messages to the stream matches the
  # given number.
  #
  #     def test_broadcasts
  #       assert_broadcasts 'messages', 0
  #       ActionCable.server.broadcast 'messages', { text: 'hello' }
  #       assert_broadcasts 'messages', 1
  #       ActionCable.server.broadcast 'messages', { text: 'world' }
  #       assert_broadcasts 'messages', 2
  #     end
  #
  # If a block is passed, that block should cause the specified number of messages
  # to be broadcasted.
  #
  #     def test_broadcasts_again
  #       assert_broadcasts('messages', 1) do
  #         ActionCable.server.broadcast 'messages', { text: 'hello' }
  #       end
  #
  #       assert_broadcasts('messages', 2) do
  #         ActionCable.server.broadcast 'messages', { text: 'hi' }
  #         ActionCable.server.broadcast 'messages', { text: 'how are you?' }
  #       end
  #     end
  #
  # source://actioncable-next//lib/action_cable/test_helper.rb#48
  def assert_broadcasts(stream, number, &block); end

  # Asserts that no messages have been sent to the stream.
  #
  #     def test_no_broadcasts
  #       assert_no_broadcasts 'messages'
  #       ActionCable.server.broadcast 'messages', { text: 'hi' }
  #       assert_broadcasts 'messages', 1
  #     end
  #
  # If a block is passed, that block should not cause any message to be sent.
  #
  #     def test_broadcasts_again
  #       assert_no_broadcasts 'messages' do
  #         # No job messages should be sent from this block
  #       end
  #     end
  #
  # Note: This assertion is simply a shortcut for:
  #
  #     assert_broadcasts 'messages', 0, &block
  #
  # source://actioncable-next//lib/action_cable/test_helper.rb#80
  def assert_no_broadcasts(stream, &block); end

  # source://actioncable-next//lib/action_cable/test_helper.rb#8
  def before_setup; end

  # source://actioncable-next//lib/action_cable/test_helper.rb#146
  def broadcasts(*_arg0, **_arg1, &_arg2); end

  # Returns the messages that are broadcasted in the block.
  #
  #     def test_broadcasts
  #       messages = capture_broadcasts('messages') do
  #         ActionCable.server.broadcast 'messages', { text: 'hi' }
  #         ActionCable.server.broadcast 'messages', { text: 'how are you?' }
  #       end
  #       assert_equal 2, messages.length
  #       assert_equal({ text: 'hi' }, messages.first)
  #       assert_equal({ text: 'how are you?' }, messages.last)
  #     end
  #
  # source://actioncable-next//lib/action_cable/test_helper.rb#96
  def capture_broadcasts(stream, &block); end

  # source://actioncable-next//lib/action_cable/test_helper.rb#146
  def clear_messages(*_arg0, **_arg1, &_arg2); end

  # source://actioncable-next//lib/action_cable/test_helper.rb#142
  def pubsub_adapter; end

  private

  # source://actioncable-next//lib/action_cable/test_helper.rb#149
  def new_broadcasts_from(current_messages, stream, assertion, &block); end
end

# source://actioncable-next//lib/action_cable/gem_version.rb#11
module ActionCable::VERSION; end

# source://actioncable-next//lib/action_cable/gem_version.rb#12
ActionCable::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://actioncable-next//lib/action_cable/gem_version.rb#13
ActionCable::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://actioncable-next//lib/action_cable/gem_version.rb#15
ActionCable::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# source://actioncable-next//lib/action_cable/gem_version.rb#17
ActionCable::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://actioncable-next//lib/action_cable/gem_version.rb#14
ActionCable::VERSION::TINY = T.let(T.unsafe(nil), Integer)
